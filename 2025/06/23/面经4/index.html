<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/notes.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/notes.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/notes.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/notes.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/notes.github.io/css/main.css">


<link rel="stylesheet" href="/notes.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhan20050128.github.io","root":"/notes.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="0528  binlog是什么？ MySQL的binlog（Binary Log）是一种二进制日志文件，记录了所有对数据库的修改操作（如INSERT、UPDATE、DELETE等），但不包括查询语句（如SELECT）。它以事件形式存储，包含操作的时间、执行时长等信息。  主要作用： ​数据恢复：通过回放binlog可将数据库恢复到特定时间点。 ​主从复制：主库的binlog会被同步到从库，实现数据">
<meta property="og:type" content="article">
<meta property="og:title" content="面经4">
<meta property="og:url" content="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%9D%A2%E7%BB%8F4/index.html">
<meta property="og:site_name" content="cz Blog">
<meta property="og:description" content="0528  binlog是什么？ MySQL的binlog（Binary Log）是一种二进制日志文件，记录了所有对数据库的修改操作（如INSERT、UPDATE、DELETE等），但不包括查询语句（如SELECT）。它以事件形式存储，包含操作的时间、执行时长等信息。  主要作用： ​数据恢复：通过回放binlog可将数据库恢复到特定时间点。 ​主从复制：主库的binlog会被同步到从库，实现数据">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-23T04:27:03.000Z">
<meta property="article:modified_time" content="2025-06-23T04:27:03.415Z">
<meta property="article:author" content="Chen Zhan">
<meta property="article:tag" content="其他">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%9D%A2%E7%BB%8F4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面经4 | cz Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/notes.github.io/atom.xml" title="cz Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/notes.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cz Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/notes.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/notes.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/chenzhan20050128" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%9D%A2%E7%BB%8F4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经4
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:27:03" itemprop="dateCreated datePublished" datetime="2025-06-23T12:27:03+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1>0528</h1>
<ol>
<li>binlog是什么？<br>
MySQL的binlog（Binary Log）是一种二进制日志文件，记录了所有对数据库的修改操作（如INSERT、UPDATE、DELETE等），但不包括查询语句（如SELECT）。它以事件形式存储，包含操作的时间、执行时长等信息。</li>
</ol>
<p>主要作用：</p>
<p>​数据恢复：通过回放binlog可将数据库恢复到特定时间点。<br>
​主从复制：主库的binlog会被同步到从库，实现数据实时同步。<br>
​审计：记录所有数据变更，用于安全审计。<br>
binlog的三种格式：</p>
<p>​Statement-based：记录SQL语句，日志量小但可能因非确定性函数导致主从不一致。<br>
​Row-based：记录行数据变更，精确但日志量大。<br>
​Mixed：混合模式，自动选择Statement或Row格式。<br>
2. MySQL中的日志类型及区别<br>
MySQL主要日志类型包括：</p>
<p>​binlog​（二进制日志）：<br>
作用：数据恢复、主从复制、审计。<br>
存储引擎无关，由Server层实现。<br>
​redo log​（重做日志）：<br>
作用：保证事务的持久性，崩溃恢复时重放未提交的事务。<br>
InnoDB特有，物理日志，记录页面的修改。<br>
​undo log​（回滚日志）：<br>
作用：实现事务回滚和MVCC（多版本并发控制）。<br>
InnoDB特有，逻辑日志，记录修改前的数据。</p>
<p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</p>
<p>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。</p>
<p>当使用 ETag 字段实现的协商缓存的过程：</p>
<p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；<br>
当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：<br>
如果没有过期，则直接使用本地缓存；<br>
如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；<br>
服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：<br>
如果值相等，则返回 304 Not Modified，不会返回资源；<br>
如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；<br>
如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源</p>
<p>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。<br>
注意!!!<br>
实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以后面所有文章讨论 HTTP/1.1 都是建立在没有使用管道化的前提。大家知道有这个功能，但是没有被使用就行了</p>
<p>非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。</p>
<p>然后把你爸爸的「个人信息 + 公钥 + 数字签名」打包成一个数字证书，也就是说这个数字证书包含你爸爸的公钥。</p>
<h3 id="TLS如何为HTTP提供安全性？——以一次完整HTTPS请求为例"><strong>TLS如何为HTTP提供安全性？——以一次完整HTTPS请求为例</strong></h3>
<p>TLS（Transport Layer Security）通过加密、身份验证和完整性保护三大机制，将不安全的HTTP协议升级为安全的HTTPS。以下是<strong>一次完整HTTPS请求的详细流程</strong>，展示TLS如何逐步建立安全通信：</p>
<hr>
<h3 id="1-客户端发起HTTPS请求（Client-Hello）"><strong>1. 客户端发起HTTPS请求（Client Hello）</strong></h3>
<ul>
<li><strong>步骤</strong>：<br>
用户在浏览器输入 <code>https://example.com</code>，浏览器（客户端）向服务器发起TCP连接（默认端口443）。</li>
<li><strong>关键动作</strong>：
<ul>
<li>发送支持的TLS版本（如TLS 1.3）。</li>
<li>列出支持的加密套件（如 <code>TLS_AES_256_GCM_SHA384</code>）。</li>
<li>生成随机数 <strong>Client Random</strong>（用于后续密钥生成）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-服务器响应（Server-Hello）"><strong>2. 服务器响应（Server Hello）</strong></h3>
<ul>
<li><strong>步骤</strong>：<br>
服务器选择双方均支持的TLS版本和加密算法，并返回：
<ul>
<li><strong>Server Random</strong>（另一个随机数）。</li>
<li><strong>数字证书</strong>（包含服务器公钥、域名、CA签名等）。</li>
<li>（可选）要求客户端证书（用于双向认证）。</li>
</ul>
</li>
<li><strong>证书作用</strong>：
<ul>
<li>验证服务器身份（防止中间人攻击）。</li>
<li>提供公钥用于密钥交换（如RSA或ECDHE）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-客户端验证证书"><strong>3. 客户端验证证书</strong></h3>
<ul>
<li><strong>验证内容</strong>：
<ol>
<li><strong>CA可信性</strong>：检查证书是否由受信任的CA（如Let’s Encrypt）签发。</li>
<li><strong>有效期</strong>：确保证书未过期。</li>
<li><strong>域名匹配</strong>：证书中的域名与请求的 <code>example.com</code> 一致。</li>
<li><strong>吊销状态</strong>：通过OCSP或CRL检查证书是否被吊销。</li>
</ol>
</li>
<li><strong>若验证失败</strong>：浏览器显示警告（如“证书无效”）。</li>
</ul>
<hr>
<h3 id="4-密钥交换（Key-Exchange）"><strong>4. 密钥交换（Key Exchange）</strong></h3>
<ul>
<li><strong>非对称加密阶段</strong>：
<ul>
<li><strong>RSA方式</strong>：<br>
客户端生成 <strong>Pre-Master Secret</strong>，用服务器公钥加密后发送，服务器用私钥解密。</li>
<li><strong>ECDHE（推荐）</strong>：<br>
双方通过椭圆曲线Diffie-Hellman算法动态生成 <strong>Pre-Master Secret</strong>，支持前向保密（即使私钥泄露，历史会话也无法解密）。</li>
</ul>
</li>
<li><strong>生成会话密钥</strong>：<br>
客户端和服务器使用 <strong>Client Random + Server Random + Pre-Master Secret</strong>，通过伪随机函数（PRF）生成：
<ul>
<li><strong>对称加密密钥</strong>（如AES-256密钥）。</li>
<li><strong>MAC密钥</strong>（用于校验数据完整性）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-握手完成（Finished）"><strong>5. 握手完成（Finished）</strong></h3>
<ul>
<li><strong>步骤</strong>：<br>
双方发送加密的 <code>Finished</code> 消息，验证握手是否成功。</li>
<li><strong>作用</strong>：
<ul>
<li>确认密钥协商无误。</li>
<li>确保通信未被篡改。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-安全数据传输（对称加密）"><strong>6. 安全数据传输（对称加密）</strong></h3>
<ul>
<li><strong>加密方式</strong>：<br>
使用协商的对称密钥（如AES-256）加密所有HTTP请求和响应。</li>
<li><strong>完整性保护</strong>：<br>
每条消息附加HMAC（如SHA-256）或AEAD（如AES-GCM）标签，防止数据被篡改。</li>
<li><strong>示例</strong>：
<ul>
<li>加密的HTTP请求：<code>GET /login HTTPS/1.1</code> → 加密为乱码传输。</li>
<li>服务器解密后处理，返回加密的响应。</li>
<li></li>
</ul>
</li>
</ul>
<p>HTTP/2 做了什么优化？<br>
HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p>
<p>HTTP/2 是 HTTP 协议的重大升级，旨在解决 HTTP/1.1 的性能瓶颈，提升网络传输效率。以下是 HTTP/2 的主要改进点，结合技术细节和实际应用场景展开说明：</p>
<hr>
<h3 id="1-二进制分帧层（Binary-Framing-Layer）"><strong>1. 二进制分帧层（Binary Framing Layer）</strong></h3>
<ul>
<li><strong>问题</strong>：HTTP/1.1 使用文本格式（如 <code>GET / HTTP/1.1</code>），解析效率低且易出错。</li>
<li><strong>改进</strong>：
<ul>
<li>引入二进制分帧层，将消息拆分为更小的<strong>帧</strong>（Frame），每个帧包含：
<ul>
<li><strong>类型</strong>（如 <code>HEADERS</code>、<code>DATA</code>、<code>PRIORITY</code>）。</li>
<li><strong>流标识符（Stream ID）</strong>：标记帧所属的请求/响应流。</li>
<li><strong>长度和标志位</strong>：控制帧的边界和特性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-多路复用（Multiplexing）"><strong>2. 多路复用（Multiplexing）</strong></h3>
<ul>
<li><strong>问题</strong>：HTTP/1.1 的队头阻塞（HOL Blocking）导致请求必须串行处理，并发需多个 TCP 连接（浏览器限制 6-8 个）。</li>
<li><strong>改进</strong>：
<ul>
<li>在<strong>单个 TCP 连接</strong>上并行传输多个请求/响应，通过 <strong>Stream ID</strong> 区分不同流。</li>
<li>帧可乱序发送，接收方按流 ID 重组。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-头部压缩（HPACK-算法）"><strong>3. 头部压缩（HPACK 算法）</strong></h3>
<ul>
<li><strong>问题</strong>：HTTP/1.1 头部冗余（如 <code>Cookie</code>、<code>User-Agent</code> 重复传输），平均占用 800-1400 字节/请求。</li>
<li><strong>改进</strong>：
<ul>
<li><strong>HPACK 算法</strong>：
<ul>
<li><strong>静态表</strong>：预定义 61 个常见字段（如 <code>:method: GET</code> 用索引 <code>2</code> 表示）。</li>
<li><strong>动态表</strong>：缓存自定义字段，后续请求用索引代替。</li>
<li><strong>Huffman 编码</strong>：压缩字段值。</li>
</ul>
</li>
<li><strong>效果</strong>：头部大小减少 85-90%。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-服务器推送（Server-Push）"><strong>4. 服务器推送（Server Push）</strong></h3>
<ul>
<li><strong>问题</strong>：HTTP/1.1 需客户端解析 HTML 后才发现依赖资源（如 CSS/JS），导致多次 RTT。</li>
<li><strong>改进</strong>：
<ul>
<li>服务器可主动推送关联资源（如 <code>PUSH_PROMISE</code> 帧推送 CSS）。</li>
<li>客户端可通过 <code>RST_STREAM</code> 拒绝冗余推送。</li>
</ul>
</li>
<li><strong>优化建议</strong>：
<ul>
<li>推送关键资源（如首屏 CSS），体积控制在 50KB 以内。<br>
​HTTP/2 中的 Stream（流）概念详解<br>
HTTP/2 的核心改进之一是引入了 ​Stream（流）​ 机制，它彻底改变了 HTTP/1.1 的串行请求-响应模型，实现了真正的多路复用（Multiplexing）。以下是 Stream 的核心特性和工作原理：<br>
​1. Stream 的定义<br>
​Stream 是 HTTP/2 连接中的虚拟双向通道，用于承载独立的请求和响应。<br>
每个 Stream 由唯一的 ​Stream ID 标识（31 位无符号整数），客户端发起的 Stream ID 为奇数，服务器发起的为偶数。<br>
​帧（Frame）是 Stream 的最小传输单位，例如：<br>
HEADERS 帧：传输 HTTP 头部。<br>
DATA 帧：传输实际数据（如 HTML、图片）。<br>
PRIORITY 帧：设置优先级。<br>
​2. Stream 的核心特性<br>
​**(1) 多路复用（Multiplexing）​**<br>
​单 TCP 连接支持多个并发 Stream：<br>
在 HTTP/1.1 中，浏览器需要建立多个 TCP 连接（通常 6-8 个）以实现并发，而 HTTP/2 只需 ​1 个 TCP 连接即可并行处理数百个 Stream。<br>
​示例：客户端可以同时发送 Stream 1（请求 HTML）和 Stream 3（请求 JS），服务器可以交错返回它们的帧（如 A1 -&gt; B1 -&gt; A2 -&gt; B2）。<br>
​**(2) 帧的乱序与有序**<br>
​不同 Stream 的帧可以乱序发送：<br>
接收方通过 Stream ID 重新组装帧，因此不同 Stream 的帧可以交替传输（如 A1 -&gt; B1 -&gt; A2 -&gt; B2）。<br>
​同一 Stream 的帧必须有序：<br>
例如，Stream 1 的 HEADERS 帧必须排在 DATA 帧之前，否则会导致解析错误。</li>
</ul>
</li>
</ul>
<p>​## MySQL为什么选择B+树？<br>
​更少的磁盘I/O<br>
B+树的非叶子节点仅存储索引，使得单节点可存储更多键值，​降低树高，减少查询时的磁盘访问次数。<br>
​稳定的查询性能<br>
所有查询均需访问叶子节点，时间复杂度恒为O(log n)，避免B树因数据位置不同导致的性能波动。<br>
​高效的范围查询<br>
叶子节点的链表结构使范围查询只需定位起始点后顺序遍历，无需回溯。<br>
​更适合磁盘存储<br>
B+树的节点大小通常设计为磁盘块（如16KB），​充分利用预读特性，减少随机I/O。<br>
​支持覆盖索引<br>
二级索引的叶子节点直接存储主键值，避免回表（如查询字段全在索引中时</p>
<h2 id="JMM-happens-before">JMM happens-before</h2>
<p>Happens-Before 原则是 JMM 中定义的操作间的顺序规则，确保操作的有序性和可见性。具体包括以下八个规则：</p>
<p>程序次序规则：一个线程中的每个操作，按照程序代码的顺序发生。<br>
监视器锁规则：一个解锁操作发生在同一个锁的随后的加锁操作之前。<br>
volatile 变量规则：对一个 volatile 变量的写操作发生在对该变量的随后的读操作之前。<br>
线程启动规则：在一个线程中对另一个线程的 Thread.start() 调用发生在这个新线程的每一个操作之前。<br>
线程终止规则：一个线程中的所有操作都发生在另一个线程检测到这个线程已经终止（通过 Thread.join() 返回）之前。<br>
线程中断规则：对线程的中断操作（Thread.interrupt()）发生在被中断线程检测到中断事件（通过 Thread.interrupted() 或 Thread.isInterrupted()）之前。<br>
对象终结规则：一个对象的构造函数执行结束发生在这个对象的 finalize() 方法之前。<br>
传递性：如果操作 A Happens-Before 操作 B，操作 B Happens-Before 操作 C，那么操作 A Happens-Before 操作 C。</p>
<h2 id="秒杀">秒杀</h2>
<p>瞬时流量的承接<br>
​问题：秒杀开始瞬间可能产生百万级QPS，需避免系统崩溃。<br>
​解决方案：<br>
​分层过滤：<br>
​前端限流：按钮置灰+动态URL防刷。<br>
​CDN缓存静态页面，减少后端请求。<br>
​Nginx限流：令牌桶算法限制每秒请求数（如limit_req模块）。<br>
​异步削峰：请求先入消息队列（如Kafka/RabbitMQ），后端异步处理订单。<br>
​独立部署：秒杀服务与主业务隔离，避免资源竞争。<br>
​2. 防止超卖<br>
​问题：高并发下库存扣减可能超量。<br>
​解决方案：<br>
​预扣库存：Redis原子操作（DECR）预减库存，避免直接访问DB。<br>
​分布式锁：Redis的SETNX或Redisson锁保证扣库存原子性。<br>
​乐观锁：SQL条件控制（如UPDATE stock SET count=count-1 WHERE count&gt;=1）。<br>
​最终一致性：MQ异步同步库存至数据库。<br>
​3. 预防黑产<br>
​问题：机器脚本刷单、僵尸账号占库存。<br>
​解决方案：<br>
​验证码：图形/滑块验证码拦截脚本请求。<br>
​行为分析：检测异常点击频率、鼠标轨迹。<br>
​设备指纹：记录IP、设备ID限制重复请求。<br>
​账号分级：限制低等级账号参与或设置购买上限。<br>
​4. 避免对正常服务的影响<br>
​问题：秒杀流量挤占常规业务资源。<br>
​解决方案：<br>
​服务隔离：秒杀使用独立集群、DB分库。<br>
​熔断降级：非核心功能（如推荐服务）自动关闭（Hystrix/Sentinel）。<br>
​动态扩容：云服务器弹性伸缩应对峰值。<br>
​5. 兜底方案<br>
​问题：极端情况下系统容灾。<br>
​解决方案：<br>
​降级策略：静态页展示“活动火爆”提示，或排队页面。<br>
​数据回滚：超卖时通过事务日志补偿库存。<br>
​多活部署：跨机房容灾，故障自动切换。</p>
<h2 id="RabbitMQ-和-Kafka">RabbitMQ 和 Kafka</h2>
<p>核心架构差异<br>
​RabbitMQ</p>
<p>​代理模式：基于AMQP协议，采用智能代理（Broker）架构，由Exchange、Queue、Binding组成，支持复杂路由规则（如Direct、Fanout、Topic）。<br>
​推送模型：消息由Broker主动推送给消费者，适合低延迟场景。<br>
​垂直扩展：通过增加单节点资源提升性能，适合中小规模系统。<br>
​Kafka</p>
<p>​流平台：基于分区日志的分布式设计，消息按顺序追加到分区，支持高吞吐和水平扩展。<br>
​拉取模型：消费者主动从分区拉取消息，牺牲延迟换取高吞吐。<br>
​持久化：消息默认保留多天，支持回溯和批量处理。</p>
<p>关键功能对比<br>
​对比项	​RabbitMQ	​Kafka<br>
​消息顺序	单队列严格有序（FIFO）	单分区有序，全局无序<br>
​吞吐量	万级QPS（依赖ACK机制）	百万级QPS，适合大数据流<br>
​消息可靠性	支持ACK、重试、死信队列	无内置重试，需自行实现<br>
​消息留存	消费后默认删除	长期留存，支持回溯<br>
​路由灵活性	支持多协议（AMQP/MQTT等）和复杂路由	仅Topic分区，路由简单<br>
​延迟	毫秒级（推送模型）	较高（拉取模型）<br>
​3. 适用场景<br>
​优先选择RabbitMQ的情况<br>
​企业级应用：需要严格消息顺序、复杂路由（如金融交易）。<br>
​低延迟任务：如实时通知、任务队列。<br>
​灵活错误处理：内置ACK和重试机制，适合容错要求高的场景。<br>
​优先选择Kafka的情况<br>
​大数据流处理：如日志聚合、实时分析（如用户行为跟踪）。<br>
​高吞吐场景：如电商秒杀、IoT设备数据。<br>
​事件溯源：需长期存储和回溯消息（如审计日志）</p>
<h1>RabbitMQ vs Kafka 在你的项目中的适用性分析</h1>
<p>你的Tomato-Mall电商项目目前选择了RabbitMQ作为消息队列解决方案，这是一个合适的选择。以下是详细分析为什么RabbitMQ比Kafka更适合你的项目：</p>
<h2 id="1-消息处理模式">1. 消息处理模式</h2>
<p><strong>RabbitMQ更适合你的场景</strong>：</p>
<ul>
<li>你的项目主要处理<strong>业务事件</strong>（订单超时、支付结果）而非数据流</li>
<li>需要<strong>即时处理</strong>消息（如订单超时后立即释放库存）</li>
<li>消息消费后通常不需要长期保留</li>
</ul>
<p><strong>Kafka的不足</strong>：</p>
<ul>
<li>Kafka设计用于<strong>高吞吐量数据流</strong>处理，消息会持久化较长时间</li>
<li>对于你的即时业务处理场景显得&quot;过重&quot;</li>
</ul>
<h2 id="2-消息传递语义">2. 消息传递语义</h2>
<p><strong>RabbitMQ优势</strong>：</p>
<ul>
<li>提供了你需要的<strong>精确一次投递</strong>语义（通过ACK机制）</li>
<li>支持<strong>死信队列</strong>（已在你的订单超时处理中使用）</li>
<li>内置<strong>消息优先级</strong>（虽然你的项目目前未使用）</li>
</ul>
<p><strong>Kafka的局限</strong>：</p>
<ul>
<li>默认是&quot;至少一次&quot;语义，实现精确一次较复杂</li>
<li>没有原生的死信队列概念</li>
</ul>
<h2 id="3-延迟消息处理">3. 延迟消息处理</h2>
<p><strong>RabbitMQ的优势</strong>：</p>
<ul>
<li>你的项目使用RabbitMQ的<strong>延迟队列插件</strong>处理订单超时</li>
<li>配置简单直观（如你的<code>orderDelayQueue</code>）</li>
</ul>
<p><strong>Kafka的不足</strong>：</p>
<ul>
<li>没有内置延迟消息支持</li>
<li>需要自行实现时间轮等复杂机制</li>
</ul>
<h2 id="4-消息量级和吞吐">4. 消息量级和吞吐</h2>
<p><strong>你的项目特点</strong>：</p>
<ul>
<li>电商系统消息量中等（订单、支付相关）</li>
<li>不需要极高吞吐（每天万级消息已足够）</li>
<li>消息大小较小（主要是订单ID、状态等）</li>
</ul>
<p><strong>RabbitMQ足够应对</strong>：</p>
<ul>
<li>单节点可支持数万TPS</li>
<li>消息体积小，不会成为瓶颈</li>
</ul>
<p><strong>Kafka的优势无法发挥</strong>：</p>
<ul>
<li>Kafka的百万级TPS优势在你的场景中不需要</li>
<li>会增加不必要的复杂性</li>
</ul>
<h2 id="5-运维复杂度">5. 运维复杂度</h2>
<p><strong>RabbitMQ更简单</strong>：</p>
<ul>
<li>你的配置已经展示了简单易用的特点</li>
<li>轻量级，适合中小型项目</li>
<li>社区支持好，问题容易解决</li>
</ul>
<p><strong>Kafka更复杂</strong>：</p>
<ul>
<li>需要Zookeeper协调</li>
<li>配置调优复杂</li>
<li>资源消耗更大</li>
</ul>
<p>Spring @Transactional 事务传播行为详解<br>
@Transactional 的事务传播行为(Propagation Behavior)定义了多个事务方法相互调用时，事务应该如何传播。这是 Spring 事务管理的核心特性之一，理解它对设计复杂业务逻辑至关重要。</p>
<p>传播行为类型<br>
Spring 提供了 7 种传播行为，通过 Propagation 枚举定义：</p>
<ol>
<li>REQUIRED（默认）<br>
​行为：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务<br>
​适用场景：大多数业务方法的默认选择<br>
​示例：<br>
@Transactional(propagation = Propagation.REQUIRED)<br>
public void methodA() {<br>
// 如果调用方有事务，则加入；否则新建事务<br>
methodB();<br>
}</li>
</ol>
<p>@Transactional(propagation = Propagation.REQUIRED)<br>
public void methodB() {<br>
// 加入methodA的事务<br>
}<br>
2. SUPPORTS<br>
​行为：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行<br>
​适用场景：查询方法，可以适应调用方的事务需求<br>
​示例：<br>
@Transactional(propagation = Propagation.SUPPORTS)<br>
public void queryData() {<br>
// 如果调用方有事务，则加入；否则无事务执行<br>
}<br>
3. MANDATORY<br>
​行为：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常<br>
​适用场景：强制要求必须在事务中执行的方法<br>
​示例：<br>
@Transactional(propagation = Propagation.MANDATORY)<br>
public void mandatoryOperation() {<br>
// 必须在事务中调用，否则抛出IllegalTransactionStateException<br>
}<br>
4. REQUIRES_NEW<br>
​行为：创建一个新事务，如果当前存在事务，则挂起当前事务<br>
​适用场景：需要独立事务执行的方法，不受外层事务影响<br>
​示例：<br>
@Transactional(propagation = Propagation.REQUIRES_NEW)<br>
public void logOperation() {<br>
// 总是新建事务，外层事务回滚不影响此方法<br>
}<br>
5. NOT_SUPPORTED<br>
​行为：以非事务方式执行操作，如果当前存在事务，则挂起该事务<br>
​适用场景：不需要事务支持的方法，如某些日志记录<br>
​示例：<br>
@Transactional(propagation = Propagation.NOT_SUPPORTED)<br>
public void nonTransactionalMethod() {<br>
// 无事务执行，即使调用方有事务也会被挂起<br>
}<br>
6. NEVER<br>
​行为：以非事务方式执行，如果当前存在事务，则抛出异常<br>
​适用场景：严格要求不能在事务中执行的方法<br>
​示例：<br>
@Transactional(propagation = Propagation.NEVER)<br>
public void mustNotInTransaction() {<br>
// 如果调用方有事务，则抛出异常<br>
}<br>
7. NESTED<br>
​行为：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则创建一个新事务<br>
​适用场景：需要部分回滚的复杂业务场景<br>
​示例：<br>
@Transactional(propagation = Propagation.NESTED)<br>
public void nestedOperation() {<br>
// 在外层事务中创建保存点(SAVEPOINT)<br>
// 可以独立回滚而不影响外层事务<br>
}<br>
传播行为对比表<br>
传播行为	当前存在事务	当前无事务<br>
REQUIRED	加入当前事务	创建新事务<br>
SUPPORTS	加入当前事务	非事务执行<br>
MANDATORY	加入当前事务	抛出异常<br>
REQUIRES_NEW	挂起当前事务，创建新事务	创建新事务<br>
NOT_SUPPORTED	挂起当前事务，非事务执行	非事务执行<br>
NEVER	抛出异常	非事务执行</p>
<h2 id="gapLock-nextKeyLock时机">gapLock nextKeyLock时机</h2>
<p>可重复读（Repeatable Read）隔离级别下间隙锁（Gap Lock）和 Next - Key Lock 的使用时机</p>
<ol>
<li>范围查询时 使用邻键锁 ：<br>
当在可重复读隔离级别下， 执行带有范围条件的查询语句时：如<br>
SELECT… FROM table WHERE column BETWEEN value1 AND value2 FOR UPDATE<br>
或<br>
SELECT… FROM table WHERE column &gt; value1 AND column &lt; value2 FOR UPDATE<br>
会使用间隙锁和 Next - Key Lock。<br>
例如，在一个按年龄字段索引的用户表中，执行<br>
SELECT * FROM users WHERE age BETWEEN 20 AND 30 FOR UPDATE，<br>
如果表中存在年龄为 20、25、30 的用户记录，那么会锁定年龄在 (20, 25]、(25, 30] 以及 20 和 30 对应的记录行，防止其他事务在这个年龄范围内插入新记录，避免幻读问题。</li>
<li>插入操作引发时 使用邻键锁 ：<br>
如果在一个事务中，先进行范围查询，然后准备插入一条新记录，而这条新记录的值处于之前查询的范围区间内，也会触发间隙锁和 Next - Key Lock。<br>
假设事务 A 先执行SELECT * FROM products WHERE price &gt; 100 AND price &lt; 200 FOR UPDATE，之后事务 A 准备插入一条price为 150 的新商品记录，此时会锁定 (100, 200) 这个区间，防止其他事务在该区间插入数据，确保事务 A 再次查询该范围时，数据的一致性。</li>
<li>唯一索引冲突检测时 使用邻键锁 ：<br>
当插入或更新数据时，如果涉及到唯一索引，并且在可重复读隔离级别下，为了防止其他事务在同一时刻插入相同唯一值的数据，会使用 Next - Key Lock。<br>
例如，在一个用户表中，email字段设置为唯一索引，当一个事务执行下面的sql ，<br>
INSERT INTO users (name, email) VALUES (‘张三’, ‘zhangsan@example.com’)<br>
会锁定email索引上对应值的 Next - Key 范围，确保在事务完成前，其他事务不能插入相同email的记录，保证唯一索引的约束性和数据一致性。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/notes.github.io/tags/%E5%85%B6%E4%BB%96/" rel="tag"># 其他</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/notes.github.io/2025/06/23/%E9%9D%A2%E7%BB%8F/" rel="prev" title="面经">
      <i class="fa fa-chevron-left"></i> 面经
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">0528</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TLS%E5%A6%82%E4%BD%95%E4%B8%BAHTTP%E6%8F%90%E4%BE%9B%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F%E2%80%94%E2%80%94%E4%BB%A5%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4HTTPS%E8%AF%B7%E6%B1%82%E4%B8%BA%E4%BE%8B"><span class="nav-number">1.0.1.</span> <span class="nav-text">TLS如何为HTTP提供安全性？——以一次完整HTTPS请求为例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7HTTPS%E8%AF%B7%E6%B1%82%EF%BC%88Client-Hello%EF%BC%89"><span class="nav-number">1.0.2.</span> <span class="nav-text">1. 客户端发起HTTPS请求（Client Hello）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%EF%BC%88Server-Hello%EF%BC%89"><span class="nav-number">1.0.3.</span> <span class="nav-text">2. 服务器响应（Server Hello）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6"><span class="nav-number">1.0.4.</span> <span class="nav-text">3. 客户端验证证书</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%EF%BC%88Key-Exchange%EF%BC%89"><span class="nav-number">1.0.5.</span> <span class="nav-text">4. 密钥交换（Key Exchange）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8F%A1%E6%89%8B%E5%AE%8C%E6%88%90%EF%BC%88Finished%EF%BC%89"><span class="nav-number">1.0.6.</span> <span class="nav-text">5. 握手完成（Finished）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AE%89%E5%85%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%89"><span class="nav-number">1.0.7.</span> <span class="nav-text">6. 安全数据传输（对称加密）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7%E5%B1%82%EF%BC%88Binary-Framing-Layer%EF%BC%89"><span class="nav-number">1.0.8.</span> <span class="nav-text">1. 二进制分帧层（Binary Framing Layer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88Multiplexing%EF%BC%89"><span class="nav-number">1.0.9.</span> <span class="nav-text">2. 多路复用（Multiplexing）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9%EF%BC%88HPACK-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.0.10.</span> <span class="nav-text">3. 头部压缩（HPACK 算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%EF%BC%88Server-Push%EF%BC%89"><span class="nav-number">1.0.11.</span> <span class="nav-text">4. 服务器推送（Server Push）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM-happens-before"><span class="nav-number">1.1.</span> <span class="nav-text">JMM happens-before</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%92%E6%9D%80"><span class="nav-number">1.2.</span> <span class="nav-text">秒杀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ-%E5%92%8C-Kafka"><span class="nav-number">1.3.</span> <span class="nav-text">RabbitMQ 和 Kafka</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">RabbitMQ vs Kafka 在你的项目中的适用性分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">1. 消息处理模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E8%AF%AD%E4%B9%89"><span class="nav-number">2.2.</span> <span class="nav-text">2. 消息传递语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">3. 延迟消息处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%B6%88%E6%81%AF%E9%87%8F%E7%BA%A7%E5%92%8C%E5%90%9E%E5%90%90"><span class="nav-number">2.4.</span> <span class="nav-text">4. 消息量级和吞吐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%BF%90%E7%BB%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.5.</span> <span class="nav-text">5. 运维复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gapLock-nextKeyLock%E6%97%B6%E6%9C%BA"><span class="nav-number">2.6.</span> <span class="nav-text">gapLock nextKeyLock时机</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Zhan"
      src="/notes.github.io/images/woshicaigou.jpg">
  <p class="site-author-name" itemprop="name">Chen Zhan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/notes.github.io/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Zhan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/notes.github.io/lib/anime.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/notes.github.io/js/utils.js"></script>

<script src="/notes.github.io/js/motion.js"></script>


<script src="/notes.github.io/js/schemes/pisces.js"></script>


<script src="/notes.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

</body>
</html>
