<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/notes.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/notes.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/notes.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/notes.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/notes.github.io/css/main.css">


<link rel="stylesheet" href="/notes.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhan20050128.github.io","root":"/notes.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="数据库中B+树相对于B树的优点总结 更高效的磁盘I&#x2F;O    B+树的非叶子节点仅存储键值和指针（不存储实际数据），使得单个节点能容纳更多索引项，从而降低树的高度，减少磁盘I&#x2F;O次数。   所有数据仅存储在叶子节点，查询时需访问叶子节点，但通过减少中间节点的数据冗余，整体I&#x2F;O效率更高。    更优的范围查询性能    B+树的叶子节点通过链表相连，范围查询时只需遍历">
<meta property="og:type" content="article">
<meta property="og:title" content="准备0603">
<meta property="og:url" content="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%870603/index.html">
<meta property="og:site_name" content="cz Blog">
<meta property="og:description" content="数据库中B+树相对于B树的优点总结 更高效的磁盘I&#x2F;O    B+树的非叶子节点仅存储键值和指针（不存储实际数据），使得单个节点能容纳更多索引项，从而降低树的高度，减少磁盘I&#x2F;O次数。   所有数据仅存储在叶子节点，查询时需访问叶子节点，但通过减少中间节点的数据冗余，整体I&#x2F;O效率更高。    更优的范围查询性能    B+树的叶子节点通过链表相连，范围查询时只需遍历">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chenzhan20050128.github.io/notes.github.io/image.png">
<meta property="article:published_time" content="2025-06-23T04:27:03.000Z">
<meta property="article:modified_time" content="2025-06-23T04:27:03.413Z">
<meta property="article:author" content="Chen Zhan">
<meta property="article:tag" content="其他">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chenzhan20050128.github.io/notes.github.io/image.png">

<link rel="canonical" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%870603/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>准备0603 | cz Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/notes.github.io/atom.xml" title="cz Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/notes.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cz Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/notes.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/notes.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/chenzhan20050128" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%870603/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          准备0603
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:27:03" itemprop="dateCreated datePublished" datetime="2025-06-23T12:27:03+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="数据库中B-树相对于B树的优点总结"><a href="#数据库中B-树相对于B树的优点总结" class="headerlink" title="数据库中B+树相对于B树的优点总结"></a>数据库中B+树相对于B树的优点总结</h2><ol>
<li><p><strong>更高效的磁盘I&#x2F;O</strong>  </p>
<ul>
<li>B+树的非叶子节点仅存储键值和指针（不存储实际数据），使得单个节点能容纳更多索引项，从而降低树的高度，减少磁盘I&#x2F;O次数。  </li>
<li>所有数据仅存储在叶子节点，查询时需访问叶子节点，但通过减少中间节点的数据冗余，整体I&#x2F;O效率更高。</li>
<li></li>
</ul>
</li>
<li><p><strong>更优的范围查询性能</strong>  </p>
<ul>
<li>B+树的叶子节点通过链表相连，范围查询时只需遍历链表即可，无需回溯上层节点；而B树需多次跨层访问。  </li>
<li>例如，查询区间<code>[a, b]</code>时，B+树只需定位到起始叶子节点后顺序扫描，时间复杂度接近O(n)。</li>
</ul>
</li>
<li><p><strong>更稳定的查询性能</strong>  </p>
<ul>
<li>B+树的查询必须到达叶子节点，路径长度固定，性能稳定；B树可能在中间节点提前终止查询，导致性能波动。</li>
</ul>
</li>
<li><p><strong>更适合顺序访问与全表扫描</strong>  </p>
<ul>
<li>叶子节点的链表结构支持高效顺序遍历，适合全表扫描或排序操作；B树需复杂的中序遍历。</li>
</ul>
</li>
<li><p><strong>更优的并发控制</strong>  ！！</p>
<ul>
<li>B+树的叶子节点独立存储数据，更新操作通常仅影响局部叶子节点，减少锁竞争，适合高并发场景。  </li>
<li>B树的分裂&#x2F;合并可能涉及更多层级，并发控制复杂度更高。</li>
</ul>
</li>
<li><p><strong>缓存友好性</strong>  </p>
<ul>
<li>B+树的数据集中在叶子节点且连续存储，预读机制能更高效利用磁盘缓存。</li>
</ul>
</li>
<li><p><strong>适应大规模数据</strong>  </p>
<ul>
<li>B+树的扁平化结构使其在处理海量数据时仍能保持较低高度，而B树可能因数据分散导致深度增加。</li>
</ul>
</li>
</ol>
<h2 id="索引失效的常见场景"><a href="#索引失效的常见场景" class="headerlink" title="索引失效的常见场景"></a>索引失效的常见场景</h2><p>违反最左前缀原则：联合索引未从最左列开始使用18</p>
<p>使用OR条件：查询条件包含OR且OR两边字段不全有索引58</p>
<p>对索引列运算：如WHERE age+1&#x3D;20或使用函数WHERE YEAR(create_time)&#x3D;202318</p>
<p>类型不一致：字符串列与数字比较WHERE name&#x3D;1232</p>
<p>LIKE以通配符开头：WHERE name LIKE ‘%张’12</p>
<p>使用!&#x3D;或&lt;&gt;：WHERE status !&#x3D; 128 范围查询(&gt;,&lt;,BETWEEN,LIKE)会使右侧列索引失效</p>
<p>IS NULL&#x2F;IS NOT NULL：某些情况下会导致索引失效2</p>
<p>全表扫描更快：当MySQL优化器判断全表扫描比索引更快时8</p>
<p>InnoDB的MVCC（多版本并发控制）机制通过隐藏列、Undo Log和Read View协同工作，实现高并发下的数据一致性。以下是插入和访问数据的完整过程及底层细节：</p>
<hr>
<h2 id="MVCC-插入and查找数据的完整过程"><a href="#MVCC-插入and查找数据的完整过程" class="headerlink" title="MVCC 插入and查找数据的完整过程"></a>MVCC 插入and查找数据的完整过程</h2><h3 id="一、插入数据的完整过程"><a href="#一、插入数据的完整过程" class="headerlink" title="一、插入数据的完整过程"></a><strong>一、插入数据的完整过程</strong></h3><ol>
<li><p><strong>分配事务ID</strong><br>事务开始时，系统分配一个全局递增的事务ID（<code>trx_id</code>），例如<code>trx_id=100</code>。</p>
</li>
<li><p><strong>写入隐藏列</strong><br>插入新行时，InnoDB为数据行添加三个隐藏字段：</p>
<ul>
<li><code>DB_ROW_ID</code>：唯一行ID（若未显式定义主键则自动生成）。</li>
<li><code>DB_TRX_ID</code>：记录操作该行的事务ID（即<code>trx_id=100</code>）。</li>
<li><code>DB_ROLL_PTR</code>（回滚指针）：指向该行在Undo Log中的历史版本，初始为<code>NULL</code>（因无历史版本）。</li>
</ul>
</li>
<li><p><strong>生成Undo Log记录</strong><br>在Undo Log中记录插入前的状态（逻辑为空），用于事务回滚时删除该行。</p>
</li>
<li><p><strong>更新聚簇索引</strong><br>数据写入聚簇索引的叶子节点，同时更新非聚簇索引（若有）。</p>
</li>
</ol>
<hr>
<h3 id="二、访问（查询）数据的完整过程"><a href="#二、访问（查询）数据的完整过程" class="headerlink" title="二、访问（查询）数据的完整过程"></a><strong>二、访问（查询）数据的完整过程</strong></h3><h4 id="步骤1：创建Read-View（可见性判断依据）"><a href="#步骤1：创建Read-View（可见性判断依据）" class="headerlink" title="步骤1：创建Read View（可见性判断依据）"></a><strong>步骤1：创建Read View（可见性判断依据）</strong></h4><p>事务首次执行<code>SELECT</code>时生成Read View，包含：</p>
<ul>
<li><code>trx_ids</code>：当前所有活跃事务ID列表（如<code>[101, 102]</code>）。</li>
<li><code>up_limit_id</code>：最小活跃事务ID（如<code>101</code>）。</li>
<li><code>low_limit_id</code>：系统下一个将分配的事务ID（如<code>103</code>）。</li>
</ul>
<h4 id="步骤2：遍历版本链，判断可见性"><a href="#步骤2：遍历版本链，判断可见性" class="headerlink" title="步骤2：遍历版本链，判断可见性"></a><strong>步骤2：遍历版本链，判断可见性</strong></h4><p>对于目标数据行，从最新版本开始，沿<code>DB_ROLL_PTR</code>回溯版本链，按规则判断可见性：</p>
<ol>
<li><strong>若行记录的<code>DB_TRX_ID &lt; up_limit_id</code></strong><br>说明该版本在Read View创建前已提交，<strong>可见</strong>（例如<code>DB_TRX_ID=99</code>）。</li>
<li><strong>若<code>DB_TRX_ID &gt;= low_limit_id</code></strong><br>说明该版本在Read View创建后才生成，<strong>不可见</strong>（例如<code>DB_TRX_ID=103</code>）。</li>
<li><strong>若<code>DB_TRX_ID</code>在<code>[up_limit_id, low_limit_id)</code>区间</strong>：  <ul>
<li><strong>在<code>trx_ids</code>列表中</strong>：生成该版本的事务仍活跃（未提交），<strong>不可见</strong>（如<code>DB_TRX_ID=101</code>）。</li>
<li><strong>不在<code>trx_ids</code>列表中</strong>：生成该版本的事务已提交，<strong>可见</strong>（如<code>DB_TRX_ID=95</code>）。</li>
</ul>
</li>
</ol>
<h4 id="步骤3：返回匹配版本"><a href="#步骤3：返回匹配版本" class="headerlink" title="步骤3：返回匹配版本"></a><strong>步骤3：返回匹配版本</strong></h4><p>找到首个可见版本后返回数据；若全不可见则返回空。</p>
<blockquote>
<p><strong>示例场景</strong>（事务ID&#x3D;100查询某行）：</p>
<ul>
<li>版本链：<code>当前版本(trx_id=102) → 历史版本(trx_id=90)</code></li>
<li>Read View：<code>trx_ids=[101, 102]</code>, <code>up_limit_id=101</code>, <code>low_limit_id=103</code></li>
<li>判断：<ul>
<li>当前版本<code>trx_id=102</code>在<code>trx_ids</code>中 → 不可见。</li>
<li>历史版本<code>trx_id=90 &lt; up_limit_id(101)</code> → 可见，返回此版本数据。</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="三、关键机制详解"><a href="#三、关键机制详解" class="headerlink" title="三、关键机制详解"></a><strong>三、关键机制详解</strong></h3><ol>
<li><p><strong>版本链管理</strong>  </p>
<ul>
<li>每次更新&#x2F;删除时，旧数据拷贝至Undo Log，新行<code>DB_TRX_ID</code>更新为当前事务ID，<code>DB_ROLL_PTR</code>指向旧版本。</li>
<li>删除操作标记<code>DB_TRX_ID</code>为删除事务ID，不立即物理删除。</li>
</ul>
</li>
<li><p><strong>隔离级别的影响</strong>  </p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>Read View生成策略</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><strong>读已提交 (RC)</strong></td>
<td>每次<code>SELECT</code>都生成新Read View</td>
<td>可能读到其他事务已提交的修改</td>
</tr>
<tr>
<td><strong>可重复读 (RR)</strong></td>
<td>事务首次<code>SELECT</code>生成Read View并复用</td>
<td>全程读取同一快照，避免不可重复读</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Purge机制</strong><br>后台线程定期清理不再被任何事务引用的Undo Log版本（如已提交事务的旧版本）。</p>
</li>
</ol>
<hr>
<h3 id="四、流程图解"><a href="#四、流程图解" class="headerlink" title="四、流程图解"></a><strong>四、流程图解</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[事务开始] --&gt; B[插入数据]</span><br><span class="line">    B --&gt; C1[分配trx_id]</span><br><span class="line">    C1 --&gt; C2[写入隐藏字段]</span><br><span class="line">    C2 --&gt; C3[生成Undo Log]</span><br><span class="line">    C3 --&gt; D[更新索引]</span><br><span class="line"></span><br><span class="line">    E[查询数据] --&gt; F&#123;首次SELECT?&#125;</span><br><span class="line">    F --&gt;|是| G[创建Read View]</span><br><span class="line">    F --&gt;|否| H[复用Read View]</span><br><span class="line">    G/H --&gt; I[遍历版本链]</span><br><span class="line">    I --&gt; J&#123;检查DB_TRX_ID&#125;</span><br><span class="line">    J --&gt;|可见| K[返回数据]</span><br><span class="line">    J --&gt;|不可见| L[回溯上一版本]</span><br><span class="line">    L --&gt; J</span><br></pre></td></tr></table></figure>

<p>此机制确保：</p>
<ul>
<li>插入时：生成新版本并关联事务ID。</li>
<li>查询时：通过Read View过滤版本链，实现无锁快照读。</li>
<li>更新&#x2F;删除时：创建新版本，旧版本进入Undo Log。</li>
</ul>
<h2 id="限流与降级"><a href="#限流与降级" class="headerlink" title="限流与降级"></a>限流与降级</h2><p>多级降级策略：</p>
<p>一级降级：关闭非核心服务（如推荐、评论）</p>
<p>二级降级：简化核心业务流程（如跳过风控检查）</p>
<p>三级降级：静态化返回结果（如直接返回”秒杀已结束”）<br>用户请求<br>  ↓ (100万QPS)<br>前端限流（验证码、按钮控制）<br>  ↓ (30万QPS)<br>Nginx限流（IP限制、频率控制）<br>  ↓ (10万QPS)<br>网关限流（API配额、集群限流）<br>  ↓ (1万QPS)<br>服务限流（线程池、信号量）<br>  ↓ (1000QPS)<br>数据库（最终写入）</p>
<p>用户在前端点击秒杀按钮<br>前端进行防重复点击和请求频率限制<br>请求发出，后端进行限流（QPS&#x2F;IP限制）<br>请求进入排队队列（如果系统压力大）<br>排队到达，后端确认库存（预减库存）<br>若库存充足，订单成功，库存减一<br>若库存不足或系统压力大，采取降级措施（快速失败、功能降级）<br>前端根据后端返回显示用户最终状态（成功&#x2F;失败&#x2F;排队中）</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>当前线程数 &lt; corePoolSize<br>​行为：直接创建新线程（核心线程）处理任务。<br>​示例：若corePoolSize&#x3D;2，提交第1、2个任务时会立即创建2个线程执行。<br>​当前线程数 ≥ corePoolSize 且队列未满<br>​行为：任务放入队列等待执行。<br>​示例：corePoolSize&#x3D;2，队列容量&#x3D;3。提交第3、4、5个任务时，任务进入队列，由空闲的核心线程处理。<br>​队列已满且线程数 &lt; maximumPoolSize<br>​行为：创建非核心线程处理新任务。<br>​示例：maximumPoolSize&#x3D;5，队列已满时，提交第6、7个任务会创建第3、4个线程（非核心线程）。<br>​线程数 &#x3D; maximumPoolSize 且队列已满<br>​行为：触发拒绝策略（如抛出异常AbortPolicy或由调用线程执行CallerRunsPolicy）。<br>​示例：maximumPoolSize&#x3D;5，队列已满时，提交第8个任务会触发拒绝策略。</p>
<p>如何选择队列？<br>场景	推荐队列	理由<br>高吞吐，允许任务积压	LinkedBlockingQueue	避免频繁创建&#x2F;销毁线程，但需警惕OOM。<br>严格控制队列长度	ArrayBlockingQueue	防止资源耗尽，配合maximumPoolSize实现弹性扩容。<br>低延迟，拒绝任务堆积	SynchronousQueue	任务直接执行或拒绝，适合短任务且要求快速响应的场景。<br>按优先级处理任务	PriorityBlockingQueue	适用于任务有明确优先级的场景（如VIP用户请求优先）。<br>​<br><img src="/notes.github.io/image.png" alt="alt text"></p>
<h2 id="spring单例模式"><a href="#spring单例模式" class="headerlink" title="spring单例模式"></a>spring单例模式</h2><p>Spring 框架中的单例模式是其 IoC 容器的核心设计之一，通过<strong>单例注册表</strong>（如 <code>ConcurrentHashMap</code>）实现 Bean 的全局唯一性。以下从实现机制、线程安全、作用域对比和应用场景四个维度详细解析：</p>
<hr>
<h3 id="⚙️-一、实现机制：单例注册表与缓存"><a href="#⚙️-一、实现机制：单例注册表与缓存" class="headerlink" title="⚙️ 一、实现机制：单例注册表与缓存"></a>⚙️ 一、实现机制：单例注册表与缓存</h3><ol>
<li><p><strong>单例注册表（<code>singletonObjects</code>）</strong><br>Spring 使用 <code>DefaultSingletonBeanRegistry</code> 类管理单例 Bean，其核心是一个线程安全的 <code>ConcurrentHashMap</code>：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 注册单例 Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">        singletonObjects.put(beanName, singletonObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取单例 Bean</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singletonObjects.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>首次请求</strong>时创建 Bean 实例并存入注册表。</li>
<li><strong>后续请求</strong>直接返回缓存中的实例，避免重复创建。</li>
</ul>
</li>
<li><p><strong>Bean 生命周期管理</strong>  </p>
<ul>
<li><strong>初始化</strong>：容器启动时默认初始化单例 Bean（可通过 <code>@Lazy</code> 改为延迟加载）。</li>
<li><strong>依赖注入</strong>：通过 <code>@Autowired</code> 注入的依赖均为同一实例。</li>
<li><strong>销毁</strong>：容器关闭时调用单例 Bean 的销毁方法（如 <code>@PreDestroy</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="🔒-二、线程安全：容器安全-≠-Bean-安全"><a href="#🔒-二、线程安全：容器安全-≠-Bean-安全" class="headerlink" title="🔒 二、线程安全：容器安全 ≠ Bean 安全"></a>🔒 二、线程安全：容器安全 ≠ Bean 安全</h3><p>Spring 仅<strong>保证实例唯一性</strong>，不保证 Bean 内部状态的线程安全：  </p>
<ul>
<li><strong>容器层安全</strong>：注册表使用 <code>ConcurrentHashMap</code> 和双重检查锁（DCL），避免多线程重复创建。</li>
<li><strong>业务层风险</strong>：若单例 Bean 含<strong>可变状态</strong>（如计数器），需开发者自行同步：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 可变状态</span></span><br><span class="line">    <span class="comment">// 需同步保护</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>解决方案</strong>：  <ul>
<li>无状态设计（推荐）：避免成员变量，用局部变量或参数传递数据。</li>
<li>同步机制：<code>synchronized</code>、<code>ReentrantLock</code>。</li>
<li>线程安全类：如 <code>AtomicInteger</code>、<code>ConcurrentHashMap</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="🔄-三、作用域对比：单例-vs-其他作用域"><a href="#🔄-三、作用域对比：单例-vs-其他作用域" class="headerlink" title="🔄 三、作用域对比：单例 vs 其他作用域"></a>🔄 三、作用域对比：单例 vs 其他作用域</h3><p>Spring 支持 6 种 Bean 作用域，单例（<code>singleton</code>）为默认值：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>生命周期</th>
<th>适用场景</th>
<th>线程安全需求</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Singleton</strong></td>
<td>容器启动到关闭</td>
<td>无状态服务（如工具类、配置）</td>
<td>需开发者保障</td>
</tr>
<tr>
<td>Prototype</td>
<td>每次请求创建新实例</td>
<td>有状态对象（如用户会话）</td>
<td>实例隔离，无需同步</td>
</tr>
<tr>
<td>Request</td>
<td>HTTP 请求内有效</td>
<td>Web 请求级数据（如表单对象）</td>
<td>实例隔离</td>
</tr>
<tr>
<td>Session</td>
<td>HTTP 会话内有效</td>
<td>用户会话数据（如购物车）</td>
<td>实例隔离</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>为何默认单例？</strong>  </p>
<ul>
<li><strong>性能优势</strong>：减少对象创建&#x2F;GC 开销。</li>
<li><strong>资源复用</strong>：如数据库连接池、配置信息。</li>
<li>符合 Spring 设计哲学：容器管理无状态服务。</li>
</ul>
</blockquote>
<hr>
<h3 id="🛠️-四、典型应用场景"><a href="#🛠️-四、典型应用场景" class="headerlink" title="🛠️ 四、典型应用场景"></a>🛠️ 四、典型应用场景</h3><ol>
<li><strong>基础设施 Bean</strong><br>数据库连接池（<code>DataSource</code>）、事务管理器（<code>TransactionManager</code>）等全局唯一资源。</li>
<li><strong>无状态服务</strong><br>工具类（<code>StringUtils</code>）、业务逻辑层（<code>Service</code>）。</li>
<li><strong>配置类 Bean</strong><br>系统配置（<code>@Configuration</code> 类），如 API 密钥、路径常量。</li>
</ol>
<hr>
<h3 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h3><ol>
<li><strong>循环依赖</strong>：单例 Bean 的循环依赖通过<strong>三级缓存</strong>解决（早期暴露引用）。</li>
<li><strong>作用域切换</strong>：需非单例时，显式声明 <code>@Scope(&quot;prototype&quot;)</code>。</li>
<li><strong>测试影响</strong>：单例的全局状态可能污染单元测试，建议用 <code>@DirtiesContext</code> 重置容器。</li>
</ol>
<hr>
<h3 id="💎-总结"><a href="#💎-总结" class="headerlink" title="💎 总结"></a>💎 总结</h3><p>Spring 的单例模式通过<strong>注册表缓存</strong>实现 Bean 全局唯一，默认适用于无状态服务以提升性能。其线程安全性需开发者根据业务状态设计保障，多线程共享可变数据时需同步控制。理解单例与其他作用域的差异（如原型模式隔离状态），是合理设计 Spring 应用的关键。</p>
<h2 id="spring适配器"><a href="#spring适配器" class="headerlink" title="spring适配器"></a>spring适配器</h2><p>当然可以！下面我会为你深入讲解<strong>适配器模式（Adapter Pattern）</strong>，特别是在<strong>Spring MVC 中 Controller 的实现</strong>场景下的应用与设计思想。</p>
<hr>
<h1 id="一、适配器模式（Adapter-Pattern）简介"><a href="#一、适配器模式（Adapter-Pattern）简介" class="headerlink" title="一、适配器模式（Adapter Pattern）简介"></a>一、适配器模式（Adapter Pattern）简介</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li>适配器模式属于结构型设计模式，其核心思想是在接口不兼容的两个类之间引入一个“适配器”，使得原本不兼容的接口可以协同工作。</li>
<li><strong>意图</strong>：让原本因接口不匹配而无法一起工作的类能够合作。</li>
</ul>
<h2 id="2-经典示意"><a href="#2-经典示意" class="headerlink" title="2. 经典示意"></a>2. 经典示意</h2><ul>
<li><strong>目标接口（Target）</strong>：客户端期待的接口。</li>
<li><strong>适配者（Adaptee）</strong>：现有的接口或类，不符合目标接口。</li>
<li><strong>适配器（Adapter）</strong>：实现目标接口，内部调用适配者的方法，从而实现兼容。</li>
</ul>
<hr>
<h1 id="二、Spring-MVC-中的适配器模式应用"><a href="#二、Spring-MVC-中的适配器模式应用" class="headerlink" title="二、Spring MVC 中的适配器模式应用"></a>二、Spring MVC 中的适配器模式应用</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><ul>
<li>在Spring MVC中，<strong>不同类型的Controller</strong>（如 <code>@Controller</code>、<code>HttpRequestHandler</code>、<code>Controller</code>接口实现）可能有不同的调用方式和接口定义。</li>
<li><strong>为了统一调用入口</strong>，Spring定义了**<code>HandlerAdapter</code>**接口，作为“适配器”角色，将各种不同的Controller封装成一致的调用方式。</li>
</ul>
<h2 id="2-核心设计"><a href="#2-核心设计" class="headerlink" title="2. 核心设计"></a>2. 核心设计</h2><ul>
<li><p><strong>目标接口（Target）</strong>：<code>HandlerAdapter</code>，定义了统一的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line">    ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>适配者（Adaptee）</strong>：各种Controller实现（如 <code>Controller</code>、<code>HttpRequestHandler</code>等），它们有不同的调用方法。</p>
</li>
<li><p><strong>适配器（Adapter）</strong>：实现<code>HandlerAdapter</code>接口，为不同Controller类型提供统一的调用逻辑。</p>
</li>
</ul>
<hr>
<h1 id="三、设计细节"><a href="#三、设计细节" class="headerlink" title="三、设计细节"></a>三、设计细节</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><ul>
<li>让Spring MVC框架可以支持多种Controller类型（如<code>@Controller</code>注解的类、<code>Controller</code>接口实现、<code>HttpRequestHandler</code>等），无需在框架内硬编码不同Controller的调用方式。</li>
<li>通过引入多个<code>HandlerAdapter</code>实现类（如<code>RequestMappingHandlerAdapter</code>、<code>HttpRequestHandlerAdapter</code>等），实现多样化Controller的支持。</li>
</ul>
<h2 id="2-典型实现"><a href="#2-典型实现" class="headerlink" title="2. 典型实现"></a>2. 典型实现</h2><ul>
<li><strong><code>HttpRequestHandlerAdapter</code></strong>：支持实现了<code>HttpRequestHandler</code>接口的Controller。</li>
<li><strong><code>RequestMappingHandlerAdapter</code></strong>：支持基于<code>@RequestMapping</code>的Controller。</li>
</ul>
<p>每个适配器内部都实现了<code>supports()</code>方法，判断当前handler是否支持，如果支持，则调用<code>handle()</code>方法完成请求处理。</p>
<hr>
<h1 id="四、深入设计示意（伪代码）"><a href="#四、深入设计示意（伪代码）" class="headerlink" title="四、深入设计示意（伪代码）"></a>四、深入设计示意（伪代码）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口（统一调用接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line">    ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配者（不同Controller类型）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpRequestHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器实现（将不同Controller适配到目标接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="type">Controller</span> <span class="variable">controller</span> <span class="operator">=</span> (Controller) handler;</span><br><span class="line">        <span class="keyword">return</span> controller.handleRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpRequestHandler</span> <span class="variable">httpHandler</span> <span class="operator">=</span> (HttpRequestHandler) handler;</span><br><span class="line">        httpHandler.handleRequest(request, response);</span><br><span class="line">        <span class="comment">// 可能不返回ModelAndView，或返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用流程：</strong></p>
<ul>
<li>DispatcherServlet收到请求。</li>
<li>根据handler对象（Controller、HttpRequestHandler等），遍历支持的HandlerAdapter，找到支持的适配器。</li>
<li>由适配器调用实际Controller的处理方法，实现接口统一。</li>
</ul>
<hr>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><table>
<thead>
<tr>
<th><strong>角色</strong></th>
<th><strong>定义</strong></th>
<th><strong>在Spring MVC中的体现</strong></th>
</tr>
</thead>
<tbody><tr>
<td>目标接口（Target）</td>
<td>一致的调用接口</td>
<td><code>HandlerAdapter</code>，定义统一的处理方法</td>
</tr>
<tr>
<td>适配者（Adaptee）</td>
<td>不同类型的Controller</td>
<td><code>Controller</code>、<code>HttpRequestHandler</code>等</td>
</tr>
<tr>
<td>适配器（Adapter）</td>
<td>实现目标接口，调用适配者</td>
<td><code>ControllerHandlerAdapter</code>、<code>HttpRequestHandlerAdapter</code>等</td>
</tr>
</tbody></table>
<p><strong>核心思想</strong>：通过引入“适配器”层，将不同类型的Controller统一封装到相同的调用接口中，从而实现Spring MVC对多样Controller的支持，增强了框架的扩展性和灵活性。</p>
<p>LangChain4j 的工具调用（Function Calling&#x2F;Tools）机制是其最强大的功能之一，它允许大语言模型（LLM）动态调用开发者定义的业务逻辑 API。以下是其工作原理的详细解析：</p>
<hr>
<h3 id="核心原理：工具调用流程"><a href="#核心原理：工具调用流程" class="headerlink" title="核心原理：工具调用流程"></a><strong>核心原理：工具调用流程</strong></h3><ol>
<li><p><strong>工具注册</strong>  </p>
<ul>
<li>开发者使用 <code>@Tool</code> 注解标记业务方法（如数据库操作、API 调用等）</li>
<li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppointmentTools</span> &#123;</span><br><span class="line">    <span class="meta">@Tool(&quot;预约挂号&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">bookAppointment</span><span class="params">(Appointment appointment)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑：调用数据库服务</span></span><br><span class="line">        <span class="keyword">return</span> appointmentService.save(appointment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>元数据生成</strong><br>LangChain4j 在运行时自动生成工具的 <strong>JSON Schema</strong> 描述，包括：</p>
<ul>
<li>工具名称（<code>name</code>）</li>
<li>功能描述（<code>description</code>）</li>
<li>参数结构（<code>parameters</code> 的 JSON Schema）</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bookAppointment&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;预约挂号&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;department&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;username&quot;</span><span class="punctuation">,</span> <span class="string">&quot;department&quot;</span><span class="punctuation">,</span> <span class="string">&quot;date&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模型决策</strong>  </p>
<ul>
<li>用户提问时，LangChain4j 将 <strong>工具描述</strong> 和 <strong>用户问题</strong> 一起发送给 LLM</li>
<li>LLM 判断是否需要调用工具：<ul>
<li>若需要 → 返回工具调用请求（而非直接回答）</li>
<li>若不需要 → 直接生成文本回复</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>本地执行</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">  LLM-&gt;&gt;LangChain4j: 返回工具调用请求（JSON）</span><br><span class="line">  LangChain4j-&gt;&gt;ToolExecutor: 解析参数</span><br><span class="line">  ToolExecutor-&gt;&gt;业务方法: 反射调用 bookAppointment(...)</span><br><span class="line">  业务方法-&gt;&gt;数据库: 执行SQL/API调用</span><br><span class="line">  业务方法--&gt;&gt;ToolExecutor: 返回结果</span><br><span class="line">  ToolExecutor-&gt;&gt;LLM: 封装工具执行结果</span><br><span class="line">  LLM-&gt;&gt;用户: 生成最终回答</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="关键技术实现"><a href="#关键技术实现" class="headerlink" title="关键技术实现"></a><strong>关键技术实现</strong></h3><h4 id="1-动态参数绑定"><a href="#1-动态参数绑定" class="headerlink" title="1. 动态参数绑定"></a>1. <strong>动态参数绑定</strong></h4><ul>
<li><strong>JSON → Java 对象转换</strong><br>LangChain4j 使用 <strong>Jackson</strong> 将 LLM 返回的 JSON 参数自动反序列化为 Java 对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LLM 返回的 JSON 参数</span></span><br><span class="line">&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;department&quot;</span>:<span class="string">&quot;内科&quot;</span>, <span class="string">&quot;date&quot;</span>:<span class="string">&quot;2025-04-14&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动转换为 Appointment 对象</span></span><br><span class="line"><span class="type">Appointment</span> <span class="variable">appt</span> <span class="operator">=</span> objectMapper.readValue(json, Appointment.class);</span><br><span class="line">bookAppointment(appt); <span class="comment">// 反射调用业务方法</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-工具执行器（ToolExecutor）"><a href="#2-工具执行器（ToolExecutor）" class="headerlink" title="2. 工具执行器（ToolExecutor）"></a>2. <strong>工具执行器（ToolExecutor）</strong></h4><ul>
<li>核心组件 <code>DefaultToolExecutor</code> 处理：<ul>
<li>匹配工具名称</li>
<li>参数反序列化</li>
<li>通过反射调用目标方法</li>
<li>捕获异常并转换为 LLM 可理解的错误消息</li>
</ul>
</li>
</ul>
<h4 id="3-对话管理"><a href="#3-对话管理" class="headerlink" title="3. 对话管理"></a>3. <strong>对话管理</strong></h4><ul>
<li>当 LLM 决定调用工具时，对话流程变为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户问题 </span><br><span class="line">→ LLM 返回工具调用请求（AiMessage） </span><br><span class="line">→ 执行本地工具 </span><br><span class="line">→ 将结果作为 ToolExecutionResultMessage 发送给 LLM </span><br><span class="line">→ LLM 生成最终回复</span><br></pre></td></tr></table></figure></li>
<li>关键代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Message&gt; messages = Arrays.asList(</span><br><span class="line">  UserMessage.from(question),</span><br><span class="line">  AiMessage.from(toolCallRequest),       <span class="comment">// 工具调用请求</span></span><br><span class="line">  ToolExecutionResultMessage.from(result) <span class="comment">// 工具执行结果</span></span><br><span class="line">);</span><br><span class="line"><span class="type">ChatResponse</span> <span class="variable">response</span> <span class="operator">=</span> model.generate(messages);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="为什么能安全调用业务逻辑？"><a href="#为什么能安全调用业务逻辑？" class="headerlink" title="为什么能安全调用业务逻辑？"></a><strong>为什么能安全调用业务逻辑？</strong></h3><ol>
<li><p><strong>沙箱化执行</strong>  </p>
<ul>
<li>工具方法在 <strong>当前 JVM</strong> 中执行，与业务代码共享安全上下文</li>
<li>无需暴露 API 给外部网络</li>
</ul>
</li>
<li><p><strong>参数校验机制</strong>  </p>
<ul>
<li>通过 <code>@P</code> 注解定义参数约束：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tool</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cancelAppointment</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@P(value=&quot;身份证号&quot;, required=true)</span> String idCard,</span></span><br><span class="line"><span class="params">    <span class="meta">@P(value=&quot;预约日期&quot;)</span> String date</span></span><br><span class="line"><span class="params">)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li>LangChain4j 自动生成参数校验规则，LLM 必须提供合法参数</li>
</ul>
</li>
<li><p><strong>权限控制</strong><br>可通过 <code>@ToolMemoryId</code> 绑定用户会话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tool</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProfile</span><span class="params">(<span class="meta">@ToolMemoryId</span> String userId)</span> &#123;</span><br><span class="line">  <span class="comment">// 根据 userId 查询数据</span></span><br><span class="line">  <span class="keyword">return</span> userService.getProfile(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="与普通-API-调用的本质区别"><a href="#与普通-API-调用的本质区别" class="headerlink" title="与普通 API 调用的本质区别"></a><strong>与普通 API 调用的本质区别</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>传统 API 调用</th>
<th>LangChain4j 工具调用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>触发方式</strong></td>
<td>开发者显式调用</td>
<td>LLM 动态决策触发</td>
</tr>
<tr>
<td><strong>参数传递</strong></td>
<td>手动构造参数对象</td>
<td>LLM 自动生成合规参数</td>
</tr>
<tr>
<td><strong>执行上下文</strong></td>
<td>独立 HTTP 请求</td>
<td>当前 JVM 进程内执行</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>开发者手动处理</td>
<td>自动转换异常为 LLM 可读消息</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>确定性业务流</td>
<td>需自然语言理解的灵活场景</td>
</tr>
</tbody></table>
<hr>
<h3 id="实战示例：挂号系统工具调用"><a href="#实战示例：挂号系统工具调用" class="headerlink" title="实战示例：挂号系统工具调用"></a><strong>实战示例：挂号系统工具调用</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tool(name=&quot;预约挂号&quot;, value=&quot;先检查号源再预约&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">bookAppointment</span><span class="params">(Appointment request)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 检查号源是否可用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> queryDepartment(</span><br><span class="line">        request.getDepartment(), </span><br><span class="line">        request.getDate(), </span><br><span class="line">        request.getTime()</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 执行业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (available) &#123;</span><br><span class="line">        appointmentService.save(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该时段无号源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用流程</span></span><br><span class="line"><span class="comment">// 用户提问 → &quot;我想预约内科4月14日上午的号&quot;</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="comment">// LLM 返回工具调用：</span></span><br><span class="line"><span class="comment">//   bookAppointment(&#123;</span></span><br><span class="line"><span class="comment">//     &quot;department&quot;: &quot;内科&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;date&quot;: &quot;2025-04-14&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;time&quot;: &quot;上午&quot;</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="comment">// LangChain4j 执行 bookAppointment(...)</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="comment">// 返回结果 → LLM 生成最终回复</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结：核心价值"><a href="#总结：核心价值" class="headerlink" title="总结：核心价值"></a><strong>总结：核心价值</strong></h3><ol>
<li><p><strong>自然语言接口</strong><br>用户用自然语言触发复杂业务逻辑（如“取消我周二的预约”）</p>
</li>
<li><p><strong>业务逻辑解耦</strong><br>业务代码无需感知 AI 模型，只需关注功能实现</p>
</li>
<li><p><strong>动态决策能力</strong><br>LLM 根据问题语义自动选择工具并生成合规参数</p>
</li>
<li><p><strong>安全执行</strong><br>通过 JVM 沙箱、参数校验、会话隔离保障安全性</p>
</li>
</ol>
<p>这种设计使 LangChain4j 成为连接大语言模型与传统业务系统的桥梁，特别适合需要自然语言交互的复杂业务场景（如医疗挂号、订单管理等）。</p>
<h2 id="方法区里到底有什么"><a href="#方法区里到底有什么" class="headerlink" title="方法区里到底有什么"></a>方法区里到底有什么</h2><p>Java 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在虚拟机启动时创建，用于存放对象实例。从内存回收角度，堆被划分为新生代和老年代，新生代又分为 Eden 区和两个 Survivor 区（From Survivor 和 To Survivor）。如果在堆中没有内存完成实例分配，并且堆也无法扩展时会抛出 OutOfMemoryError 异常。<br>方法区（元空间）：在 JDK 1.8 及以后的版本中，方法区被元空间取代，使用本地内存。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。虽然方法区被描述为堆的逻辑部分，但有 “非堆” 的别名。方法区可以选择不实现垃圾收集，内存不足时会抛出 OutOfMemoryError 异常。</p>
<hr>
<h3 id="1-核心职责不同"><a href="#1-核心职责不同" class="headerlink" title="1. 核心职责不同"></a><strong>1. 核心职责不同</strong></h3><ul>
<li><p><strong>堆（Heap）</strong><br><strong>对象生存的土壤</strong>：所有通过 <code>new</code> 创建的对象实例（包括数组）都存储于此。<br><strong>核心作用</strong>：支撑 Java 程序运行时 <strong>对象的动态分配和生命周期管理</strong>，是垃圾回收（GC）的主战场。</p>
</li>
<li><p><strong>方法区（Method Area &#x2F; Metaspace）</strong><br><strong>类元数据的基石</strong>：存储与类结构相关的静态信息（不是对象！）。<br><strong>核心作用</strong>：支撑 JVM 的 <strong>类加载机制</strong>，记录类的“设计蓝图”（如类名、方法字节码、字段定义等），是程序静态结构的仓库。</p>
</li>
</ul>
<hr>
<h3 id="2-存储内容不同"><a href="#2-存储内容不同" class="headerlink" title="2. 存储内容不同"></a><strong>2. 存储内容不同</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>堆（Heap）</strong></th>
<th><strong>方法区（元空间）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储对象</strong></td>
<td>✅ 所有对象实例、数组</td>
<td>❌ 不存储任何对象实例</td>
</tr>
<tr>
<td><strong>类信息</strong></td>
<td>❌</td>
<td>✅ 类名、父类、接口、访问修饰符</td>
</tr>
<tr>
<td><strong>方法字节码</strong></td>
<td>❌</td>
<td>✅ 方法的代码指令（编译后的字节码）</td>
</tr>
<tr>
<td><strong>运行时常量池</strong></td>
<td>❌（但字符串常量池在堆中）</td>
<td>✅ 类的字面量、符号引用等（在元空间内）</td>
</tr>
<tr>
<td><strong>静态变量</strong></td>
<td>❌</td>
<td>✅ 静态变量（<code>static</code> 修饰的变量）</td>
</tr>
<tr>
<td><strong>字符串常量池</strong></td>
<td>✅（JDK7+ 从方法区移至堆）</td>
<td>❌（JDK7 后不再存储在方法区）</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 <strong>关键差异</strong>：堆存“对象”，方法区存“类的描述信息”。</p>
</blockquote>
<hr>
<h3 id="3-内存特性不同"><a href="#3-内存特性不同" class="headerlink" title="3. 内存特性不同"></a><strong>3. 内存特性不同</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>堆（Heap）</strong></th>
<th><strong>方法区（元空间）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存位置</strong></td>
<td>JVM 管理的内存区域</td>
<td>JDK8+：使用本地内存（Native Memory）</td>
</tr>
<tr>
<td><strong>垃圾回收</strong></td>
<td>✅ 频繁 GC（分代收集：新生代&#x2F;老年代）</td>
<td>✅ 低频率 GC（卸载不再使用的类）</td>
</tr>
<tr>
<td><strong>内存溢出错误</strong></td>
<td><code>OutOfMemoryError: Java heap space</code></td>
<td><code>OutOfMemoryError: Metaspace</code></td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>受 <code>-Xmx</code> 限制，无法突破最大堆大小</td>
<td>默认无上限（受物理内存限制），可设 <code>-XX:MaxMetaspaceSize</code></td>
</tr>
<tr>
<td><strong>线程共享</strong></td>
<td>✅ 所有线程共享</td>
<td>✅ 所有线程共享</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>元空间的本地内存特性</strong>：<br>JDK8 将方法区从“堆内的永久代”迁移到“本地内存的元空间”，避免了永久代大小受限的问题（不再有 <code>PermGen OutOfMemory</code>），直接使用操作系统的内存。</p>
</blockquote>
<hr>
<h3 id="本质总结"><a href="#本质总结" class="headerlink" title="本质总结"></a><strong>本质总结</strong></h3><table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>堆（Heap）</strong></th>
<th><strong>方法区（Metaspace）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>是什么</strong></td>
<td><strong>对象实例的运行时数据池</strong></td>
<td><strong>类元数据的存储仓库</strong></td>
</tr>
<tr>
<td><strong>存什么</strong></td>
<td><code>new</code> 出来的对象</td>
<td>类的结构信息（非对象！）</td>
</tr>
<tr>
<td><strong>存在哪</strong></td>
<td>JVM 管理的堆内存</td>
<td>操作系统本地内存（JDK8+）</td>
</tr>
<tr>
<td><strong>为何存在</strong></td>
<td>动态分配对象内存</td>
<td>支撑类加载、反射、方法调用等机制</td>
</tr>
</tbody></table>
<hr>
<h3 id="场景比喻"><a href="#场景比喻" class="headerlink" title="场景比喻"></a><strong>场景比喻</strong></h3><ul>
<li><p><strong>堆</strong> → <strong>汽车工厂的组装车间</strong><br>流水线上动态生产汽车（对象），空间不足时扩建厂房（扩容），废旧汽车拆解回收（GC）。</p>
</li>
<li><p><strong>方法区</strong> → <strong>工厂的设计档案室</strong><br>存放汽车设计图纸（类信息）、生产标准（字节码）、零件规格（常量）。档案室独立于车间（本地内存），图纸陈旧时才清理（类卸载）。</p>
</li>
</ul>
<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p>类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。<br>常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。<br>静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。<br>方法字节码：存储类的方法字节码，即编译后的代码。<br>符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。<br>运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。<br>常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。<br>#String保存在哪里呢？</p>
<h2 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h2><p>ThreadLocal的实现中，每个Thread维护一个ThreadLocalMap映射表，key是ThreadLocal实例本身，value是真正需要存储的Object。</p>
<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。</p>
<p>如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。<br>这条路径要记得！是ThreadLocalMap -&gt; Entry -&gt; value！这样的<br>如何解决此问题？<br>第一，使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除；</p>
<h2 id="对象头（Object-Header）的详细解析"><a href="#对象头（Object-Header）的详细解析" class="headerlink" title="对象头（Object Header）的详细解析"></a><strong>对象头（Object Header）的详细解析</strong></h2><p>在对象创建的第四步中，<strong>对象头（Object Header）的设置</strong>是JVM对对象进行内部管理的关键环节。对象头存储了对象的元数据信息，直接影响JVM的运行时行为（如锁机制、垃圾回收等）。以下从5个维度深入分析：</p>
<hr>
<h3 id="一、对象头的结构"><a href="#一、对象头的结构" class="headerlink" title="一、对象头的结构"></a><strong>一、对象头的结构</strong></h3><p>对象头由 <strong>固定部分</strong> 和 <strong>可变部分</strong> 组成（以64位JVM为例，未开启压缩指针）：</p>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>大小（64位JVM）</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mark Word</strong></td>
<td>8字节</td>
<td>存储对象运行时数据：哈希码、GC分代年龄、锁状态等</td>
</tr>
<tr>
<td><strong>Klass Pointer</strong></td>
<td>8字节</td>
<td>指向类元数据的指针（方法区中的Class对象）</td>
</tr>
<tr>
<td><strong>数组长度</strong></td>
<td>4字节（可选）</td>
<td>仅当对象是数组时存在，记录数组长度</td>
</tr>
</tbody></table>
<h3 id="内存布局示例"><a href="#内存布局示例" class="headerlink" title="内存布局示例"></a><strong>内存布局示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-------------------------------------------------------|</span><br><span class="line">| Mark Word (8 bytes) | Klass Pointer (8 bytes) | 数组长度 (4 bytes) | 实例数据... |</span><br><span class="line">|-------------------------------------------------------|</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、Mark-Word的详细内容"><a href="#二、Mark-Word的详细内容" class="headerlink" title="二、Mark Word的详细内容"></a><strong>二、Mark Word的详细内容</strong></h3><p>Mark Word是对象头的核心部分，其内容会<strong>根据对象状态动态变化</strong>（以HotSpot VM为例）：</p>
<h3 id="不同状态下的存储格式"><a href="#不同状态下的存储格式" class="headerlink" title="不同状态下的存储格式"></a><strong>不同状态下的存储格式</strong></h3><table>
<thead>
<tr>
<th>对象状态</th>
<th>存储内容（64位JVM）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>无锁态</strong></td>
<td>25位哈希码 + 4位分代年龄 + 1位偏向锁标志（0） + 2位锁标志（01） + 32位未使用</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>54位线程ID + 2位Epoch + 4位分代年龄 + 1位偏向锁标志（1） + 2位锁标志（01）</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>62位指向栈中锁记录的指针 + 2位锁标志（00）</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>62位指向监视器（Monitor）的指针 + 2位锁标志（10）</td>
</tr>
<tr>
<td><strong>GC标记</strong></td>
<td>62位空（用于标记可回收对象） + 2位锁标志（11）</td>
</tr>
</tbody></table>
<blockquote>
<p>🔥 <strong>关键点</strong>：  </p>
<ul>
<li>锁标志位（最后2位）决定当前对象的锁状态（01&#x3D;无锁&#x2F;偏向锁，00&#x3D;轻量级锁，10&#x3D;重量级锁，11&#x3D;GC标记）。  </li>
<li><strong>哈希码延迟计算</strong>：调用<code>System.identityHashCode()</code>时才生成并存入Mark Word。</li>
</ul>
</blockquote>
<hr>
<h3 id="三、Klass-Pointer的作用"><a href="#三、Klass-Pointer的作用" class="headerlink" title="三、Klass Pointer的作用"></a><strong>三、Klass Pointer的作用</strong></h3><p>Klass Pointer指向方法区中的<strong>类元数据</strong>（即Class对象），使JVM能够：</p>
<ol>
<li><strong>确定对象类型</strong>：在运行时识别对象属于哪个类。</li>
<li><strong>访问类信息</strong>：通过该指针找到方法表、字段定义等元数据。</li>
<li><strong>支持多态</strong>：结合方法表实现虚方法调用。</li>
</ol>
<h3 id="压缩指针优化（-XX-UseCompressedOops）"><a href="#压缩指针优化（-XX-UseCompressedOops）" class="headerlink" title="压缩指针优化（-XX:+UseCompressedOops）"></a><strong>压缩指针优化（-XX:+UseCompressedOops）</strong></h3><ul>
<li>开启后，Klass Pointer从8字节压缩为4字节，节省内存。</li>
<li>要求堆内存不超过32GB（否则指针无法压缩）。</li>
</ul>
<hr>
<h3 id="四、数组长度的特殊处理"><a href="#四、数组长度的特殊处理" class="headerlink" title="四、数组长度的特殊处理"></a><strong>四、数组长度的特殊处理</strong></h3><p>当对象是数组时，对象头会额外增加4字节存储<strong>数组长度</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];  <span class="comment">// 对象头包含长度字段</span></span><br></pre></td></tr></table></figure>
<ul>
<li>长度字段的存在让JVM能快速检查数组越界（如<code>ArrayIndexOutOfBoundsException</code>）。</li>
<li>非数组对象没有此字段。</li>
</ul>
<hr>
<h3 id="五、对象头与JVM功能的关联"><a href="#五、对象头与JVM功能的关联" class="headerlink" title="五、对象头与JVM功能的关联"></a><strong>五、对象头与JVM功能的关联</strong></h3><h3 id="1-锁机制"><a href="#1-锁机制" class="headerlink" title="1. 锁机制"></a><strong>1. 锁机制</strong></h3><ul>
<li><strong>偏向锁</strong>：通过Mark Word中的线程ID实现，减少同步开销。</li>
<li><strong>轻量级锁</strong>：将Mark Word替换为指向线程栈锁记录的指针。</li>
<li><strong>重量级锁</strong>：指向Monitor对象（操作系统层面的互斥量）。</li>
</ul>
<h3 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2. 垃圾回收"></a><strong>2. 垃圾回收</strong></h3><ul>
<li><strong>分代年龄</strong>：4位存储（最大15），触发GC时年龄+1，超过阈值则晋升老年代。</li>
<li><strong>GC标记</strong>：标记阶段用特殊位标识可回收对象。</li>
</ul>
<h3 id="3-内存布局优化"><a href="#3-内存布局优化" class="headerlink" title="3. 内存布局优化"></a><strong>3. 内存布局优化</strong></h3><ul>
<li><strong>字段重排序</strong>：JVM可能根据对象头信息调整实例字段的排列顺序，以节省内存。</li>
</ul>
<h2 id="Java静态初始化（）与对象初始化（）总结"><a href="#Java静态初始化（）与对象初始化（）总结" class="headerlink" title="Java静态初始化（&lt;clinit&gt;）与对象初始化（&lt;init&gt;）总结"></a><strong>Java静态初始化（<code>&lt;clinit&gt;</code>）与对象初始化（<code>&lt;init&gt;</code>）总结</strong></h2><p>在Java虚拟机（JVM）中，类的初始化过程被细分为两个截然不同的阶段：<strong>静态初始化</strong>（对应JVM的<code>&lt;clinit&gt;</code>方法）和<strong>对象初始化</strong>（对应JVM的<code>&lt;init&gt;</code>方法）。理解这两者的区别对于掌握Java类的生命周期、内存管理以及编写健程、高效的代码至关重要。</p>
<p><strong>核心差异概述</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>静态初始化 (<code>&lt;clinit&gt;</code>)</th>
<th>对象初始化 (<code>&lt;init&gt;</code>)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用范围</strong></td>
<td>类级别</td>
<td>对象实例级别</td>
</tr>
<tr>
<td><strong>执行次数</strong></td>
<td>每个类在JVM生命周期中仅执行<strong>一次</strong></td>
<td>每次创建对象实例时执行</td>
</tr>
<tr>
<td><strong>触发时机</strong></td>
<td>类首次被主动使用时（如第一次 <code>new</code>、访问静态成员、反射加载类并初始化）</td>
<td>每次执行 <code>new</code> 操作时</td>
</tr>
<tr>
<td><strong>内容</strong></td>
<td>静态变量赋初值、静态代码块</td>
<td>实例变量赋初值、实例代码块、构造方法</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>由JVM隐式保证（线程安全）</td>
<td>需开发者自行处理（非线程安全）</td>
</tr>
<tr>
<td><strong>底层方法</strong></td>
<td><code>&lt;clinit&gt;</code></td>
<td><code>&lt;init&gt;</code></td>
</tr>
</tbody></table>
<p><strong>静态初始化（<code>&lt;clinit&gt;</code>）详解</strong></p>
<p><code>&lt;clinit&gt;</code> 方法是编译器自动为每个类生成的，它汇集了源码中所有<strong>静态变量的显式赋值</strong>和<strong>静态代码块</strong>（<code>static &#123;&#125;</code>）中的逻辑。它的主要作用是完成类本身相关的准备工作，例如初始化静态字段、加载配置等类级别的资源。</p>
<p><code>&lt;clinit&gt;</code> 的触发严格且高效。只有在类被首次“主动使用”时（如通过 <code>new</code> 关键字创建实例、直接访问静态变量&#x2F;方法、通过反射强制初始化等），JVM才会执行 <code>&lt;clinit&gt;</code>。一个类一旦完成初始化，后续的所有使用都不会再次触发 <code>&lt;clinit&gt;</code>。</p>
<p>尤其重要的是，JVM为 <code>&lt;clinit&gt;</code> 方法的执行提供了<strong>线程安全性保证</strong>。当多个线程同时尝试初始化同一个类时，JVM会确保只有一个线程执行 <code>&lt;clinit&gt;</code>，其他线程会阻塞等待，直到初始化完成。这使得静态初始化成为实现简单线程安全单例模式的天然温床。</p>
<p>反编译字节码可以清晰地看到 <code>&lt;clinit&gt;</code> 方法的存在，它按照源码中静态变量和静态块出现的顺序依次执行。</p>
<p><strong>对象初始化（<code>&lt;init&gt;</code>）详解</strong></p>
<p><code>&lt;init&gt;</code> 方法则与类的实例（对象）紧密相关。它也是编译器自动生成的，合并了<strong>实例变量的显式赋值</strong>、<strong>实例代码块</strong>（<code>&#123;&#125;</code>）以及<strong>构造方法</strong>中的逻辑。每次通过 <code>new</code> 关键字创建一个对象时，都会调用该对象的 <code>&lt;init&gt;</code> 方法来初始化该实例特有的状态。</p>
<p>与 <code>&lt;clinit&gt;</code> 不同，<code>&lt;init&gt;</code> <strong>每次</strong>创建新对象时都会执行。这意味着同一个类的不同对象会执行各自独立的初始化过程。<code>&lt;init&gt;</code> 的执行顺序在继承体系中尤为关键：它总是先调用<strong>父类的 <code>&lt;init&gt;</code> 方法</strong>（通过 <code>invokespecial</code> 指令，对应父类构造器的执行），然后执行<strong>当前类的实例变量赋值和实例代码块</strong>，最后执行<strong>当前类的构造方法体</strong>。</p>
<p><code>&lt;init&gt;</code> 方法的执行<strong>不是线程安全的</strong>。多个线程创建各自的对象实例时，它们会独立地执行 <code>&lt;init&gt;</code>。如果对象的初始化逻辑（特别是构造方法或实例块中的代码）涉及到共享资源的修改，开发者必须自行实现同步机制（如使用 <code>synchronized</code> 关键字）来保证线程安全。</p>
<p>反编译字节码同样会展示 <code>&lt;init&gt;</code> 方法，其中包含了对父类 <code>&lt;init&gt;</code> 的调用以及本类实例变量和实例块的初始化指令。</p>
<p><strong>关键对比与应用场景</strong></p>
<ol>
<li><p><strong>初始化顺序：</strong> 在一个继承体系中，当创建一个子类对象时，完整的初始化流程是：<br>父类静态初始化 (<code>Parent.&lt;clinit&gt;</code>) -&gt; 子类静态初始化 (<code>Child.&lt;clinit&gt;</code>) -&gt; 父类对象初始化 (<code>Parent.&lt;init&gt;</code>) -&gt; 子类对象初始化 (<code>Child.&lt;init&gt;</code>)。静态初始化只发生一次，而对象初始化每次创建子类对象时都会重复。</p>
</li>
<li><p><strong>线程安全性：</strong> 利用 <code>&lt;clinit&gt;</code> 的线程安全特性可以轻松实现饿汉式单例模式，如 <code>private static Singleton instance = new Singleton();</code>，JVM保证在类加载时安全地创建实例。而懒汉式或其他复杂的对象创建若需线程安全，则需要在 <code>&lt;init&gt;</code> 或调用 <code>&lt;init&gt;</code> 的外部（如工厂方法）进行同步控制。</p>
</li>
<li><p><strong>异常处理：</strong> <code>&lt;clinit&gt;</code> 执行失败会导致 JVM 抛出 <code>NoClassDefFoundError</code>（而非 <code>ClassNotFoundException</code>），这个类在整个应用生命周期内将无法被正常使用，影响范围广。而 <code>&lt;init&gt;</code> 执行失败通常抛出正常的运行时异常，只影响当前对象的创建，不影响类的可用性或其他对象。</p>
</li>
</ol>
<p>标记-清除是非移动式回收算法​（Non-Moving），其设计决定了必须：</p>
<p>标记阶段：全堆扫描以保证准确性。<br>清除阶段：全堆扫描以释放内存。<br>所以慢</p>
<h2 id="各种垃圾回收器"><a href="#各种垃圾回收器" class="headerlink" title="各种垃圾回收器"></a>各种垃圾回收器</h2><p>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；<br>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；<br>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；<br>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；<br>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；<br>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。<br>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代</p>
<h2 id="CMS与G1的标记过程对比及STW阶段分析"><a href="#CMS与G1的标记过程对比及STW阶段分析" class="headerlink" title="CMS与G1的标记过程对比及STW阶段分析"></a><strong>CMS与G1的标记过程对比及STW阶段分析</strong></h2><p>CMS（Concurrent Mark-Sweep）和G1（Garbage-First）是两种不同的垃圾回收器，它们在标记过程和STW（Stop-The-World）行为上有显著差异。以下是详细对比：</p>
<hr>
<h3 id="一、CMS的标记过程与STW阶段"><a href="#一、CMS的标记过程与STW阶段" class="headerlink" title="一、CMS的标记过程与STW阶段"></a><strong>一、CMS的标记过程与STW阶段</strong></h3><p>CMS的设计目标是<strong>最小化老年代回收的停顿时间</strong>，其标记过程分为以下阶段：</p>
<h3 id="1-初始标记（Initial-Mark）"><a href="#1-初始标记（Initial-Mark）" class="headerlink" title="1. 初始标记（Initial Mark）"></a><strong>1. 初始标记（Initial Mark）</strong></h3><ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：仅标记<strong>GC Roots直接引用的老年代对象</strong>（不递归标记）。</li>
<li><strong>耗时</strong>：极短（通常几毫秒），因为只扫描直接引用。</li>
</ul>
<h3 id="2-并发标记（Concurrent-Marking）"><a href="#2-并发标记（Concurrent-Marking）" class="headerlink" title="2. 并发标记（Concurrent Marking）"></a><strong>2. 并发标记（Concurrent Marking）</strong></h3><ul>
<li><strong>并发执行</strong>：与用户线程同时运行。</li>
<li><strong>任务</strong>：从初始标记的对象出发，递归标记所有<strong>老年代可达对象</strong>。</li>
<li><strong>耗时</strong>：较长（取决于老年代对象数量），但无需STW。</li>
<li><strong>问题</strong>：可能产生<strong>浮动垃圾</strong>（标记期间新产生的垃圾）。</li>
</ul>
<h3 id="3-重新标记（Remark）"><a href="#3-重新标记（Remark）" class="headerlink" title="3. 重新标记（Remark）"></a><strong>3. 重新标记（Remark）</strong></h3><ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：修正并发标记期间因用户线程运行导致的<strong>引用变化</strong>（如新增或删除的引用）。</li>
<li><strong>优化技术</strong>：使用**增量更新（Incremental Update）<strong>或</strong>卡表（Card Table）**减少扫描范围。</li>
<li><strong>耗时</strong>：比初始标记长，但远短于并发标记（通常10-100ms）。</li>
</ul>
<h3 id="4-并发清除（Concurrent-Sweep）"><a href="#4-并发清除（Concurrent-Sweep）" class="headerlink" title="4. 并发清除（Concurrent Sweep）"></a><strong>4. 并发清除（Concurrent Sweep）</strong></h3><ul>
<li><strong>并发执行</strong>：与用户线程同时运行。</li>
<li><strong>任务</strong>：清理未被标记的垃圾对象（不整理内存，导致碎片化）。</li>
<li><strong>耗时</strong>：较长，但无需STW。</li>
</ul>
<hr>
<h3 id="二、G1的标记过程与STW阶段"><a href="#二、G1的标记过程与STW阶段" class="headerlink" title="二、G1的标记过程与STW阶段"></a><strong>二、G1的标记过程与STW阶段</strong></h3><p>G1的设计目标是<strong>平衡吞吐量和低延迟</strong>，其标记过程更复杂，覆盖整个堆（新生代+老年代）：</p>
<h3 id="1-初始标记（Initial-Mark）-1"><a href="#1-初始标记（Initial-Mark）-1" class="headerlink" title="1. 初始标记（Initial Mark）"></a><strong>1. 初始标记（Initial Mark）</strong></h3><ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：标记GC Roots直接引用的对象（类似CMS）。</li>
<li><strong>附加工作</strong>：与**年轻代GC（Young GC）**一起执行（借道Young GC的STW）。</li>
<li><strong>耗时</strong>：极短（通常几毫秒）。</li>
</ul>
<h3 id="2-并发标记（Concurrent-Marking）-1"><a href="#2-并发标记（Concurrent-Marking）-1" class="headerlink" title="2. 并发标记（Concurrent Marking）"></a><strong>2. 并发标记（Concurrent Marking）</strong></h3><ul>
<li><strong>并发执行</strong>：与用户线程同时运行。</li>
<li><strong>任务</strong>：递归标记整个堆（包括新生代和老年代）的可达对象。</li>
<li><strong>优化技术</strong>：使用**Snapshot-At-The-Beginning（SATB）**算法记录初始快照，减少重新标记工作量。</li>
<li><strong>耗时</strong>：较长，但无需STW。</li>
</ul>
<h3 id="3-最终标记（Final-Marking）"><a href="#3-最终标记（Final-Marking）" class="headerlink" title="3. 最终标记（Final Marking）"></a><strong>3. 最终标记（Final Marking）</strong></h3><ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：处理SATB队列中的引用变化，完成标记。</li>
<li><strong>耗时</strong>：比CMS的重新标记更可控（通常10-50ms）。</li>
</ul>
<h3 id="4-清理阶段（Cleanup）"><a href="#4-清理阶段（Cleanup）" class="headerlink" title="4. 清理阶段（Cleanup）"></a><strong>4. 清理阶段（Cleanup）</strong></h3><ul>
<li><strong>部分STW</strong>：<ul>
<li><strong>STW部分</strong>：统计存活对象，选择回收收益高的Region（基于G1的回收优先级）。</li>
<li><strong>并发部分</strong>：重置空Region的标记状态。</li>
</ul>
</li>
<li><strong>耗时</strong>：通常很短（几毫秒）。</li>
</ul>
<h3 id="5-复制阶段（Evacuation）"><a href="#5-复制阶段（Evacuation）" class="headerlink" title="5. 复制阶段（Evacuation）"></a><strong>5. 复制阶段（Evacuation）</strong></h3><ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：将存活对象从待回收Region复制到空闲Region（压缩内存）。</li>
<li><strong>耗时</strong>：取决于存活对象数量（通常10-200ms）。</li>
</ul>
<hr>
<h3 id="三、CMS与G1的关键差异"><a href="#三、CMS与G1的关键差异" class="headerlink" title="三、CMS与G1的关键差异"></a><strong>三、CMS与G1的关键差异</strong></h3><table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>CMS</strong></th>
<th><strong>G1</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用区域</strong></td>
<td>仅老年代</td>
<td>整个堆（新生代+老年代）</td>
</tr>
<tr>
<td><strong>标记范围</strong></td>
<td>仅老年代对象</td>
<td>全堆对象</td>
</tr>
<tr>
<td><strong>STW阶段</strong></td>
<td>初始标记、重新标记</td>
<td>初始标记、最终标记、清理（部分）、复制</td>
</tr>
<tr>
<td><strong>并发阶段</strong></td>
<td>并发标记、并发清除</td>
<td>并发标记</td>
</tr>
<tr>
<td><strong>内存整理</strong></td>
<td>不整理（碎片化严重）</td>
<td>复制阶段整理（减少碎片）</td>
</tr>
<tr>
<td><strong>触发条件</strong></td>
<td>老年代空间不足</td>
<td>基于Region的回收阈值（默认45%堆占用）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>低延迟老年代回收</td>
<td>大堆内存、平衡吞吐量与延迟</td>
</tr>
</tbody></table>
<hr>
<h3 id="四、STW阶段的本质差异"><a href="#四、STW阶段的本质差异" class="headerlink" title="四、STW阶段的本质差异"></a><strong>四、STW阶段的本质差异</strong></h3><h3 id="1-CMS的STW更少但不可控"><a href="#1-CMS的STW更少但不可控" class="headerlink" title="1. CMS的STW更少但不可控"></a><strong>1. CMS的STW更少但不可控</strong></h3><ul>
<li><strong>优点</strong>：仅初始标记和重新标记需要STW，适合对延迟敏感的老年代回收。</li>
<li><strong>缺点</strong>：<ul>
<li>并发清除不整理内存，最终可能触发Full GC（Serial Old）整理碎片。</li>
<li>重新标记时间可能因引用变化量波动。</li>
</ul>
</li>
</ul>
<h3 id="2-G1的STW更多但可预测"><a href="#2-G1的STW更多但可预测" class="headerlink" title="2. G1的STW更多但可预测"></a><strong>2. G1的STW更多但可预测</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li>通过<strong>SATB算法</strong>和<strong>Region分区</strong>，使最终标记时间更稳定。</li>
<li>复制阶段整理内存，避免碎片化问题。</li>
</ul>
</li>
<li><strong>缺点</strong>：总体STW时间比CMS长，但通过<strong>停顿预测模型</strong>（-XX:MaxGCPauseMillis）控制。</li>
</ul>
<hr>
<h2 id="五、如何选择？"><a href="#五、如何选择？" class="headerlink" title="五、如何选择？"></a><strong>五、如何选择？</strong></h2><ul>
<li><strong>选择CMS</strong>：若应用需要<strong>极低的老年代停顿</strong>（如延迟敏感型服务），且堆内存较小（如4-6GB以下）。</li>
<li><strong>选择G1</strong>：若堆内存较大（如6GB以上），或需要<strong>平衡吞吐量与延迟</strong>（如大数据处理）。<br>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。<br>因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW</li>
</ul>
<h2 id="浮动垃圾（Floating-Garbage）深度解析与CMS-G1差异总结"><a href="#浮动垃圾（Floating-Garbage）深度解析与CMS-G1差异总结" class="headerlink" title="浮动垃圾（Floating Garbage）深度解析与CMS&#x2F;G1差异总结"></a><strong>浮动垃圾（Floating Garbage）深度解析与CMS&#x2F;G1差异总结</strong></h2><p>在并发垃圾回收器中，为了减少或消除GC时对用户线程的长时间暂停（Stop-The-World, STW），垃圾回收过程的部分或大部分是与用户线程并行进行的。然而，这种并发性引入了一个特有的问题：<strong>浮动垃圾</strong>（Floating Garbage）。</p>
<p><strong>什么是浮动垃圾？</strong></p>
<p>浮动垃圾是指在垃圾回收器执行并发阶段（如并发标记或并发清理）时，由于用户线程仍在运行并修改对象引用关系，导致原本被认为是存活的对象变得不可达（即成为垃圾）。这些新产生的垃圾对象因为它们“出现”在标记或清理过程的“之后”，本轮GC无法识别并回收它们，它们就像“浮”在水面上一样，只能等待下一轮GC周期才能被清理。</p>
<p>简单来说，如果在并发标记阶段，一个对象 <code>A</code> 被标记为存活，但随后用户线程将指向 <code>A</code> 的唯一引用设置为 <code>null</code>，那么 <code>A</code> 就成为了本轮GC的浮动垃圾。</p>
<p><strong>CMS 回收器与浮动垃圾</strong></p>
<p>CMS（Concurrent Mark Sweep）回收器是典型的处理老年代的并发回收器。其核心思想是希望大部分标记和清理工作能够与用户线程并发进行。然而，CMS的设计决定了它必然会产生浮动垃圾，并且浮动垃圾可能导致严重的问题。</p>
<p>CMS 的主要步骤包括：</p>
<ol>
<li><strong>初始标记 (STW)</strong>：标记GC Roots直接关联的对象。</li>
<li><strong>并发标记 (Concurrent)</strong>：从GC Roots开始遍历对象图，标记所有存活对象。<em>此阶段用户线程运行，可能创建新对象、断开引用，产生浮动垃圾。</em></li>
<li><strong>重新标记 (STW)</strong>：修正并发标记期间因用户线程活动导致的对象引用变化。虽然尝试修正，但仍无法完全捕捉所有变化。</li>
<li><strong>并发清理 (Concurrent)</strong>：扫描堆，回收未被标记的对象。<em>此阶段用户线程也运行，会继续创建新对象并可能产生新的垃圾，这些新垃圾也成为浮动垃圾。</em></li>
</ol>
<p>CMS 回收的特点是<strong>非移动式</strong>的（Non-moving），即它只负责标记和清除死对象占据的空间，但不整理内存，会产生内存碎片。由于清理是并发进行的，CMS 无法实时地追踪和处理用户线程新产生的浮动垃圾。这些浮动垃圾会一直占据内存空间，直到下一轮GC周期才能被回收。</p>
<p>为了应对浮动垃圾可能导致的内存不足问题，CMS 必须预留一部分老年代空间。如果预留空间被浮动垃圾耗尽，而用户线程此时需要分配内存或对象需要晋升到老年代，就会触发 <strong>Concurrent Mode Failure</strong>，此时JVM会紧急启动一个 Full GC（通常是 Serial Old 回收器），这是一个全堆范围的、单线程的、STW的回收过程，会导致应用长时间停顿，严重影响性能。因此，CMS 的一个重要调优参数 <code>-XX:CMSInitiatingOccupancyFraction</code> 就是控制老年代在何种占用比例下启动GC，以尽早回收，留出足够的空间容纳浮动垃圾和新晋升的对象。</p>
<p><strong>G1 回收器与浮动垃圾</strong></p>
<p>G1（Garbage-First）回收器是面向大堆的、区域（Region）化的并发回收器。虽然G1也是并发回收器，它也产生浮动垃圾，但处理方式和影响与CMS有显著不同，通常认为G1没有CMS那样突出的“浮动垃圾问题”。</p>
<p>G1通过以下机制来缓解浮动垃圾的影响：</p>
<ol>
<li><strong>Region 分区</strong>：G1将堆划分为多个大小相等的 Region。GC时可以针对性地回收部分 Region。</li>
<li><strong>SATB 标记算法 (Snapshot-At-The-Beginning)</strong>：G1在并发标记阶段使用的是 SATB 算法。SATB 会记录标记开始时的对象引用图<strong>快照</strong>。在并发标记过程中，如果用户线程删除了一个引用，SATB 会通过 Remembered Set 记录下来。SATB 的核心思想是：所有在标记开始时被快照认为是存活的对象，都会被视为存活，即使它们在标记过程中变成了垃圾。这意味着 SATB 会<strong>有意地将一部分本应是垃圾的对象标记为存活</strong>——这些就是G1中的浮动垃圾。</li>
<li><strong>筛选回收 (Evacuation)</strong>：G1的清理阶段本质上是<strong>并行复制</strong>。在 Evacuation 阶段（通常有较短的STW），G1会将选中区域（包括新生代和部分老年代）中的存活对象复制到新的空闲 Region 中。原先的 Region 整个被释放。这个复制过程是并行的，且在STW下进行，因此不会产生新的浮动垃圾。</li>
</ol>
<p>G1的SATB算法产生的浮动垃圾不会导致像CMS那样的 Concurrent Mode Failure。被SATB错误标记为存活的浮动垃圾对象会被复制到新Region中，它们只是延迟到<strong>下一轮</strong>GC周期才会被回收。G1通过控制每次 Evacuation 回收的 Region 数量（基于用户设置的目标暂停时间）来管理内存回收速率，而不是依赖预留空间来应对随时可能溢出的浮动垃圾。即使G1的并发标记跟不上用户线程分配速率，导致没有足够的空闲Region进行Evacuation，它会增加 Evacuation 的 Region 数量或临时 Full GC，但这种 Full GC 的触发原因和CMS的 CM Failure 不同，也通常优化得比 Serial Old 好。</p>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>CMS</strong></th>
<th><strong>G1</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>标记算法</strong></td>
<td>增量更新 (Incremental Update)</td>
<td>原始快照 (SATB - Snapshot-At-The-Beginning)</td>
</tr>
<tr>
<td><strong>清理方式</strong></td>
<td>并发清理 (Sweep - Non-moving)</td>
<td>并行复制 (Evacuation - Moving)</td>
</tr>
<tr>
<td><strong>浮动垃圾来源</strong></td>
<td>并发标记和并发清理阶段用户线程修改引用</td>
<td>并发标记阶段用户线程修改引用 (SATB特性)</td>
</tr>
<tr>
<td><strong>浮动垃圾影响</strong></td>
<td>累积可能导致内存不足，触发 CM Failure (STW)</td>
<td>被SATB标记为存活，延迟到下一轮回收，不直接导致 CM Failure</td>
</tr>
<tr>
<td><strong>应对策略</strong></td>
<td>预留内存空间 (<code>CMSInitiatingOccupancyFraction</code>)</td>
<td>SATB + Region化 + 并行复制 (延迟清理)</td>
</tr>
</tbody></table>
<p>核心差异在于，CMS的非移动式并发清理与浮动垃圾的产生直接冲突，需要预留空间避免失败；而G1的SATB标记和并行复制机制虽然也产生浮动垃圾，但将其处理推迟到下一轮，并通过Region的管理和复制的方式避免了CMS那种因浮动垃圾填满老年代导致的紧急STW退化。因此，理解浮动垃圾的产生及其在不同回收器中的处理方式，对于选择合适的GC回收器和进行性能调优至关重要。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">         <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">         Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; nums[q.getLast()] &lt;= nums[i])&#123;</span><br><span class="line">               q.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            q.addLast();</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; i - q.getFirst() &gt;= k)&#123;</span><br><span class="line">               q.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k)&#123;</span><br><span class="line">               ans[i-k+<span class="number">1</span>] = q.getFirst();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/notes.github.io/tags/%E5%85%B6%E4%BB%96/" rel="tag"># 其他</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/notes.github.io/2025/06/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="prev" title="操作系统：并发编程">
      <i class="fa fa-chevron-left"></i> 操作系统：并发编程
    </a></div>
      <div class="post-nav-item">
    <a href="/notes.github.io/2025/06/23/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87/" rel="next" title="项目问题准备">
      项目问题准备 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADB-%E6%A0%91%E7%9B%B8%E5%AF%B9%E4%BA%8EB%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">数据库中B+树相对于B树的优点总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">索引失效的常见场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC-%E6%8F%92%E5%85%A5and%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">MVCC 插入and查找数据的完整过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">一、插入数据的完整过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%AE%BF%E9%97%AE%EF%BC%88%E6%9F%A5%E8%AF%A2%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">二、访问（查询）数据的完整过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E5%88%9B%E5%BB%BARead-View%EF%BC%88%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%A4%E6%96%AD%E4%BE%9D%E6%8D%AE%EF%BC%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">步骤1：创建Read View（可见性判断依据）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E9%81%8D%E5%8E%86%E7%89%88%E6%9C%AC%E9%93%BE%EF%BC%8C%E5%88%A4%E6%96%AD%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">3.2.2.</span> <span class="nav-text">步骤2：遍历版本链，判断可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A43%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%8C%B9%E9%85%8D%E7%89%88%E6%9C%AC"><span class="nav-number">3.2.3.</span> <span class="nav-text">步骤3：返回匹配版本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.3.</span> <span class="nav-text">三、关键机制详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="nav-number">3.4.</span> <span class="nav-text">四、流程图解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E6%B5%81%E4%B8%8E%E9%99%8D%E7%BA%A7"><span class="nav-number">4.</span> <span class="nav-text">限流与降级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">spring单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9A%99%EF%B8%8F-%E4%B8%80%E3%80%81%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%B3%A8%E5%86%8C%E8%A1%A8%E4%B8%8E%E7%BC%93%E5%AD%98"><span class="nav-number">6.1.</span> <span class="nav-text">⚙️ 一、实现机制：单例注册表与缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%94%92-%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8-%E2%89%A0-Bean-%E5%AE%89%E5%85%A8"><span class="nav-number">6.2.</span> <span class="nav-text">🔒 二、线程安全：容器安全 ≠ Bean 安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%94%84-%E4%B8%89%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E6%AF%94%EF%BC%9A%E5%8D%95%E4%BE%8B-vs-%E5%85%B6%E4%BB%96%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">6.3.</span> <span class="nav-text">🔄 三、作用域对比：单例 vs 其他作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%9B%A0%EF%B8%8F-%E5%9B%9B%E3%80%81%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.4.</span> <span class="nav-text">🛠️ 四、典型应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.5.</span> <span class="nav-text">⚠️ 注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%8E-%E6%80%BB%E7%BB%93"><span class="nav-number">6.6.</span> <span class="nav-text">💎 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">spring适配器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter-Pattern%EF%BC%89%E7%AE%80%E4%BB%8B"><span class="nav-number"></span> <span class="nav-text">一、适配器模式（Adapter Pattern）简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BB%8F%E5%85%B8%E7%A4%BA%E6%84%8F"><span class="nav-number">2.</span> <span class="nav-text">2. 经典示意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Spring-MVC-%E4%B8%AD%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">二、Spring MVC 中的适配器模式应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">1. 背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">2. 核心设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82"><span class="nav-number"></span> <span class="nav-text">三、设计细节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">1. 作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">2. 典型实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E8%AE%BE%E8%AE%A1%E7%A4%BA%E6%84%8F%EF%BC%88%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">四、深入设计示意（伪代码）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number"></span> <span class="nav-text">五、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%EF%BC%9A%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">0.1.</span> <span class="nav-text">核心原理：工具调用流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="nav-number">0.2.</span> <span class="nav-text">关键技术实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-number">0.2.1.</span> <span class="nav-text">1. 动态参数绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B7%A5%E5%85%B7%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%88ToolExecutor%EF%BC%89"><span class="nav-number">0.2.2.</span> <span class="nav-text">2. 工具执行器（ToolExecutor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AF%B9%E8%AF%9D%E7%AE%A1%E7%90%86"><span class="nav-number">0.2.3.</span> <span class="nav-text">3. 对话管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%AE%89%E5%85%A8%E8%B0%83%E7%94%A8%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%9F"><span class="nav-number">0.3.</span> <span class="nav-text">为什么能安全调用业务逻辑？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E6%99%AE%E9%80%9A-API-%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="nav-number">0.4.</span> <span class="nav-text">与普通 API 调用的本质区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%8C%82%E5%8F%B7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8"><span class="nav-number">0.5.</span> <span class="nav-text">实战示例：挂号系统工具调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC"><span class="nav-number">0.6.</span> <span class="nav-text">总结：核心价值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E9%87%8C%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">方法区里到底有什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3%E4%B8%8D%E5%90%8C"><span class="nav-number">1.1.</span> <span class="nav-text">1. 核心职责不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9%E4%B8%8D%E5%90%8C"><span class="nav-number">1.2.</span> <span class="nav-text">2. 存储内容不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E7%89%B9%E6%80%A7%E4%B8%8D%E5%90%8C"><span class="nav-number">1.3.</span> <span class="nav-text">3. 内存特性不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E8%B4%A8%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.</span> <span class="nav-text">本质总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E6%AF%94%E5%96%BB"><span class="nav-number">1.5.</span> <span class="nav-text">场景比喻</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">ThreadLocal内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%88Object-Header%EF%BC%89%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">对象头（Object Header）的详细解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">一、对象头的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.2.</span> <span class="nav-text">内存布局示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Mark-Word%E7%9A%84%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9"><span class="nav-number">3.3.</span> <span class="nav-text">二、Mark Word的详细内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">不同状态下的存储格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81Klass-Pointer%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.5.</span> <span class="nav-text">三、Klass Pointer的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96%EF%BC%88-XX-UseCompressedOops%EF%BC%89"><span class="nav-number">3.6.</span> <span class="nav-text">压缩指针优化（-XX:+UseCompressedOops）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="nav-number">3.7.</span> <span class="nav-text">四、数组长度的特殊处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%8EJVM%E5%8A%9F%E8%83%BD%E7%9A%84%E5%85%B3%E8%81%94"><span class="nav-number">3.8.</span> <span class="nav-text">五、对象头与JVM功能的关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">3.9.</span> <span class="nav-text">1. 锁机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.10.</span> <span class="nav-text">2. 垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96"><span class="nav-number">3.11.</span> <span class="nav-text">3. 内存布局优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%EF%BC%89%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%EF%BC%89%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">Java静态初始化（&lt;clinit&gt;）与对象初始化（&lt;init&gt;）总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">各种垃圾回收器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E4%B8%8EG1%E7%9A%84%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B%E5%AF%B9%E6%AF%94%E5%8F%8ASTW%E9%98%B6%E6%AE%B5%E5%88%86%E6%9E%90"><span class="nav-number">6.</span> <span class="nav-text">CMS与G1的标记过程对比及STW阶段分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81CMS%E7%9A%84%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B%E4%B8%8ESTW%E9%98%B6%E6%AE%B5"><span class="nav-number">6.1.</span> <span class="nav-text">一、CMS的标记过程与STW阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%EF%BC%88Initial-Mark%EF%BC%89"><span class="nav-number">6.2.</span> <span class="nav-text">1. 初始标记（Initial Mark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%88Concurrent-Marking%EF%BC%89"><span class="nav-number">6.3.</span> <span class="nav-text">2. 并发标记（Concurrent Marking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%EF%BC%88Remark%EF%BC%89"><span class="nav-number">6.4.</span> <span class="nav-text">3. 重新标记（Remark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B9%B6%E5%8F%91%E6%B8%85%E9%99%A4%EF%BC%88Concurrent-Sweep%EF%BC%89"><span class="nav-number">6.5.</span> <span class="nav-text">4. 并发清除（Concurrent Sweep）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81G1%E7%9A%84%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B%E4%B8%8ESTW%E9%98%B6%E6%AE%B5"><span class="nav-number">6.6.</span> <span class="nav-text">二、G1的标记过程与STW阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%EF%BC%88Initial-Mark%EF%BC%89-1"><span class="nav-number">6.7.</span> <span class="nav-text">1. 初始标记（Initial Mark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%88Concurrent-Marking%EF%BC%89-1"><span class="nav-number">6.8.</span> <span class="nav-text">2. 并发标记（Concurrent Marking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%80%E7%BB%88%E6%A0%87%E8%AE%B0%EF%BC%88Final-Marking%EF%BC%89"><span class="nav-number">6.9.</span> <span class="nav-text">3. 最终标记（Final Marking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%B8%85%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%88Cleanup%EF%BC%89"><span class="nav-number">6.10.</span> <span class="nav-text">4. 清理阶段（Cleanup）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%A4%8D%E5%88%B6%E9%98%B6%E6%AE%B5%EF%BC%88Evacuation%EF%BC%89"><span class="nav-number">6.11.</span> <span class="nav-text">5. 复制阶段（Evacuation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81CMS%E4%B8%8EG1%E7%9A%84%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82"><span class="nav-number">6.12.</span> <span class="nav-text">三、CMS与G1的关键差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81STW%E9%98%B6%E6%AE%B5%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%B7%AE%E5%BC%82"><span class="nav-number">6.13.</span> <span class="nav-text">四、STW阶段的本质差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-CMS%E7%9A%84STW%E6%9B%B4%E5%B0%91%E4%BD%86%E4%B8%8D%E5%8F%AF%E6%8E%A7"><span class="nav-number">6.14.</span> <span class="nav-text">1. CMS的STW更少但不可控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-G1%E7%9A%84STW%E6%9B%B4%E5%A4%9A%E4%BD%86%E5%8F%AF%E9%A2%84%E6%B5%8B"><span class="nav-number">6.15.</span> <span class="nav-text">2. G1的STW更多但可预测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">五、如何选择？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE%EF%BC%88Floating-Garbage%EF%BC%89%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8ECMS-G1%E5%B7%AE%E5%BC%82%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">浮动垃圾（Floating Garbage）深度解析与CMS&#x2F;G1差异总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Zhan"
      src="/notes.github.io/images/woshicaigou.jpg">
  <p class="site-author-name" itemprop="name">Chen Zhan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/notes.github.io/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Zhan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/notes.github.io/lib/anime.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/notes.github.io/js/utils.js"></script>

<script src="/notes.github.io/js/motion.js"></script>


<script src="/notes.github.io/js/schemes/pisces.js"></script>


<script src="/notes.github.io/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
