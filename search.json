[{"title":"01词法分析I","url":"/notes.github.io/2025/06/23/01%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90I/","content":"01 词法分析 I\n  by Arthals\n  \n  blog：Arthals' ink\n\n\n词法分析器\n读入源程序字符流，输出 token 序列\n过滤空白 / 换行 / 制表符 / 注释\n将 token 信息添加到符号表\n逻辑上独立于语法分析，但是通常和语法分析器在同一 Pass\n\n\n基础概念词法单元 token结构：&lt;词法单元名, 属性值(可选)&gt;\n\n单元名：表明该词法单位的种类，是表示词法单位种类的抽象符号，词法分析器通过各 token 的单元名即可确定词法单元序列的结构\n属性值：可选，用于语义分析之后的阶段\n\n模式 pattern描述一类词法单元的词素可能具有的形式\n词素 lexeme\n源程序中的字符序列\n如果一个词素和某个 token 的模式相匹配，它会被词法分析器识别为该 token 的实例\n\n词法分析器的功能\n识别词法单元 token\n去除注释 / 空白 / 空行 / 制表符\n将编译器生成的错误信息关联到源文件\n可能要进行一些 预处理：识别宏 macro；宏的扩展\n\ntoken 的类别\n关键字 Keyword：if, else, while, return，没有属性值\n标识符 Identifier：变量名等\n字面常数 Literal：12，true，1e+3\n运算符 Operator：+ - * /\n分界符 Delimiter：逗号 / 分号 / 冒号 /etc\n\n词法分析器的输出Token 的基本输出格式：&lt;类别编码, 词法单元自身的属性值&gt;\n在词法分析过程中，有时候需要无限长的向前看\n词法分析的设计\n可以实现为单独的一个扫描（pass）\n也可以作为语法分析 / 语义分析的子程序，即每调用一次 getToken() 函数即获得一个 token\n\n语言和正则表达式规约（Specification）：用正则表达式来描述处理词法单元时用到的模式类型\n字母表 Alphabet字母表：符号的非空有穷集合\n每一程序语言都有自己的字母表\n\n机器语言：符号 0 和 1\nASCII 字符集\n\n符号串 String / 字 word已知字母表 $\\Sigma$\n\n$ε$ 是 $\\Sigma$ 上的一个 符号串 （空串）\n若 $\\alpha$ 是 $\\Sigma$ 上的符号串，而 $a$ 是 $\\Sigma$ 的元素，则 $\\alpha a$ 是 $\\Sigma$ 上的符号串。\n$\\beta$ 是 $\\Sigma$ 上的符号串，当且仅当它由 1 和 / 或 2 导出（递归定义）。\n\n定义：由字母表中的符号所组成的 任意有穷序列 被称为该字母表上的 符号串（String），也称作 字（Word） 。\n通常约定\n靠前的小写字母表示 符号：$a, b, c$\n小写希腊字母或靠后的小写英文字母表示 符号串：$α, β, γ, x ,y ,z$\n$ε$ 通常表示 空串\n大写字母表示 符号串集合：$A,B,C$\n\n相关概念设 $x$ 是一个符号串，定义如下概念：\n\n前缀（prefix）：移走 $x$ 尾部的 零个 或多个连续的符号。\n后缀（suffix）：移走 $x$ 头部的 零个 或多个连续的符号。\n子串（substring）：从 $x$ 中删去一个前缀和一个后缀。\n真前缀 / 真后缀 / 真子串：首先要非空（和集图不同），而且不等，即 $y\\neq x\\mathrm{~}\\&amp;\\mathrm{~}y\\neq\\mathbf{\\varepsilon}$\n子序列（subsequence）：从 $x$ 中删去 零个或多个 符号（这些符号 不要求是连续的 ）。\n逆转（reverse） ：或称转置，用 $x^R$ 表示。将 $x$ 中的符号按相反次序写出而得到的符号串。\n长度（length） ：符号串中的符号的数目。如 $|aab| = 3$，$|\\varepsilon| = 0$\n\n符号串的运算\n连接 (concatenation)\n 设 $x$ 和 $y$ 是符号串，它们的连接 $xy$ 是把 $y$ 的符号写在 $x$ 的符号之后得到的符号串。\n 例如，$x = ba,{~}y = nana\\Rightarrow{~}xy = banana$\n\n方幂 (exponentiation)\n\n$x^0 = \\varepsilon$\n$x^1 = x$\n$x^2 = xx$\n$x^n = x^{n-1}x$\n\n\n\n语言（符号串集合）语言（language）：某个给定字母表上的一个任意的可数的符号串集合。\n语言的例子\n空集 $\\varnothing$\n只包含空串的集合 ${\\varepsilon}$\n所有符合规范的 C 语言标识符的集合\n所有语法正确的 C 语言程序的集合\n所有语法正确的英语句子的集合\n\n语言的运算设 $L$ 和 $M$ 是两个符号串集合，则：\n\n合并 (union)\n L \\cup M = \\{s | s \\in L \\text{ 或 } s \\in M\\}\n连接 (concatenation)\n LM = \\{st | s \\in L \\text{ 且 } t \\in M\\}\n方幂 (exponentiation)\n$L^0 = {\\varepsilon}$\n$L^1 = L$\n$L^2 = LL$\n$L^n = L^{n-1}L$\n\n\n语言 $L$ 的 Kleene 闭包（closure）\n 记作 $L^*$：\n\n L^* = \\bigcup_{i \\geq 0} L^i = L^0 \\cup L^1 \\cup L^2 \\cup L^3 \\cup \\ldots\n语言 $L$ 的正闭包（positive closure）\n 记作 $L^+$：\n\n L^+ = L \\cdot L^*\n L^+ = \\bigcup_{i \\geq 1} L^i = L^1 \\cup L^2 \\cup L^3 \\cup L^4 \\cup \\ldots\n\n辨析\n空集 $\\varnothing$：空集是一个不包含任何元素的集合。\n只包含空串的集合 ${\\varepsilon}$：这个集合包含一个元素，即空串 $\\varepsilon$。空串是长度为零的字符串。\n\n运算性质：\n\n空集 $\\varnothing$：没有元素。\n因此，对于任何集合 $M$，有：\n\n\\varnothing M = M \\varnothing = \\varnothing因为空集与任何集合的笛卡尔积仍然是空集\n\n集合 ${\\varepsilon}$：只包含空串。\n这个集合包含一个元素 $\\varepsilon$。对于任何集合 $M$，有：\n\n\\{\\varepsilon\\} M = M \\{\\varepsilon\\} = M因为空串与任何字符串的连接操作不会改变字符串\n\n\n正则表达式与正则语言 Regular Expression定义：某个字母表 $\\Sigma$ 上的正则表达式及其对应的正则集合（正则语言），满足以下条件：\n\n$\\varepsilon$ 是一个正则表达式，表示的语言 $L(\\varepsilon) = {\\varepsilon}$。\n若 $a \\in \\Sigma$，$a$ 是一个正则表达式，$L(a) = {a}$。\n归纳步骤：设 $r$ 和 $s$ 是 $\\Sigma$ 上的正则表达式：\n$(r) | (s)$ 是一个正则表达式，表示语言 $L(r) \\cup L(s)$，即或\n$(r)(s)$ 是一个正则表达式，表示语言 $L(r) L(s)$，即连接在一起\n$(r)^$ 是一个正则表达式，表示语言 $(L(r))^$，即重复\n$(r)$ 是一个正则表达式，表示语言 $L(r)$\n\n\n\n注意：去掉一个正则表达式中的冗余括号之后，它表示的正则语言不变（注意运算的优先级）。\n正则表达式示例例：$\\Sigma = {a, b}$\n\n$a | b$：${a, b}$\n$(a | b)(a | b)$：${aa, ab, ba, bb}$\n$a^*$：${\\varepsilon, a, aa, aaa, aaaa, \\dots}$\n$(a | b)^$ 或 $(a^b^)^$：${\\varepsilon, a, b, aa, ab, ba, bb, aaa, \\dots}$\n$a^*b$：${b, ab, aab, aaab, \\dots}$\n\nC 语言标识符：可视化\n(A|B|...|Z|a|b|...|z|_)((A|B|...|Z|a|b|...|z|_ |0|1|...|9))*// [A-Z_][A-Za-z0-9_]*\n有符号整数：可视化\n(+|-|ε)(0|1|...|9)(0|1|...|9)*// [+-]?[0-9][0-9]*\n正则表达式的性质设 $e_1, e_2, e_3$ 均为某字母表上的正则表达式，则有：\n\n单位正则表达式 $\\varepsilon$：$\\varepsilon e = e \\varepsilon = e$\n交换律：$e_1 | e_2 = e_2 | e_1$\n结合律：$e_1 | (e_2 | e_3) = (e_1 | e_2) | e_3$，$e_1(e_2 e_3) = (e_1 e_2)e_3$\n分配律：$e_1(e_2 | e_3) = e_1 e_2 | e_1 e_3$，$(e_1 | e_2)e_3 = e_1 e_3 | e_2 e_3$\n\n此外：\n\n$r^ = (r\\varepsilon)^$\n$r^{*} = r^$\n$(r|s)^ = (r^ s^)^$\n\n正则定义（Regular Definition）正则定义是如下形式的定义序列：\n\nD_1 \\rightarrow R_1 \\\\\nD_2 \\rightarrow R_2 \\\\\n\\vdots \\\\\nD_n \\rightarrow R_n其中：\n\n$R_1, R_2, \\ldots, R_n$ 为正则表达式。\n$D_1, D_2, \\ldots, D_n$ 为正则表达式名字。\n\n限定：在 $Ri$ 中只能出现字母表 $\\Sigma$ 中的字符，以及前面已定义的正则表达式名字，即 $D_1, D_2, \\ldots, D{i-1}$。\n我们用这种辅助定义式（相当于规则）来定义程序语言的单词符号。\n正则表达式的扩展形式为了表达的方便，通常可以对正则表达式做如下的扩展：\n\n1 次或多次出现：$(r)+$ 用来表示 $L(r)+$\n$r^ = r+|\\varepsilon \\quad r+ = rr^ = r^* r$\n\n0 次或 1 次出现：$r?$ 用来表示 $r | \\varepsilon$\n也就是 $L(r) \\cup {\\varepsilon}$\n\n字符类：$[abc]$ 表示 $a|b|c$；$[a-z]$ 表示 $a|b|c|\\ldots|z$\n\n\n建议看 RegexLearn。\n例题写出语言 “所有相邻数字都不相同的非空数字串” 的正则定义。\n解答：正则定义如下\n\n\\begin{aligned} &\\text{answer} & \\rightarrow &\\ (0 \\mid \\text{no\\_0}\\ 0)(\\text{no\\_0}\\ 0)^*(\\text{no\\_0} \\mid \\varepsilon) \\mid \\text{no\\_0} \\\\ &\\text{no\\_0} & \\rightarrow &\\ (1 \\mid \\text{no\\_0-1}\\ 1)(\\text{no\\_0-1}\\ 1)^*(\\text{no\\_0-1} \\mid \\varepsilon) \\mid \\text{no\\_0-1} \\\\ &{~~~}\\vdots & &\\ \\\\ &\\text{no\\_0-8} & \\rightarrow &\\ 9 \\\\ \\end{aligned}将这些正则定义逆序排列就是答案。\n\n顶层规则 answer ：\nanswer 可以是以 0 开头的数字串，或者以 no_0 开头的数字串。\n对于以 0 开头的串，后面可以跟任意多个 (no_0 0)，最后再跟一个 no_0 或者为空（$\\varepsilon$）。\n对于以 no_0 开头的串，直接匹配 no_0。\n\n\n子表达式 no_0 ：\n\nno_0 代表不能以 0 开头的数字串，其定义类似于 answer，但替换了数字。\nno_0 可以是以 1 开头，后面可以跟任意多个 (no_0-1 1)，最后再跟一个 no_0-1 或者为空（$\\varepsilon$）。\n对于以 no_0-1 开头的串，直接匹配 no_0-1。\n\n\n递归定义 ：\n\n其他子表达式 no_0-1，no_0-2，直到 no_0-8，都以类似的方式定义，保证生成的串中相邻数字始终不同。\n最终，no_0-8 只能匹配 9。\n\n\n\n","tags":["PKU/Compiler-Principles-2024Fall-PKU/Note"]},{"title":"急救","url":"/notes.github.io/2025/06/23/%E6%80%A5%E6%95%91/","content":"在活跃变量分析（Live Variable Analysis）中，def和use是定义基本块内变量行为的关键集合，用于计算程序点的活跃变量状态（IN[B]和OUT[B]）。以下结合定义、时序规则和实例详细说明：\n\n一、核心定义与时序规则\ndef_B（定值集合）  \n\n定义：在基本块 B 中被赋值（定义），且赋值操作先于任何使用的变量集合。  \n时序规则：若变量在 B 中被赋值，且该赋值前未被使用，则属于 def_B。赋值后若再使用，不影响 def_B 的归属。  \n作用：def_B 中的变量在 B 入口处一定不活跃（因新赋值“杀死”了之前的值）。\n\n\nuse_B（使用集合）  \n\n定义：在基本块 B 中被使用（引用），且使用操作先于任何赋值的变量集合。  \n时序规则：若变量在 B 中被使用，且该使用前未被赋值，则属于 use_B。使用后再赋值不影响 use_B 的归属。  \n作用：use_B 中的变量在 B 入口处一定活跃（因需使用其值）。\n\n\n\n\n二、实例说明不同情况情况1：单条赋值语句\n\n\n\n语句\ndef\nuse\n解释\n\n\n\n\na = b + c;\n&#123;a&#125;\n&#123;b,c&#125;\na 被赋值（先于使用），b,c 被使用（先于赋值）\n\n\nx = x * 2;\n&#123;x&#125;\n&#123;x&#125;\n右侧 x 使用先于左侧赋值，故同时属于 use 和 def\n\n\n\n\n\n注：若变量在同一语句中先使用后赋值（如 x = x + 1），则同时属于 use_B 和 def_B。\n\n\n情况2：基本块内多语句时序b = a + 1;  // 语句1c = c + b;  // 语句2a = b * 2;  // 语句3\n\n分析：  \n语句1：def=&#123;b&#125;, use=&#123;a&#125;（a 使用先于赋值，b 新赋值）  \n语句2：def=&#123;c&#125;, use=&#123;c,b&#125;（右侧 c 使用先于左侧赋值）  \n语句3：def=&#123;a&#125;, use=&#123;b&#125;  \n\n\n整体 def_B 和 use_B：  \ndef_B = &#123;a,b,c&#125;（所有被赋值的变量）  \nuse_B = &#123;a,c&#125;（仅语句1的 a 和语句2的 c，因它们使用前无定义）  \n\n\n\n\n关键：use_B 仅包含第一次使用前无赋值的变量（如 a 在语句1使用前无赋值），而后续使用（如语句2的 b）因已有定义，不属于 use_B。\n\n\n情况3：分支与循环结构if (x &gt; y) &#123;   // 分支条件    z = x;     // 语句1&#125; else &#123;    z = y;     // 语句2&#125;w = z;         // 语句3\n\n基本块划分：  \nB1（条件）：use=&#123;x,y&#125;, def=∅  \nB2（语句1）：def=&#123;z&#125;, use=&#123;x&#125;  \nB3（语句2）：def=&#123;z&#125;, use=&#123;y&#125;  \nB4（语句3）：def=&#123;w&#125;, use=&#123;z&#125;  \n\n\nuse_B 的传递性：B4 的 use=&#123;z&#125; 要求 z 在 B2/B3 出口处活跃，进而要求 x,y 在 B1 入口活跃。\n\n\n情况4：变量重定义v = 10;     // 语句1v = v + 5;  // 语句2\n\n语句1：def=&#123;v&#125;, use=∅（赋值前未使用）  \n语句2：def=&#123;v&#125;, use=&#123;v&#125;（右侧 v 使用先于左侧赋值）  \n整体：def_B = &#123;v&#125;, use_B = ∅  \n原因：语句1的 v 在 use_B 中不活跃（因后续被重定义），仅语句2的 v 属于 use，但因其使用前已有定义（语句1），故不属于 use_B。\n\n\n\n\n情况5：控制流语句（如 if/goto）if (c &gt; 0) goto L0;  // 条件跳转\n\ndef=∅：未定义新变量  \nuse=&#123;c&#125;：条件表达式引用 c 且使用前无赋值。\n\n\n三、特殊场景与边界\n循环中的变量：  \n\n循环变量（如 i）在循环入口处活跃，因其值在后续迭代中被使用。  \n若循环内重定义变量（如 i = i+1），则属于 def 和 use（如情况1）。\n\n\nPhi函数（SSA形式）：在静态单赋值（SSA）中，Phi函数合并多路径值：  \nx = φ(x1, x2)  // 合并前驱路径的x1,x2\n\ndef=&#123;x&#125;（新定义变量）  \nuse=&#123;x1,x2&#125;（引用前驱路径的值）。\n\n\n\n\n四、def/use 在数据流方程中的作用活跃变量计算依赖以下方程：  \n\nOUT[B] = ∪ IN[S]（S 是 B 的后继）  \nIN[B] = use_B ∪ (OUT[B] - def_B)  \nuse_B 强制入口活跃性；  \nOUT[B] - def_B 表示出口活跃的变量若未被重定义，则入口也活跃。\n\n\n\n\n总结def_B 和 use_B 的核心区别在于时序：  \n\nuse_B：变量在使用前无定义（需入口活跃）；  \ndef_B：变量在定义前无使用（杀死入口活跃性）。通过上述实例可明确不同语句和控制结构下的集合归属，为编译器优化（如寄存器分配、死代码删除）提供依据。\n\n可用表达式分析（Available Expressions Analysis）是一种前向数据流分析技术，用于确定在程序点可被重复使用的表达式计算结果。其核心在于识别表达式是否“可用”——即在不被重新定义的情况下，其值在后续使用点仍有效。以下从定义、规则和实例三方面展开分析：\n\n📌 一、e_gen[B] 和 e_kill[B] 的准确定义\ne_gen[B]（生成集合）  \n\n含义：基本块 B 中新计算且未被后续操作覆盖的表达式集合。  \n条件：  \n表达式在 B 中被计算（如 x + y）；  \n计算后，表达式中的所有变量在 B 内未被重新定义。  \n\n\n作用：标记 B 中“新鲜”的表达式，其值可被后续路径复用。\n\n\ne_kill[B]（注销集合）  \n\n含义：被 B 破坏可用性的表达式集合。  \n条件：表达式包含的变量在 B 中被重新定义。  \n作用：标记因变量重定义而失效的表达式，无论其此前是否可用。\n\n\n\n\n数据流方程：  \n\nOUT[B] = e_gen[B] ∪ (IN[B] - e_kill[B])  \nIN[B] = ∩_&#123;P∈前驱(B)&#125; OUT[P]（前向交汇操作为交集）\n\n\n\n🧩 二、实例分析：各类场景下的 e_gen 与 e_kill场景1：基本块内无重定义// 基本块 B1a = b + c;    // 表达式: b+cd = b * c;    // 表达式: b*c\n\n分析：  \nb+c 和 b*c 均被计算，且变量 b、c 未被重定义 → e_gen[B1] = &#123;b+c, b*c&#125;  \n无变量被重定义 → e_kill[B1] = ∅  \n\n\n解释：两个表达式在 B1 出口处均可用。\n\n\n场景2：变量被重定义// 基本块 B2x = b + c;    // 表达式: b+cb = 10;       // 重定义 by = b + c;    // 表达式: b+c (值已变)\n\n分析：  \n第一行计算 b+c → 生成 &#123;b+c&#125;；  \n第二行重定义 b → 杀死所有含 b 的表达式（即 b+c）；  \n第三行计算新的 b+c → 生成 &#123;b+c&#125;（覆盖旧值）。  \ne_gen[B2] = &#123;b+c&#125;（仅第三行的新表达式）  \ne_kill[B2] = &#123;b+c&#125;（因 b 被重定义）  \n\n\n解释：重定义 b 后，原 b+c 失效，新 b+c 可用。\n\n\n场景3：部分变量被重定义// 基本块 B3p = a * b;    // 表达式: a*ba = 5;        // 重定义 aq = a * c;    // 表达式: a*c\n\n分析：  \na*b 被计算 → 生成 &#123;a*b&#125;；  \n重定义 a → 杀死所有含 a 的表达式（如 a*b, a*c）；  \na*c 被计算 → 生成 &#123;a*c&#125;。  \ne_gen[B3] = &#123;a*c&#125;  \ne_kill[B3] = &#123;a*b, a*c&#125;（因 a 被重定义）  \n\n\n解释：重定义 a 后，a*b 失效，新生成的 a*c 可用。\n\n\n场景4：多表达式与重复计算// 基本块 B4t1 = x + y;   // 表达式: x+yt2 = x * y;   // 表达式: x*yt3 = x + y;   // 表达式: x+y (重复)\n\n分析：  \nx+y 首次计算 → 生成 &#123;x+y&#125;；  \nx*y 计算 → 生成 &#123;x*y&#125;；  \n再次计算 x+y → 不重复生成（因值未变）。  \ne_gen[B4] = &#123;x+y, x*y&#125;  \ne_kill[B4] = ∅（无变量重定义）  \n\n\n解释：重复表达式仅首次生成，x+y 仍可用。\n\n\n场景5：分支与循环结构flowchart TB    B1[&quot;B1: a = b + c&quot;] --&gt; B2    B2&#123;&quot;B2: if (a &gt; 0)&quot;&#125;    B2 --&gt;|true| B3[&quot;B3: d = b * c&quot;]    B2 --&gt;|false| B4[&quot;B4: b = 10&quot;]    B3 --&gt; B5    B4 --&gt; B5[&quot;B5: e = b + c&quot;]\n\n分析：  \nB1：计算 b+c → e_gen[B1] = &#123;b+c&#125;, e_kill[B1] = ∅（a 重定义不影响 b+c）。  \nB3：计算 b*c → e_gen[B3] = &#123;b*c&#125;, e_kill[B3] = ∅。  \nB4：重定义 b → e_gen[B4] = ∅, e_kill[B4] = &#123;b+c, b*c&#125;（杀死含 b 的表达式）。  \nB5：  \n输入 IN[B5] = OUT[B3] ∩ OUT[B4] = &#123;b+c&#125; ∩ ∅ = ∅（交汇操作为交集）。  \n计算 b+c → e_gen[B5] = &#123;b+c&#125;（因输入为空，生成新表达式）。  \n\n\n\n\n\n\n关键点：分支交汇点取交集，B4 杀死 b+c 导致 B5 入口无可用表达式。\n\n\n⚙️ 三、e_gen 和 e_kill 在优化中的应用\n公共子表达式消除（CSE）：若表达式在 IN[B] 中可用，则无需重复计算，直接复用结果。示例：  \n// 优化前x = a + b;y = a + b;  // 可复用 x\n// 优化后x = a + b;y = x;      // 直接赋值\n\n循环不变代码外提：若循环体内表达式可用（不依赖循环变量），可提到循环外。示例：  \n// 优化前while (i &lt; n) &#123;    z = x + y;  // x,y 在循环内不变    // ...&#125;\n// 优化后temp = x + y;while (i &lt; n) &#123;    z = temp;   // 直接使用预计算结果    // ...&#125;\n\n\n\n💎 四、边界与注意事项\n表达式形式敏感性：仅语法相同的表达式视为同一表达式（如 a+b 与 b+a 不同）。  \n副作用的影响：若表达式含可能副作用的函数（如 rand()），需排除分析。  \n循环闭包计算：循环区域的传递函数需计算闭包（F* = F^0 ∪ F^1 ∪ ...），以覆盖任意次迭代。  \n\n\n🔚 总结\n\n\n\n概念\n含义\n影响\n\n\n\n\ne_gen[B]\n块内新增且变量未重定义的表达式\n增加可用表达式\n\n\ne_kill[B]\n因变量重定义而失效的表达式\n移除失效表达式\n\n\n\n\ne_gen 和 e_kill 通过数据流方程驱动可用表达式的传播与失效，为编译器优化（如CSE、代码外提）提供关键依据。实际应用中需结合控制流拓扑，通过迭代算法求解不动点，最终确定全局可用表达式集合。\n支配性与控制依赖性对比• 基本块B控制依赖于基本块A，当且仅当：• A的执行结果决定B是否会被执行• 基本块B控制依赖于基本块A，当且仅当：• A有多个后继块• 并非所有后继块都能到达B• 根据定义，我们总是需要从B的所有后继块向前遍历才能判断A是否控制依赖于B。这种计算方式代价过高！\n","tags":["其他"]},{"title":"期末重点0603","url":"/notes.github.io/2025/06/23/%E6%9C%9F%E6%9C%AB%E9%87%8D%E7%82%B90603/","content":"Chaitin算法：寄存器分配的核心方法详解Chaitin算法是由Gregory Chaitin在1982年提出的经典图着色寄存器分配算法，它通过将寄存器分配问题转化为图着色问题来解决这一编译器优化中的关键挑战。\n算法基本原理Chaitin算法的核心思想是将寄存器分配问题建模为图着色问题：\n\n冲突图(Interference Graph)构建：将程序中的变量表示为图中的节点，如果两个变量在程序执行过程中同时存活(即它们的生命周期重叠)，则在对应的节点之间画一条边。\n\n图着色问题转化：将寄存器分配问题转化为为冲突图着色的问题，其中：\n\n每种颜色代表一个物理寄存器\n相邻节点(有边连接的节点)不能着相同颜色\n颜色数量等于可用物理寄存器数量\n\n\n\n算法详细步骤1. 构建冲突图\n通过活跃变量分析确定每个变量的生命周期\n对于每对同时活跃的变量，在冲突图中添加一条边\n\n2. 简化图(Simplify)递归地移除度(相邻边数)小于k(可用寄存器数)的节点：while 存在度 &lt; k 的节点 n:    将n压入栈    从图中移除n及其所有边\n3. 潜在溢出节点处理当图中所有节点的度 ≥ k时：\n\n选择一个启发式认为”最佳”的节点作为溢出候选(基于使用频率、生命周期长度等)\n将该节点标记为可能溢出并压入栈\n从图中移除该节点及其边\n返回简化步骤\n\n4. 着色阶段从栈中逐个弹出节点并尝试着色：while 栈不为空:    n = 弹出栈顶节点    将n重新加入图中，恢复其所有边    尝试为n分配一个与所有相邻节点不同的颜色    如果失败且n未被标记为溢出:        实际溢出发生，需要生成溢出代码\n5. 溢出处理当无法为节点分配寄存器时：\n\n将该变量的某些使用替换为内存访问\n可能需要重新计算活跃变量信息并重建冲突图\n\n关键优化与变种\nBriggs变种：改进溢出选择策略，只有当两个高度数节点的共同邻居数≥k时才必然溢出\n\nGeorge变种：更精确的溢出条件判断，考虑节点是否能与某个已着色节点共享颜色\n\n乐观着色(Optimistic Coloring)：先尝试着色，失败时才处理溢出\n\n合并移动相关节点(Coalescing)：合并那些可以通过寄存器移动相关的节点(如a=b的情况)\n\n\n算法复杂度分析\n构建冲突图：O(n²)最坏情况，n为变量数\n简化阶段：O(n)\n着色阶段：O(n²)最坏情况\n总体：多项式时间，实践中通常表现良好\n\n实际应用考虑\n启发式选择：溢出节点的选择策略显著影响结果质量\n\n架构限制：某些架构有特殊的寄存器使用约束需要额外处理\n\n多轮迭代：有时需要多轮分配和溢出处理才能得到满意结果\n\n与指令调度交互：寄存器分配和指令调度相互影响，可能需要协同优化\n\n\nChaitin算法因其简洁性和有效性，至今仍是许多编译器后端的基础寄存器分配方法，现代编译器如LLVM、GCC等都采用了基于Chaitin思想的改进算法。\n","tags":["其他"]},{"title":"期末考试复习细节","url":"/notes.github.io/2025/06/23/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%BB%86%E8%8A%82/","content":"期末考试复习细节第七章 链接ccp -&gt; .i -&gt; cc1 -&gt; .s -&gt; as -&gt; .o -&gt; ld -&gt; prog(exec)\n动态链接器负责链接共享库，运行时加载共享库\n位置无关代码：可以被加载到内存的任何位置，不需要重定位，共享库的编译总是需要加上 -fPIC 选项\n编译时打桩：需要访问源代码\n链接时打桩：需要访问可重定向目标文件\n运行时打桩：只需要访问可执行文件\n第八章 异常控制流SIGKILL 和 SIGSTOP 不能被捕获或忽略\n对信号 S 的信号处理函数可以被对信号 T 的处理函数中断（过程转移），处理完 T 后再继续处理 S\n第九章 虚拟内存TLB 对页表进行缓存，以 VPN 查询\nTLB 可以在 MMU 内缓存多级页表，页表存在于内存中，只有一级页表常驻内存，其他级别的页表在需要时才加载到内存中（或者根本没创建）\n内部碎片：分配块大小-有效载荷大小，包括头脚部\nCache 高速缓存是物理寻址的，进程切换时/内核态切换时不需要刷新\nTLB 是虚拟寻址的，进程切换时需要刷新，但是内核态切换时不需要刷新（因为内核态的虚拟地址空间是共享的，即不改变内存映射）\nCore i7 每个页表项为 8 字节，包括各种控制位 + 页表物理基地址\nA 位（引用位）和 D 位（修改位）由 MMU 在读写时设置，由软件擦除，从而实现一些页替换算法（如 LRU）\n图 9.22 的寻址过程很重要\n任务结构：进程间独立\npgd（Page Global Directory）：页全局目录，存放一级页表的物理地址，也存放在 CR3 寄存器中\nP581\nmmap（Memory Map）：指向一个 vm_area_struct （区域结构）的链表，每个 vm_area_struct 描述了一个虚拟内存区域\n\nvm_start：区域开始的虚拟地址\nvm_end：区域结束的虚拟地址\nvm_next：指向下一个区域的指针\nvm_prot：区域的保护位，如可读、可写、可执行\nvm_flags：区域的标志位，\n\n第十章 系统级 I/Odup2 函数是一个在类 Unix 操作系统中用于处理文件描述符的系统调用。它的作用是将一个已打开的文件描述符复制到另一个指定的文件描述符。如果目标文件描述符已经打开，dup2 会先将其关闭，然后进行复制。如果目标文件描述符未打开，dup2 会直接复制文件描述符。\n因而，可以向一个未打开的描述符进行复制、从一个未打开的描述符复制（即未打开的描述符是 dup2 的第一个参数）都是合法的（但是后者一旦开始写就会报错）。\n第十一章 网络编程IP 地址和端口号总是以网络字节序存储，即大端序\nhostname -i 返回点分十进制的 IP 地址（而不是域名）\n第十二章 并发编程可重入的：不引用任何共享变量\n\n显式可重入：函数参数都是按值传递的，并且所有数据引用都是本地自动栈变量（没有引用静态/全局变量）\n隐式可重入：允许传递指针，但是线程小心地传递指向非共享数据的指针\n\n线程安全的：多个并发线程反复调用该函数，不会出错\n线程不安全类：\n\n不保护共享变量\n保持跨越多个调用的状态信息，如随机数发生器\n返回指向静态变量的指针\n调用了线程不安全的函数，但这类不一定是线程不安全的\n\n复习相关洞：4513174（太细）\n5813817\n","tags":["PKU/Introduction-to-Computer-System-2023Fall-PKU/复习资料"]}]