<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/notes.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/notes.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/notes.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/notes.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/notes.github.io/css/main.css">


<link rel="stylesheet" href="/notes.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhan20050128.github.io","root":"/notes.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cz Blog">
<meta property="og:url" content="https://chenzhan20050128.github.io/notes.github.io/page/3/index.html">
<meta property="og:site_name" content="cz Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chen Zhan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chenzhan20050128.github.io/notes.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>cz Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/notes.github.io/atom.xml" title="cz Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/notes.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cz Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/notes.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/notes.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/chenzhan20050128" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">设备管理笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:25:29" itemprop="dateCreated datePublished" datetime="2025-06-23T12:25:29+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、层次结构框架"><a href="#一、层次结构框架" class="headerlink" title="一、层次结构框架"></a>一、层次结构框架</h3><p>典型I&#x2F;O子系统分为五层（如图5-3）：</p>
<ol>
<li><strong>用户层I&#x2F;O软件</strong>（库函数、SPOOLing）  </li>
<li><strong>设备独立性软件</strong>（命名映射、缓冲管理）  </li>
<li><strong>设备驱动程序</strong>（硬件命令转换）  </li>
<li><strong>中断处理程序</strong>（硬件信号处理）  </li>
<li><strong>硬件层</strong>（控制器、设备）</li>
</ol>
<h3 id="二、层级间交互机制"><a href="#二、层级间交互机制" class="headerlink" title="二、层级间交互机制"></a>二、层级间交互机制</h3><h4 id="1-用户层与设备无关层的接口"><a href="#1-用户层与设备无关层的接口" class="headerlink" title="1. 用户层与设备无关层的接口"></a>1. 用户层与设备无关层的接口</h4><ul>
<li><strong>系统调用传递</strong>：用户程序通过<code>read/write</code>等系统调用进入内核态，例如<code>printf</code>调用会触发<code>write</code>系统调用  </li>
<li><strong>参数标准化</strong>：用户层传递逻辑设备名（如<code>/dev/sda</code>），设备无关层通过逻辑设备表（LUT）将其映射为物理设备地址  </li>
<li><strong>错误屏蔽</strong>：设备无关层过滤底层硬件错误（如磁盘重试机制），仅向上报告无法处理的异常</li>
</ul>
<h4 id="2-设备无关层与驱动层的协作"><a href="#2-设备无关层与驱动层的协作" class="headerlink" title="2. 设备无关层与驱动层的协作"></a>2. 设备无关层与驱动层的协作</h4><ul>
<li><strong>请求封装</strong>：将逻辑I&#x2F;O请求（如文件偏移量）转换为物理块地址，并通过设备控制表（DCT）选择对应驱动程序  </li>
<li><strong>资源调度</strong>：执行I&#x2F;O调度算法（如磁盘电梯算法），合并相邻请求优化性能  </li>
<li><strong>缓冲区管理</strong>：在内核空间建立数据缓冲区，协调用户空间与设备速度差异（如PageCache机制）</li>
</ul>
<h4 id="3-驱动层与硬件控制器的交互"><a href="#3-驱动层与硬件控制器的交互" class="headerlink" title="3. 驱动层与硬件控制器的交互"></a>3. 驱动层与硬件控制器的交互</h4><ul>
<li><strong>寄存器操作</strong>：驱动程序向设备控制器的命令寄存器写入操作码（如SCSI命令），设置DMA传输参数  </li>
<li><strong>状态轮询</strong>：通过控制器状态寄存器检测设备就绪状态，或等待中断信号  </li>
<li><strong>协议适配</strong>：将标准I&#x2F;O命令转换为设备专属指令序列（如不同品牌打印机的控制码）</li>
</ul>
<h4 id="4-硬件层与中断处理的联动"><a href="#4-硬件层与中断处理的联动" class="headerlink" title="4. 硬件层与中断处理的联动"></a>4. 硬件层与中断处理的联动</h4><ul>
<li><strong>中断触发</strong>：设备完成操作后通过中断控制器（如APIC）向CPU发送信号  </li>
<li><strong>上下文保存</strong>：中断处理程序保存被中断进程的寄存器状态到内核栈  </li>
<li><strong>状态反馈</strong>：读取控制器状态寄存器，将结果写入内核缓冲区并唤醒阻塞进程</li>
</ul>
<h3 id="三、关键数据流示例（以磁盘读取为例）"><a href="#三、关键数据流示例（以磁盘读取为例）" class="headerlink" title="三、关键数据流示例（以磁盘读取为例）"></a>三、关键数据流示例（以磁盘读取为例）</h3><ol>
<li><strong>用户层</strong>：<code>fread()</code>调用触发系统调用<code>read(fd, buf, size)</code>  </li>
<li><strong>设备无关层</strong>：  <ul>
<li>检查文件权限  </li>
<li>将文件偏移转换为物理扇区号  </li>
<li>分配内核缓冲区并加入I&#x2F;O调度队列</li>
</ul>
</li>
<li><strong>驱动层</strong>：  <ul>
<li>向磁盘控制器发送<code>READ SECTOR</code>命令  </li>
<li>设置DMA传输目标地址为内核缓冲区</li>
</ul>
</li>
<li><strong>硬件层</strong>：  <ul>
<li>磁盘控制器执行寻道操作  </li>
<li>DMA引擎直接将数据写入内核缓冲区</li>
</ul>
</li>
<li><strong>中断处理</strong>：  <ul>
<li>DMA完成中断触发后，将数据从内核缓冲区复制到用户缓冲区  </li>
<li>唤醒等待该I&#x2F;O完成的进程</li>
</ul>
</li>
</ol>
<h3 id="四、分层设计的优势"><a href="#四、分层设计的优势" class="headerlink" title="四、分层设计的优势"></a>四、分层设计的优势</h3><ol>
<li><strong>接口标准化</strong>：每层仅暴露抽象接口（如驱动层的<code>read/write</code>方法），隐藏实现细节  </li>
<li><strong>错误隔离</strong>：设备驱动故障不会导致上层崩溃（如USB设备异常仅影响对应驱动）  </li>
<li><strong>扩展性</strong>：新增设备只需实现驱动层，无需修改上层逻辑（如NVMe SSD兼容SATA接口）  </li>
<li><strong>性能优化</strong>：各层独立实现缓存策略（用户层缓冲区 vs 内核PageCache）</li>
</ol>
<h3 id="五、跨层优化技术"><a href="#五、跨层优化技术" class="headerlink" title="五、跨层优化技术"></a>五、跨层优化技术</h3><ol>
<li><strong>零拷贝（Zero-Copy）</strong>：绕过内核缓冲区，直接让用户空间与DMA引擎交互  </li>
<li><strong>异步I&#x2F;O</strong>：通过<code>io_uring</code>等机制实现请求批量提交和完成事件通知  </li>
<li><strong>直接内存访问（DMA）</strong>：硬件控制器直接访问内存，减少CPU介入</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">操作系统：第三章复习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-06-23 12:25:29 / 修改时间：12:26:30" itemprop="dateCreated datePublished" datetime="2025-06-23T12:25:29+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="可变分区方式的内存分配"><a href="#可变分区方式的内存分配" class="headerlink" title="可变分区方式的内存分配"></a>可变分区方式的内存分配</h2><h3 id="内存分配算法整理"><a href="#内存分配算法整理" class="headerlink" title="内存分配算法整理"></a><strong>内存分配算法整理</strong></h3><table>
<thead>
<tr>
<th>算法</th>
<th>分配策略</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>最先适应 (First-Fit)</strong></td>
<td>从头找第一个足够大的</td>
<td>简单高效，适合大作业</td>
<td>低&#x2F;高地址利用不均，回收麻烦</td>
<td>通用</td>
</tr>
<tr>
<td><strong>邻近适应 (Next-Fit)</strong></td>
<td>从上次位置开始找</td>
<td>查找更快，空间均衡</td>
<td>可能分割大空闲区</td>
<td>中等负载</td>
</tr>
<tr>
<td><strong>最优适应 (Best-Fit)</strong></td>
<td>找最小的足够大的</td>
<td>减少大分区浪费</td>
<td>产生小碎片，查找慢</td>
<td>中小作业</td>
</tr>
<tr>
<td><strong>最坏适应 (Worst-Fit)</strong></td>
<td>找最大的分区</td>
<td>减少小碎片</td>
<td>可能耗尽大分区</td>
<td>中小作业</td>
</tr>
<tr>
<td><strong>快速适应 (Quick-Fit)</strong></td>
<td>维护常用大小链表</td>
<td>查找极快</td>
<td>合并复杂，额外开销</td>
<td>特定场景</td>
</tr>
</tbody></table>
<p><strong>最常用</strong>：最先适应（简单高效） &gt; 邻近适应 &gt; 最优适应。</p>
<h2 id="外部碎片-内部碎片"><a href="#外部碎片-内部碎片" class="headerlink" title="外部碎片 内部碎片"></a>外部碎片 内部碎片</h2><p>内部零头（Internal Fragmentation）​<br>​定义：分配给进程的内存块比实际需求大，导致块内部有未使用的空间。<br>外部零头（External Fragmentation）​<br>​定义：内存中存在多个分散的小空闲区，但每个单独的空闲区都太小，无法满足进程需求。<br>​最先适应（First-Fit）​：倾向于使用低地址的大空闲区，可能保留高地址的大块空闲区，外零头较少。<br>​最坏适应（Worst-Fit）​：总是分配最大的空闲区，减少小碎片产生，但可能耗尽大分区。<br>​最优适应（Best-Fit）​：​最激进地切割空闲区，故外零头问题最严重。</p>
<h1 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h1><table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>定义</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>页号</strong></td>
<td>进程虚拟地址空间的逻辑划分单元编号（如4KB一页的序号）</td>
<td>标识虚拟内存中的逻辑页位置</td>
</tr>
<tr>
<td><strong>页框号</strong></td>
<td>物理内存中实际存储块的编号（与页大小相同的物理块，也称页帧号&#x2F;Physical Frame）</td>
<td>定位数据在物理内存中的实际存储位置</td>
</tr>
</tbody></table>
<p><strong>关键区别</strong>：  </p>
<ul>
<li>页号属于<strong>虚拟地址空间</strong>（进程视角），页框号属于<strong>物理地址空间</strong>（硬件视角）。  </li>
<li>页表的核心功能就是完成<strong>页号→页框号</strong>的映射（如下图所示）：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址 = [页号][页内偏移] </span><br><span class="line">          ↓ 页表转换</span><br><span class="line">物理地址 = [页框号][页内偏移]</span><br></pre></td></tr></table></figure>
<img src="/notes.github.io/image-13.png" alt="alt text"></li>
</ul>
<h2 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h2><p>正向页表（每个进程一个）：​<br>​索引：​ 虚拟页号 (VPN)<br>​表项内容：​ 物理页框号 (PFN) + 标志位<br>​大小：​ 与进程的虚拟地址空间大小成正比（每个可能的虚拟页都有一个表项，即使该页未使用）。<br>​反置页表（整个系统一个）：​<br>​索引：​ 物理页框号 (PFN) (隐含在表项位置中)<br>​表项内容：​ 进程ID (PID) + 虚拟页号 (VPN) + 标志位<br>​大小：​ 与物理内存大小成正比（每个物理页框对应一个表项）。<br>适用场景：​ 主要用在物理内存相对较小而虚拟地址空间非常大的系统中（如64位系统），或者嵌入式系统等资源受限环境。<br> 反置页表的页表项<br>页号：虚拟地址页号<br>进程标志符：使用该页的进程号(页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页)<br>标志位：有效、引用、修改、保护和锁定等标志信息<br>链指针：哈希链，如果某个项没有链项，则该域为空(允许用一个单独的位来表示)<br><img src="/notes.github.io/image-14.png" alt="alt text"></p>
<h2 id="段式"><a href="#段式" class="headerlink" title="段式"></a>段式</h2><p>页式存储管理中页的划分对程序员不可见。<br>段式存储管理中段的划分对程序员可见。<br>分段是信息的逻辑单位，由源程序的逻辑结构所决定，用户可见<br>段长可根据用户需要来规定，段起始地址可从任何主存地址开始。<br>分段方式中，源程序(段号，段内位移)经连结装配后地址仍保持二维结构。<br>分页是信息的物理单位，与源程序的逻辑结构无关，用户不可见，<br>页长由系统确定，页面只能以页大小的整倍数地址开始<br>分页方式中，源程序(页号，页内位移)经连结装配后地址变成了一维结构<br><img src="/notes.github.io/image-15.png" alt="alt text"></p>
<p>传统教科书中的段页式 &#x3D; ​分段（逻辑划分）+ 分页（物理划分）​：<br>程序地址空间被划分为逻辑段​（代码、数据、堆、栈等）。<br>每个逻辑段被独立分页​（即段内地址再被拆分为页号和页内偏移）。<br>​硬件流程：CPU生成地址（段号, 段内偏移）→ 段表 → 得到段基址和线性地址 → 线性地址通过页表 → 物理地址。</p>
<h2 id="页式"><a href="#页式" class="headerlink" title="页式"></a>页式</h2><p>需要扩充页表项，至少包含如上信息，指出：<br>主存驻留标志：指出页面是否已经装入内存。1表示在内存中可以被正常访问，0表示不能立即访问，产生缺页异常。<br>修改位：被设置后，该页被调出内存前必须先写回磁盘，保障数据一致性<br>保护位：限制页面访问权限<br>引用位：在页面被引用无论是读写时设置，用来帮助系统进行页面淘汰。<br>内存块号：页面对应的页框号，用来地址转换</p>
<p><img src="/notes.github.io/image-16.png" alt="alt text"><br>维度	全局替换	局部替换<br>置换范围	全系统物理帧	当前进程分配的帧<br>帧分配方式	动态（按需调整）	静态（预先固定）<br>公平性	低（强者通吃）	高（隔离保护）<br>适用场景	通用计算（如Linux&#x2F;Windows）	实时系统、嵌入式系统</p>
<h1 id="全局页面替换策略"><a href="#全局页面替换策略" class="headerlink" title="全局页面替换策略"></a>全局页面替换策略</h1><h2 id="OPT页面调度算法-Belady算法"><a href="#OPT页面调度算法-Belady算法" class="headerlink" title="OPT页面调度算法(Belady算法)"></a>OPT页面调度算法(Belady算法)</h2><p>算法描述：当要调入新页面时，首先淘汰以后不再访问的页，然后选择距现在最长时间后再访问的页。<br>该方法由Belady提出，称为BeLady算法，又称最佳算法(OPT)<br>OPT只可以模拟，不可以实现，因为永远无法预知之后的事情。<br>这种算法可以用作衡量其他各种算法的标准</p>
<h2 id="先进先出页面调度算法-FIFO"><a href="#先进先出页面调度算法-FIFO" class="headerlink" title="先进先出页面调度算法(FIFO)"></a>先进先出页面调度算法(FIFO)</h2><p>算法描述：首先淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页(常驻的除外)<br>模拟的是程序执行的顺序性，有一定合理性，并不能很好模拟程序的循环性。<br>根据估计，缺页中断率也是最佳算法的2-3倍。<br><img src="/notes.github.io/image-17.png" alt="alt text"></p>
<h2 id="最近最少用LRU页面调度算法"><a href="#最近最少用LRU页面调度算法" class="headerlink" title="最近最少用LRU页面调度算法"></a>最近最少用LRU页面调度算法</h2><p>淘汰最近一段时间较久未被访问的那一页，即那些刚被使用过的页面，可以马上还要被使用到。<br>模拟了程序执行的局部属性，既考虑了循环性，又兼顾了顺序性<br>LRU算法得到模拟实现：模拟是相当的不严谨，非常粗粒度的一个模拟。<br>引用位法：每页建立一个引用标志，供硬件使用，设置一个时间间隔中断，发生时将页引用标志置0，访问页面时将引用标志置为1，页面置换的时候选择标志为0的页面，在选中淘汰页时，将所有的页的引用为全部置为0<br>计数法：每页添加页面引用计数器，根据计数器选择最小的，定时清空页面引用计数器<br>计时法：每页添加计时单元，引用时，将绝对时间记录进入计时单元，定时清空计时单元。<br>老化算法：设置一个多位寄存器，被访问将最左侧设置为1，定时将寄存器右移，缺页中断时找到最小值的寄存器界面淘汰，被采用较多。</p>
<h2 id="第二次机会页面替换算法-SCR，Second-Chance-Replacement"><a href="#第二次机会页面替换算法-SCR，Second-Chance-Replacement" class="headerlink" title="第二次机会页面替换算法(SCR，Second Chance Replacement)"></a>第二次机会页面替换算法(SCR，Second Chance Replacement)</h2><p>将FIFO算法和页表中引用位结合。<br>算法描述：<br>首先检查FIFO页面队列队首<br>引用位为0，则淘汰该页面<br>引用位为1，将引用位清0，并将该页面移到队列尾部<br>如果第一遍全为1，则循环</p>
<h2 id="最不常用LFU的页面调度算法"><a href="#最不常用LFU的页面调度算法" class="headerlink" title="最不常用LFU的页面调度算法"></a>最不常用LFU的页面调度算法</h2><p>淘汰最近一段时间内访问次数较少的页面，对OPT的模拟性比LRU更好<br>算法过程：基于时间间隔中断，并给每一页设置一个计数器，时间间隔中断发生后，所有计数器清0，每访问页1次就给计数器加1，选择计数最小的页面淘汰</p>
<h2 id="伙伴算法与slab"><a href="#伙伴算法与slab" class="headerlink" title="伙伴算法与slab"></a>伙伴算法与slab</h2><p>伙伴系统的分配和回收过程<br>分配过程：当系统需要内存时，从对应大小的链表中查找空闲块。如果没有找到，就向更大的内存块查找，并将其分裂为合适的大小进行分配。</p>
<p>伙伴系统分配内存的过程较为复杂。首先，当系统需要内存时，会根据所需内存的大小确定对应的页阶（order）。然后从对应页阶的链表中查找空闲块。如果在该链表中没有找到空闲块，就会向更大页阶的链表查找。例如，当需要一个 128 个页的页块时，先检查 128 个页的页块链表是否有空闲块。如果没有，则查 256 个页的页块链表；如果有空闲块的话，则将 256 个页的页块分成两份，一份使用，一份插入 128 个页的页块链表中。如果还是没有，就查 512 个页的页块链表；如果有的话，就分裂为 128、128、256 三个页块，一个 128 的使用，剩余两个插入对应页块链表。<br>其实伙伴系统算法有如下3个基本条件需要满足：</p>
<p>两个内存块的大小相同</p>
<p>两个内存块的地址连续</p>
<p>两个内存块必须是从同一个大的内存块中分离出来的<br>小于 4KB 的内存分配：Slab 分配器<br>伙伴系统的最小分配单位是 4KB 页框，分配更小内存会产生内部碎片。​Slab 分配器​（及其演进版本 SLUB&#x2F;SLOB）专门解决此问题，为内核对象提供精细化分配。</p>
<ol>
<li>​Slab 的核心机制<br>​对象缓存池：<br>为高频小对象（如 task_struct、inode）创建专用缓存（kmem_cache），预分配并初始化对象。<br>​内存来源：<br>从伙伴系统申请整页（4KB），再划分为多个小对象（如 64B、128B）。<br>​分配流程：<br>优先从 ​Per-CPU 本地缓存 获取空闲对象（无锁操作）。<br>若本地缓存空，从 ​部分空闲的 Slab 补充对象。<br>若无可用 Slab，向伙伴系统申请新页并初始化新 Slab。<br>4MB+： vmalloc<br>伙伴系统（Buddy System）分配的内存空间是虚拟地址连续且物理地址连续的，而 vmalloc 分配的内存是虚拟地址连续但物理地址不连续的<br>vmalloc 是 Linux 内核提供的内存分配函数之一，它用于在虚拟地址空间中分配连续的内存块。与 kmalloc 主要用于物理内存的分配不同，vmalloc 分配的内存并不要求物理内存是连续的，但它确保分配的虚拟地址空间是连续的。<br>在Linux内核中对于物理上连续的分配方式，采用伙伴系统和slub分配器分配内存，但是知道物理上连续的映射是最好的分配方式，但并不总能成功地使用。在分配一大块内存时，可能竭尽全力也无法找到连续的内存块。针对这种情况内核提供了一种申请一片连续的虚拟地址空间，但不保证物理空间连续，也就是vmalloc接口。</li>
</ol>
<p>vmalloc的工作方式类似于kmalloc，只不过前者分配的内存虚拟地址连续，而物理地址则无需连续，因此不能用于dma缓冲区<br>通过vmalloc获得的页必须一个一个地进行映射，效率不高，因此不得已时才使用，同时vmalloc分配的一般是大块内存<br>vmalloc分配的一般是高端内存，只有当内存不够的时候，才会分配低端内存</p>
<p>slab：<br>三级结构<br>层级	作用<br>Slab缓存	每个缓存管理同一类型对象（如task_struct），包含多个Slab。<br>Slab	一组连续的物理页（来自伙伴系统），划分为多个对象槽（Object Chunk）。<br>对象	实际分配的内存单元，大小固定（如task_struct占1KB）。<br>状态分类<br>Full Slab：所有对象已被分配。<br>Partial Slab：部分对象空闲（优先从此分配）。<br>Empty Slab：所有对象空闲（可返还给伙伴系统）。<br>Slab分配器不直接处理任意大小的内存请求，而是通过以下方式分层管理：</p>
<p>专用缓存（kmem_cache）</p>
<p>为高频使用的内核对象（如task_struct）预定义固定大小的缓存（通过kmem_cache_create创建）。<br>对象大小由类型本身决定（如sizeof(struct task_struct)）。<br>通用缓存（kmalloc）</p>
<p>提供一组预定义尺寸的Slab缓存（如32B、64B、128B、…、8KB等2的幂次方大小）。<br>当调用kmalloc(size)时，内核选择最小适配的Slab缓存（如申请100B→分配128B的Slab）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/note1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/note1/" class="post-title-link" itemprop="url">note1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:22:32" itemprop="dateCreated datePublished" datetime="2025-06-23T12:22:32+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p><strong>距离与纠错能力</strong>：通过上述讨论，我们知道：</p>
<ul>
<li>要处理 ( k ) 个擦除错误，需要最小距离 ( \ge k+1 )。</li>
<li>要处理 ( k ) 个一般错误，需要最小距离 ( \ge 2k+1 )。</li>
</ul>
</li>
<li><p><strong>Reed-Solomon码的性质</strong>：</p>
<ul>
<li>Reed-Solomon 码通过将 ( n ) 个消息映射到一个具有 ( n + 2k ) 个符号的码字，其理论最小距离正好是 ( 2k+1 )。</li>
<li>我们通过构造两个在 ( n-1 ) 点相同的不同码字得到了上界 ( 2k+1 )，同时从译码正确性（错误不能互相混淆）知下界也为 ( 2k+1 )，因此二者相等。</li>
</ul>
</li>
<li><p><strong>侧记</strong>：这种证明方式实际上等价于利用了Singleton界，是衡量码设计中极限性能的重要工具。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/notes.github.io/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/notes.github.io/">1</a><a class="page-number" href="/notes.github.io/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Zhan"
      src="/notes.github.io/images/woshicaigou.jpg">
  <p class="site-author-name" itemprop="name">Chen Zhan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/notes.github.io/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Zhan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/notes.github.io/lib/anime.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/notes.github.io/js/utils.js"></script>

<script src="/notes.github.io/js/motion.js"></script>


<script src="/notes.github.io/js/schemes/pisces.js"></script>


<script src="/notes.github.io/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
