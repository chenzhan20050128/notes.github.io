<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/notes.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/notes.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/notes.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/notes.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/notes.github.io/css/main.css">


<link rel="stylesheet" href="/notes.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhan20050128.github.io","root":"/notes.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cz Blog">
<meta property="og:url" content="https://chenzhan20050128.github.io/notes.github.io/index.html">
<meta property="og:site_name" content="cz Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chen Zhan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chenzhan20050128.github.io/notes.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>cz Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/notes.github.io/atom.xml" title="cz Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/notes.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cz Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/notes.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/notes.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/chenzhan20050128" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%9D%A2%E7%BB%8F4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E9%9D%A2%E7%BB%8F4/" class="post-title-link" itemprop="url">面经4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:27:03" itemprop="dateCreated datePublished" datetime="2025-06-23T12:27:03+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>0528</h1>
<ol>
<li>binlog是什么？<br>
MySQL的binlog（Binary Log）是一种二进制日志文件，记录了所有对数据库的修改操作（如INSERT、UPDATE、DELETE等），但不包括查询语句（如SELECT）。它以事件形式存储，包含操作的时间、执行时长等信息。</li>
</ol>
<p>主要作用：</p>
<p>​数据恢复：通过回放binlog可将数据库恢复到特定时间点。<br>
​主从复制：主库的binlog会被同步到从库，实现数据实时同步。<br>
​审计：记录所有数据变更，用于安全审计。<br>
binlog的三种格式：</p>
<p>​Statement-based：记录SQL语句，日志量小但可能因非确定性函数导致主从不一致。<br>
​Row-based：记录行数据变更，精确但日志量大。<br>
​Mixed：混合模式，自动选择Statement或Row格式。<br>
2. MySQL中的日志类型及区别<br>
MySQL主要日志类型包括：</p>
<p>​binlog​（二进制日志）：<br>
作用：数据恢复、主从复制、审计。<br>
存储引擎无关，由Server层实现。<br>
​redo log​（重做日志）：<br>
作用：保证事务的持久性，崩溃恢复时重放未提交的事务。<br>
InnoDB特有，物理日志，记录页面的修改。<br>
​undo log​（回滚日志）：<br>
作用：实现事务回滚和MVCC（多版本并发控制）。<br>
InnoDB特有，逻辑日志，记录修改前的数据。</p>
<p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</p>
<p>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。</p>
<p>当使用 ETag 字段实现的协商缓存的过程：</p>
<p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；<br>
当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：<br>
如果没有过期，则直接使用本地缓存；<br>
如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；<br>
服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：<br>
如果值相等，则返回 304 Not Modified，不会返回资源；<br>
如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；<br>
如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源</p>
<p>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。<br>
注意!!!<br>
实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以后面所有文章讨论 HTTP/1.1 都是建立在没有使用管道化的前提。大家知道有这个功能，但是没有被使用就行了</p>
<p>非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。</p>
<p>然后把你爸爸的「个人信息 + 公钥 + 数字签名」打包成一个数字证书，也就是说这个数字证书包含你爸爸的公钥。</p>
<h3 id="TLS如何为HTTP提供安全性？——以一次完整HTTPS请求为例"><strong>TLS如何为HTTP提供安全性？——以一次完整HTTPS请求为例</strong></h3>
<p>TLS（Transport Layer Security）通过加密、身份验证和完整性保护三大机制，将不安全的HTTP协议升级为安全的HTTPS。以下是<strong>一次完整HTTPS请求的详细流程</strong>，展示TLS如何逐步建立安全通信：</p>
<hr>
<h3 id="1-客户端发起HTTPS请求（Client-Hello）"><strong>1. 客户端发起HTTPS请求（Client Hello）</strong></h3>
<ul>
<li><strong>步骤</strong>：<br>
用户在浏览器输入 <code>https://example.com</code>，浏览器（客户端）向服务器发起TCP连接（默认端口443）。</li>
<li><strong>关键动作</strong>：
<ul>
<li>发送支持的TLS版本（如TLS 1.3）。</li>
<li>列出支持的加密套件（如 <code>TLS_AES_256_GCM_SHA384</code>）。</li>
<li>生成随机数 <strong>Client Random</strong>（用于后续密钥生成）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-服务器响应（Server-Hello）"><strong>2. 服务器响应（Server Hello）</strong></h3>
<ul>
<li><strong>步骤</strong>：<br>
服务器选择双方均支持的TLS版本和加密算法，并返回：
<ul>
<li><strong>Server Random</strong>（另一个随机数）。</li>
<li><strong>数字证书</strong>（包含服务器公钥、域名、CA签名等）。</li>
<li>（可选）要求客户端证书（用于双向认证）。</li>
</ul>
</li>
<li><strong>证书作用</strong>：
<ul>
<li>验证服务器身份（防止中间人攻击）。</li>
<li>提供公钥用于密钥交换（如RSA或ECDHE）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-客户端验证证书"><strong>3. 客户端验证证书</strong></h3>
<ul>
<li><strong>验证内容</strong>：
<ol>
<li><strong>CA可信性</strong>：检查证书是否由受信任的CA（如Let’s Encrypt）签发。</li>
<li><strong>有效期</strong>：确保证书未过期。</li>
<li><strong>域名匹配</strong>：证书中的域名与请求的 <code>example.com</code> 一致。</li>
<li><strong>吊销状态</strong>：通过OCSP或CRL检查证书是否被吊销。</li>
</ol>
</li>
<li><strong>若验证失败</strong>：浏览器显示警告（如“证书无效”）。</li>
</ul>
<hr>
<h3 id="4-密钥交换（Key-Exchange）"><strong>4. 密钥交换（Key Exchange）</strong></h3>
<ul>
<li><strong>非对称加密阶段</strong>：
<ul>
<li><strong>RSA方式</strong>：<br>
客户端生成 <strong>Pre-Master Secret</strong>，用服务器公钥加密后发送，服务器用私钥解密。</li>
<li><strong>ECDHE（推荐）</strong>：<br>
双方通过椭圆曲线Diffie-Hellman算法动态生成 <strong>Pre-Master Secret</strong>，支持前向保密（即使私钥泄露，历史会话也无法解密）。</li>
</ul>
</li>
<li><strong>生成会话密钥</strong>：<br>
客户端和服务器使用 <strong>Client Random + Server Random + Pre-Master Secret</strong>，通过伪随机函数（PRF）生成：
<ul>
<li><strong>对称加密密钥</strong>（如AES-256密钥）。</li>
<li><strong>MAC密钥</strong>（用于校验数据完整性）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-握手完成（Finished）"><strong>5. 握手完成（Finished）</strong></h3>
<ul>
<li><strong>步骤</strong>：<br>
双方发送加密的 <code>Finished</code> 消息，验证握手是否成功。</li>
<li><strong>作用</strong>：
<ul>
<li>确认密钥协商无误。</li>
<li>确保通信未被篡改。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-安全数据传输（对称加密）"><strong>6. 安全数据传输（对称加密）</strong></h3>
<ul>
<li><strong>加密方式</strong>：<br>
使用协商的对称密钥（如AES-256）加密所有HTTP请求和响应。</li>
<li><strong>完整性保护</strong>：<br>
每条消息附加HMAC（如SHA-256）或AEAD（如AES-GCM）标签，防止数据被篡改。</li>
<li><strong>示例</strong>：
<ul>
<li>加密的HTTP请求：<code>GET /login HTTPS/1.1</code> → 加密为乱码传输。</li>
<li>服务器解密后处理，返回加密的响应。</li>
<li></li>
</ul>
</li>
</ul>
<p>HTTP/2 做了什么优化？<br>
HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p>
<p>HTTP/2 是 HTTP 协议的重大升级，旨在解决 HTTP/1.1 的性能瓶颈，提升网络传输效率。以下是 HTTP/2 的主要改进点，结合技术细节和实际应用场景展开说明：</p>
<hr>
<h3 id="1-二进制分帧层（Binary-Framing-Layer）"><strong>1. 二进制分帧层（Binary Framing Layer）</strong></h3>
<ul>
<li><strong>问题</strong>：HTTP/1.1 使用文本格式（如 <code>GET / HTTP/1.1</code>），解析效率低且易出错。</li>
<li><strong>改进</strong>：
<ul>
<li>引入二进制分帧层，将消息拆分为更小的<strong>帧</strong>（Frame），每个帧包含：
<ul>
<li><strong>类型</strong>（如 <code>HEADERS</code>、<code>DATA</code>、<code>PRIORITY</code>）。</li>
<li><strong>流标识符（Stream ID）</strong>：标记帧所属的请求/响应流。</li>
<li><strong>长度和标志位</strong>：控制帧的边界和特性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-多路复用（Multiplexing）"><strong>2. 多路复用（Multiplexing）</strong></h3>
<ul>
<li><strong>问题</strong>：HTTP/1.1 的队头阻塞（HOL Blocking）导致请求必须串行处理，并发需多个 TCP 连接（浏览器限制 6-8 个）。</li>
<li><strong>改进</strong>：
<ul>
<li>在<strong>单个 TCP 连接</strong>上并行传输多个请求/响应，通过 <strong>Stream ID</strong> 区分不同流。</li>
<li>帧可乱序发送，接收方按流 ID 重组。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-头部压缩（HPACK-算法）"><strong>3. 头部压缩（HPACK 算法）</strong></h3>
<ul>
<li><strong>问题</strong>：HTTP/1.1 头部冗余（如 <code>Cookie</code>、<code>User-Agent</code> 重复传输），平均占用 800-1400 字节/请求。</li>
<li><strong>改进</strong>：
<ul>
<li><strong>HPACK 算法</strong>：
<ul>
<li><strong>静态表</strong>：预定义 61 个常见字段（如 <code>:method: GET</code> 用索引 <code>2</code> 表示）。</li>
<li><strong>动态表</strong>：缓存自定义字段，后续请求用索引代替。</li>
<li><strong>Huffman 编码</strong>：压缩字段值。</li>
</ul>
</li>
<li><strong>效果</strong>：头部大小减少 85-90%。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-服务器推送（Server-Push）"><strong>4. 服务器推送（Server Push）</strong></h3>
<ul>
<li><strong>问题</strong>：HTTP/1.1 需客户端解析 HTML 后才发现依赖资源（如 CSS/JS），导致多次 RTT。</li>
<li><strong>改进</strong>：
<ul>
<li>服务器可主动推送关联资源（如 <code>PUSH_PROMISE</code> 帧推送 CSS）。</li>
<li>客户端可通过 <code>RST_STREAM</code> 拒绝冗余推送。</li>
</ul>
</li>
<li><strong>优化建议</strong>：
<ul>
<li>推送关键资源（如首屏 CSS），体积控制在 50KB 以内。<br>
​HTTP/2 中的 Stream（流）概念详解<br>
HTTP/2 的核心改进之一是引入了 ​Stream（流）​ 机制，它彻底改变了 HTTP/1.1 的串行请求-响应模型，实现了真正的多路复用（Multiplexing）。以下是 Stream 的核心特性和工作原理：<br>
​1. Stream 的定义<br>
​Stream 是 HTTP/2 连接中的虚拟双向通道，用于承载独立的请求和响应。<br>
每个 Stream 由唯一的 ​Stream ID 标识（31 位无符号整数），客户端发起的 Stream ID 为奇数，服务器发起的为偶数。<br>
​帧（Frame）是 Stream 的最小传输单位，例如：<br>
HEADERS 帧：传输 HTTP 头部。<br>
DATA 帧：传输实际数据（如 HTML、图片）。<br>
PRIORITY 帧：设置优先级。<br>
​2. Stream 的核心特性<br>
​**(1) 多路复用（Multiplexing）​**<br>
​单 TCP 连接支持多个并发 Stream：<br>
在 HTTP/1.1 中，浏览器需要建立多个 TCP 连接（通常 6-8 个）以实现并发，而 HTTP/2 只需 ​1 个 TCP 连接即可并行处理数百个 Stream。<br>
​示例：客户端可以同时发送 Stream 1（请求 HTML）和 Stream 3（请求 JS），服务器可以交错返回它们的帧（如 A1 -&gt; B1 -&gt; A2 -&gt; B2）。<br>
​**(2) 帧的乱序与有序**<br>
​不同 Stream 的帧可以乱序发送：<br>
接收方通过 Stream ID 重新组装帧，因此不同 Stream 的帧可以交替传输（如 A1 -&gt; B1 -&gt; A2 -&gt; B2）。<br>
​同一 Stream 的帧必须有序：<br>
例如，Stream 1 的 HEADERS 帧必须排在 DATA 帧之前，否则会导致解析错误。</li>
</ul>
</li>
</ul>
<p>​## MySQL为什么选择B+树？<br>
​更少的磁盘I/O<br>
B+树的非叶子节点仅存储索引，使得单节点可存储更多键值，​降低树高，减少查询时的磁盘访问次数。<br>
​稳定的查询性能<br>
所有查询均需访问叶子节点，时间复杂度恒为O(log n)，避免B树因数据位置不同导致的性能波动。<br>
​高效的范围查询<br>
叶子节点的链表结构使范围查询只需定位起始点后顺序遍历，无需回溯。<br>
​更适合磁盘存储<br>
B+树的节点大小通常设计为磁盘块（如16KB），​充分利用预读特性，减少随机I/O。<br>
​支持覆盖索引<br>
二级索引的叶子节点直接存储主键值，避免回表（如查询字段全在索引中时</p>
<h2 id="JMM-happens-before">JMM happens-before</h2>
<p>Happens-Before 原则是 JMM 中定义的操作间的顺序规则，确保操作的有序性和可见性。具体包括以下八个规则：</p>
<p>程序次序规则：一个线程中的每个操作，按照程序代码的顺序发生。<br>
监视器锁规则：一个解锁操作发生在同一个锁的随后的加锁操作之前。<br>
volatile 变量规则：对一个 volatile 变量的写操作发生在对该变量的随后的读操作之前。<br>
线程启动规则：在一个线程中对另一个线程的 Thread.start() 调用发生在这个新线程的每一个操作之前。<br>
线程终止规则：一个线程中的所有操作都发生在另一个线程检测到这个线程已经终止（通过 Thread.join() 返回）之前。<br>
线程中断规则：对线程的中断操作（Thread.interrupt()）发生在被中断线程检测到中断事件（通过 Thread.interrupted() 或 Thread.isInterrupted()）之前。<br>
对象终结规则：一个对象的构造函数执行结束发生在这个对象的 finalize() 方法之前。<br>
传递性：如果操作 A Happens-Before 操作 B，操作 B Happens-Before 操作 C，那么操作 A Happens-Before 操作 C。</p>
<h2 id="秒杀">秒杀</h2>
<p>瞬时流量的承接<br>
​问题：秒杀开始瞬间可能产生百万级QPS，需避免系统崩溃。<br>
​解决方案：<br>
​分层过滤：<br>
​前端限流：按钮置灰+动态URL防刷。<br>
​CDN缓存静态页面，减少后端请求。<br>
​Nginx限流：令牌桶算法限制每秒请求数（如limit_req模块）。<br>
​异步削峰：请求先入消息队列（如Kafka/RabbitMQ），后端异步处理订单。<br>
​独立部署：秒杀服务与主业务隔离，避免资源竞争。<br>
​2. 防止超卖<br>
​问题：高并发下库存扣减可能超量。<br>
​解决方案：<br>
​预扣库存：Redis原子操作（DECR）预减库存，避免直接访问DB。<br>
​分布式锁：Redis的SETNX或Redisson锁保证扣库存原子性。<br>
​乐观锁：SQL条件控制（如UPDATE stock SET count=count-1 WHERE count&gt;=1）。<br>
​最终一致性：MQ异步同步库存至数据库。<br>
​3. 预防黑产<br>
​问题：机器脚本刷单、僵尸账号占库存。<br>
​解决方案：<br>
​验证码：图形/滑块验证码拦截脚本请求。<br>
​行为分析：检测异常点击频率、鼠标轨迹。<br>
​设备指纹：记录IP、设备ID限制重复请求。<br>
​账号分级：限制低等级账号参与或设置购买上限。<br>
​4. 避免对正常服务的影响<br>
​问题：秒杀流量挤占常规业务资源。<br>
​解决方案：<br>
​服务隔离：秒杀使用独立集群、DB分库。<br>
​熔断降级：非核心功能（如推荐服务）自动关闭（Hystrix/Sentinel）。<br>
​动态扩容：云服务器弹性伸缩应对峰值。<br>
​5. 兜底方案<br>
​问题：极端情况下系统容灾。<br>
​解决方案：<br>
​降级策略：静态页展示“活动火爆”提示，或排队页面。<br>
​数据回滚：超卖时通过事务日志补偿库存。<br>
​多活部署：跨机房容灾，故障自动切换。</p>
<h2 id="RabbitMQ-和-Kafka">RabbitMQ 和 Kafka</h2>
<p>核心架构差异<br>
​RabbitMQ</p>
<p>​代理模式：基于AMQP协议，采用智能代理（Broker）架构，由Exchange、Queue、Binding组成，支持复杂路由规则（如Direct、Fanout、Topic）。<br>
​推送模型：消息由Broker主动推送给消费者，适合低延迟场景。<br>
​垂直扩展：通过增加单节点资源提升性能，适合中小规模系统。<br>
​Kafka</p>
<p>​流平台：基于分区日志的分布式设计，消息按顺序追加到分区，支持高吞吐和水平扩展。<br>
​拉取模型：消费者主动从分区拉取消息，牺牲延迟换取高吞吐。<br>
​持久化：消息默认保留多天，支持回溯和批量处理。</p>
<p>关键功能对比<br>
​对比项	​RabbitMQ	​Kafka<br>
​消息顺序	单队列严格有序（FIFO）	单分区有序，全局无序<br>
​吞吐量	万级QPS（依赖ACK机制）	百万级QPS，适合大数据流<br>
​消息可靠性	支持ACK、重试、死信队列	无内置重试，需自行实现<br>
​消息留存	消费后默认删除	长期留存，支持回溯<br>
​路由灵活性	支持多协议（AMQP/MQTT等）和复杂路由	仅Topic分区，路由简单<br>
​延迟	毫秒级（推送模型）	较高（拉取模型）<br>
​3. 适用场景<br>
​优先选择RabbitMQ的情况<br>
​企业级应用：需要严格消息顺序、复杂路由（如金融交易）。<br>
​低延迟任务：如实时通知、任务队列。<br>
​灵活错误处理：内置ACK和重试机制，适合容错要求高的场景。<br>
​优先选择Kafka的情况<br>
​大数据流处理：如日志聚合、实时分析（如用户行为跟踪）。<br>
​高吞吐场景：如电商秒杀、IoT设备数据。<br>
​事件溯源：需长期存储和回溯消息（如审计日志）</p>
<h1>RabbitMQ vs Kafka 在你的项目中的适用性分析</h1>
<p>你的Tomato-Mall电商项目目前选择了RabbitMQ作为消息队列解决方案，这是一个合适的选择。以下是详细分析为什么RabbitMQ比Kafka更适合你的项目：</p>
<h2 id="1-消息处理模式">1. 消息处理模式</h2>
<p><strong>RabbitMQ更适合你的场景</strong>：</p>
<ul>
<li>你的项目主要处理<strong>业务事件</strong>（订单超时、支付结果）而非数据流</li>
<li>需要<strong>即时处理</strong>消息（如订单超时后立即释放库存）</li>
<li>消息消费后通常不需要长期保留</li>
</ul>
<p><strong>Kafka的不足</strong>：</p>
<ul>
<li>Kafka设计用于<strong>高吞吐量数据流</strong>处理，消息会持久化较长时间</li>
<li>对于你的即时业务处理场景显得&quot;过重&quot;</li>
</ul>
<h2 id="2-消息传递语义">2. 消息传递语义</h2>
<p><strong>RabbitMQ优势</strong>：</p>
<ul>
<li>提供了你需要的<strong>精确一次投递</strong>语义（通过ACK机制）</li>
<li>支持<strong>死信队列</strong>（已在你的订单超时处理中使用）</li>
<li>内置<strong>消息优先级</strong>（虽然你的项目目前未使用）</li>
</ul>
<p><strong>Kafka的局限</strong>：</p>
<ul>
<li>默认是&quot;至少一次&quot;语义，实现精确一次较复杂</li>
<li>没有原生的死信队列概念</li>
</ul>
<h2 id="3-延迟消息处理">3. 延迟消息处理</h2>
<p><strong>RabbitMQ的优势</strong>：</p>
<ul>
<li>你的项目使用RabbitMQ的<strong>延迟队列插件</strong>处理订单超时</li>
<li>配置简单直观（如你的<code>orderDelayQueue</code>）</li>
</ul>
<p><strong>Kafka的不足</strong>：</p>
<ul>
<li>没有内置延迟消息支持</li>
<li>需要自行实现时间轮等复杂机制</li>
</ul>
<h2 id="4-消息量级和吞吐">4. 消息量级和吞吐</h2>
<p><strong>你的项目特点</strong>：</p>
<ul>
<li>电商系统消息量中等（订单、支付相关）</li>
<li>不需要极高吞吐（每天万级消息已足够）</li>
<li>消息大小较小（主要是订单ID、状态等）</li>
</ul>
<p><strong>RabbitMQ足够应对</strong>：</p>
<ul>
<li>单节点可支持数万TPS</li>
<li>消息体积小，不会成为瓶颈</li>
</ul>
<p><strong>Kafka的优势无法发挥</strong>：</p>
<ul>
<li>Kafka的百万级TPS优势在你的场景中不需要</li>
<li>会增加不必要的复杂性</li>
</ul>
<h2 id="5-运维复杂度">5. 运维复杂度</h2>
<p><strong>RabbitMQ更简单</strong>：</p>
<ul>
<li>你的配置已经展示了简单易用的特点</li>
<li>轻量级，适合中小型项目</li>
<li>社区支持好，问题容易解决</li>
</ul>
<p><strong>Kafka更复杂</strong>：</p>
<ul>
<li>需要Zookeeper协调</li>
<li>配置调优复杂</li>
<li>资源消耗更大</li>
</ul>
<p>Spring @Transactional 事务传播行为详解<br>
@Transactional 的事务传播行为(Propagation Behavior)定义了多个事务方法相互调用时，事务应该如何传播。这是 Spring 事务管理的核心特性之一，理解它对设计复杂业务逻辑至关重要。</p>
<p>传播行为类型<br>
Spring 提供了 7 种传播行为，通过 Propagation 枚举定义：</p>
<ol>
<li>REQUIRED（默认）<br>
​行为：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务<br>
​适用场景：大多数业务方法的默认选择<br>
​示例：<br>
@Transactional(propagation = Propagation.REQUIRED)<br>
public void methodA() {<br>
// 如果调用方有事务，则加入；否则新建事务<br>
methodB();<br>
}</li>
</ol>
<p>@Transactional(propagation = Propagation.REQUIRED)<br>
public void methodB() {<br>
// 加入methodA的事务<br>
}<br>
2. SUPPORTS<br>
​行为：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行<br>
​适用场景：查询方法，可以适应调用方的事务需求<br>
​示例：<br>
@Transactional(propagation = Propagation.SUPPORTS)<br>
public void queryData() {<br>
// 如果调用方有事务，则加入；否则无事务执行<br>
}<br>
3. MANDATORY<br>
​行为：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常<br>
​适用场景：强制要求必须在事务中执行的方法<br>
​示例：<br>
@Transactional(propagation = Propagation.MANDATORY)<br>
public void mandatoryOperation() {<br>
// 必须在事务中调用，否则抛出IllegalTransactionStateException<br>
}<br>
4. REQUIRES_NEW<br>
​行为：创建一个新事务，如果当前存在事务，则挂起当前事务<br>
​适用场景：需要独立事务执行的方法，不受外层事务影响<br>
​示例：<br>
@Transactional(propagation = Propagation.REQUIRES_NEW)<br>
public void logOperation() {<br>
// 总是新建事务，外层事务回滚不影响此方法<br>
}<br>
5. NOT_SUPPORTED<br>
​行为：以非事务方式执行操作，如果当前存在事务，则挂起该事务<br>
​适用场景：不需要事务支持的方法，如某些日志记录<br>
​示例：<br>
@Transactional(propagation = Propagation.NOT_SUPPORTED)<br>
public void nonTransactionalMethod() {<br>
// 无事务执行，即使调用方有事务也会被挂起<br>
}<br>
6. NEVER<br>
​行为：以非事务方式执行，如果当前存在事务，则抛出异常<br>
​适用场景：严格要求不能在事务中执行的方法<br>
​示例：<br>
@Transactional(propagation = Propagation.NEVER)<br>
public void mustNotInTransaction() {<br>
// 如果调用方有事务，则抛出异常<br>
}<br>
7. NESTED<br>
​行为：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则创建一个新事务<br>
​适用场景：需要部分回滚的复杂业务场景<br>
​示例：<br>
@Transactional(propagation = Propagation.NESTED)<br>
public void nestedOperation() {<br>
// 在外层事务中创建保存点(SAVEPOINT)<br>
// 可以独立回滚而不影响外层事务<br>
}<br>
传播行为对比表<br>
传播行为	当前存在事务	当前无事务<br>
REQUIRED	加入当前事务	创建新事务<br>
SUPPORTS	加入当前事务	非事务执行<br>
MANDATORY	加入当前事务	抛出异常<br>
REQUIRES_NEW	挂起当前事务，创建新事务	创建新事务<br>
NOT_SUPPORTED	挂起当前事务，非事务执行	非事务执行<br>
NEVER	抛出异常	非事务执行</p>
<h2 id="gapLock-nextKeyLock时机">gapLock nextKeyLock时机</h2>
<p>可重复读（Repeatable Read）隔离级别下间隙锁（Gap Lock）和 Next - Key Lock 的使用时机</p>
<ol>
<li>范围查询时 使用邻键锁 ：<br>
当在可重复读隔离级别下， 执行带有范围条件的查询语句时：如<br>
SELECT… FROM table WHERE column BETWEEN value1 AND value2 FOR UPDATE<br>
或<br>
SELECT… FROM table WHERE column &gt; value1 AND column &lt; value2 FOR UPDATE<br>
会使用间隙锁和 Next - Key Lock。<br>
例如，在一个按年龄字段索引的用户表中，执行<br>
SELECT * FROM users WHERE age BETWEEN 20 AND 30 FOR UPDATE，<br>
如果表中存在年龄为 20、25、30 的用户记录，那么会锁定年龄在 (20, 25]、(25, 30] 以及 20 和 30 对应的记录行，防止其他事务在这个年龄范围内插入新记录，避免幻读问题。</li>
<li>插入操作引发时 使用邻键锁 ：<br>
如果在一个事务中，先进行范围查询，然后准备插入一条新记录，而这条新记录的值处于之前查询的范围区间内，也会触发间隙锁和 Next - Key Lock。<br>
假设事务 A 先执行SELECT * FROM products WHERE price &gt; 100 AND price &lt; 200 FOR UPDATE，之后事务 A 准备插入一条price为 150 的新商品记录，此时会锁定 (100, 200) 这个区间，防止其他事务在该区间插入数据，确保事务 A 再次查询该范围时，数据的一致性。</li>
<li>唯一索引冲突检测时 使用邻键锁 ：<br>
当插入或更新数据时，如果涉及到唯一索引，并且在可重复读隔离级别下，为了防止其他事务在同一时刻插入相同唯一值的数据，会使用 Next - Key Lock。<br>
例如，在一个用户表中，email字段设置为唯一索引，当一个事务执行下面的sql ，<br>
INSERT INTO users (name, email) VALUES (‘张三’, ‘zhangsan@example.com’)<br>
会锁定email索引上对应值的 Next - Key 范围，确保在事务完成前，其他事务不能插入相同email的记录，保证唯一索引的约束性和数据一致性。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:27:03" itemprop="dateCreated datePublished" datetime="2025-06-23T12:27:03+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>0519</h1>
<h2 id="幻读和GapLock">幻读和GapLock</h2>
<p>先后两次执行相同的范围查询，却“前后结果不一样”：第二次多了（或少了）一些行——这些新出现（或消失）的行就称为“phantom rows”，现象称为幻读。</p>
<p>例子（隔离级别：READ COMMITTED）</p>
<ol>
<li>事务 A：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>;  </span><br><span class="line">   <span class="comment">-- 假设此时返回 5 行</span></span><br><span class="line">   ```  </span><br><span class="line"><span class="number">2.</span> 同时，事务 B 插入了一条满足 amount <span class="operator">&gt;</span> <span class="number">100</span> 的新记录，并提交。  </span><br><span class="line"><span class="number">3.</span> 事务 A 再次执行同样的查询：  </span><br><span class="line">   ```<span class="keyword">sql</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line">   ```  </span><br><span class="line">   这次会看到 <span class="number">6</span> 行，多出来的那行就是“幻读”——之前不存在、现在却出现了。</span><br><span class="line"></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">Gap Lock（间隙锁） <span class="operator">&amp;</span> Next<span class="operator">-</span>Key Lock  </span><br><span class="line">InnoDB 在可重复读（REPEATABLE READ）及以上隔离级别下，对以下操作（<span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span><span class="operator">/</span><span class="keyword">SELECT</span> … <span class="keyword">FOR</span> <span class="keyword">UPDATE</span><span class="operator">/</span>LOCK <span class="keyword">IN</span> SHARE MODE）会使用 <span class="operator">*</span><span class="operator">*</span>Next<span class="operator">-</span>Key Lock<span class="operator">*</span><span class="operator">*</span>，本质上是：</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> Record Lock：锁住已有索引键值对应的记录  </span><br><span class="line"><span class="operator">-</span> Gap Lock：锁住两个相邻索引值之间的“间隙”（不含边界的记录本身）  </span><br><span class="line"></span><br><span class="line">这样，对一个范围 `a <span class="operator">&lt;</span> col ≤ b`，InnoDB 会在 `a` 和 `b` 之间，以及它们各自的左右相邻记录之间，全部加上 Gap Lock。  </span><br><span class="line"></span><br><span class="line">为什么 Gap Lock 能防止幻读？  </span><br><span class="line"><span class="operator">-</span> 事务 A 首次读到某个范围后，对该范围施加了 Gap Lock。  </span><br><span class="line"><span class="operator">-</span> 这样，事务 B 就 <span class="operator">*</span><span class="operator">*</span>无法<span class="operator">*</span><span class="operator">*</span> 在这个范围内插入任何新行（因为插入要占用某个间隙，而该间隙已被锁定）。  </span><br><span class="line"><span class="operator">-</span> 所以，即使事务 B 提交，事务 A 再次查询时，也不会看到“新幻影”——范围内的行集保持不变。</span><br><span class="line"></span><br><span class="line">简而言之，Gap Lock 在索引的“空白”上也加锁，阻止并发事务往原先读取过的范围插入新记录，从而杜绝幻读。</span><br><span class="line"></span><br><span class="line">“(<span class="operator">*</span>) 通过间隙锁可避免幻读，但需显式加锁”</span><br><span class="line">核心点：InnoDB 在默认的可重复读隔离级别下，可以通过加间隙锁（Gap Lock） 来避免幻读。</span><br><span class="line">但：如果没有显式地在事务中加锁（比如没有用 <span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> 或 LOCK <span class="keyword">IN</span> SHARE MODE），那么幻读仍然可能发生。</span><br><span class="line"></span><br><span class="line">## Redis原子化操作的底层原理？</span><br><span class="line">Lua 脚本 (EVAL)</span><br><span class="line"></span><br><span class="line">将多条命令写在一个 Lua 脚本里，提交给 Redis 后，服务器会在脚本执行期间 完全阻塞 事件循环。</span><br><span class="line">脚本内所有调用 redis.call(...) 的命令都在同一个上下文里连贯执行，中途不会被打断。</span><br><span class="line">这样就保证了跨命令的复杂逻辑也能做到“要么全做完要么不做”。</span><br><span class="line"></span><br><span class="line">## RedLock</span><br><span class="line">### <span class="number">1.</span> 证明RedLock的正确性  </span><br><span class="line">RedLock的正确性基于以下设计原则和反驳争议的论点：  </span><br><span class="line"></span><br><span class="line">#### <span class="operator">*</span><span class="operator">*</span>核心保证机制<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>多数派原则<span class="operator">*</span><span class="operator">*</span>：客户端需在过半（如<span class="number">5</span>个实例中的<span class="number">3</span>个）Redis实例上成功获取锁，确保即使部分节点故障，锁仍有效。  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>时钟误差容忍<span class="operator">*</span><span class="operator">*</span>：Redis作者Antirez指出，RedLock仅需时钟大体一致（允许微小误差），通过运维避免大幅时钟跳跃即可满足要求。  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>锁持有时间校验<span class="operator">*</span><span class="operator">*</span>：客户端在获取锁后计算实际耗时（T2<span class="operator">-</span>T1），若超过锁的过期时间则主动放弃锁，避免因网络延迟或GC导致锁冲突。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">### <span class="number">2.</span> 设置唯一标识（UUID）和过期时间的原因  </span><br><span class="line">#### <span class="operator">*</span><span class="operator">*</span>唯一标识（UUID）的作用<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>防误删锁<span class="operator">*</span><span class="operator">*</span>：释放锁时需验证UUID，确保只有锁的持有者能删除锁，避免其他客户端误删。  </span><br><span class="line">  <span class="operator">-</span> <span class="operator">*</span>示例<span class="operator">*</span>：客户端A持有锁后因GC暂停，锁过期被客户端B获取。若A恢复后尝试释放锁，因UUID不匹配，无法删除B的锁。  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>避免锁冲突<span class="operator">*</span><span class="operator">*</span>：唯一标识确保锁的全局唯一性，防止不同客户端的锁请求混淆。  </span><br><span class="line"></span><br><span class="line">#### <span class="operator">*</span><span class="operator">*</span>过期时间（TTL）的作用<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>防止死锁<span class="operator">*</span><span class="operator">*</span>：若客户端崩溃未主动释放锁，过期时间确保锁自动释放，避免资源永久阻塞。  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>活性保证<span class="operator">*</span><span class="operator">*</span>：限制锁的最大持有时间，确保其他客户端在超时后有机会获取锁。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Spring AOP及代理模式的实现？</span><br><span class="line">代理模式在Spring AOP中的实现</span><br><span class="line">​</span><br><span class="line">###（<span class="number">1</span>）JDK动态代理</span><br><span class="line"></span><br><span class="line">​适用条件：目标对象实现了至少一个接口。</span><br><span class="line">​原理：基于Java反射机制，通过Proxy.newProxyInstance()生成代理对象，代理类实现与目标对象相同的接口。</span><br><span class="line"></span><br><span class="line">## <span class="number">1.</span> 核心概念</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>Proxy 类<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line">  `java.lang.reflect.Proxy`，Java 自带的动态代理入口，负责在运行时生成代理类字节码，并加载到 JVM。</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>InvocationHandler 接口<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line">  代理实例方法调用时的“调度中心”，所有对代理实例的方法调用，都会被转给它的 `invoke(...)` 方法去处理。</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>目标对象（target）<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line">  真正要被增强的对象，必须实现了一个或多个接口。</span><br><span class="line"></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">## <span class="number">2.</span> 代码回顾</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class JdkProxyHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public Object createProxy(Object target) &#123;</span><br><span class="line">        this.target <span class="operator">=</span> target;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span> 生成并返回代理对象</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            this</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            this</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public Object invoke(Object proxy, <span class="keyword">Method</span> <span class="keyword">method</span>, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;前置通知&quot;);</span><br><span class="line">        Object <span class="keyword">result</span> <span class="operator">=</span> method.invoke(target, args);  <span class="operator">/</span><span class="operator">/</span> 调用真实对象方法</span><br><span class="line">        System.out.println(&quot;后置通知&quot;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p><code>createProxy(...)</code>：<br>
调用 <code>Proxy.newProxyInstance</code>，传入</p>
<ol>
<li>类加载器（和目标类一致）</li>
<li>接口列表（目标对象实现的接口）</li>
<li>当前 InvocationHandler 实例（把增强逻辑写在 <code>invoke</code> 里）</li>
</ol>
</li>
<li>
<p><code>invoke(...)</code>：<br>
真正发生“代理增强”的地方：前置处理 → 反射调用真实方法 → 后置处理。<br>
JDK 动态代理的限制：<br>
只能代理接口，无法直接给普通类（没有接口）生成代理。<br>
如果目标类没有任何接口，通常用 CGLIB、ByteBuddy 等库，它们是基于生成子类字节码来做代理。</p>
</li>
</ul>
<h3 id="CGLIB代理">CGLIB代理</h3>
<p>CGLIB通过ASM字节码操作框架在运行时动态生成目标类的子类，并在子类中重写非final方法。代理类通过方法拦截器（MethodInterceptor）​将方法调用委托给用户定义的增强逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(targetClass);</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键步骤</p>
<ol>
<li>
<p><strong>生成代理类</strong>：</p>
<ul>
<li>使用<code>Enhancer</code>类指定目标类（父类），生成其子类字节码。</li>
<li>子类会继承目标类的所有非<code>final</code>方法，并重写这些方法以插入拦截逻辑。</li>
</ul>
</li>
<li>
<p><strong>方法拦截</strong>：</p>
<ul>
<li>代理类重写的方法会调用<code>MethodInterceptor.intercept()</code>，该方法接收四个参数：
<ul>
<li><code>obj</code>：代理对象。</li>
<li><code>method</code>：目标方法。</li>
<li><code>args</code>：方法参数。</li>
<li><code>proxy</code>：方法代理（用于调用父类原始方法）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="与JDK动态代理的对比"><strong>与JDK动态代理的对比</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CGLIB代理</strong></th>
<th><strong>JDK动态代理</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>代理方式</strong></td>
<td>继承目标类，生成子类</td>
<td>实现目标接口，生成接口实现类</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>更高（直接调用父类方法，无反射开销）</td>
<td>较低（反射调用接口方法）</td>
</tr>
<tr>
<td><strong>限制</strong></td>
<td>无法代理<code>final</code>类或方法</td>
<td>只能代理实现了接口的类</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>Spring AOP（无接口时默认使用）</td>
<td>微服务接口代理</td>
</tr>
</tbody>
</table>
<h3 id="Spring中的应用？">Spring中的应用？</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>     <span class="comment">// 表示这是一个切面类</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">// 让Spring能自动扫描并管理这个Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 定义切入点：匹配com.example.service包下所有类的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">txPoint</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在切入点方法执行前执行</span></span><br><span class="line">    <span class="meta">@Before(&quot;txPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;开启事务&quot;</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在切入点方法正常返回后执行</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;txPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;提交事务&quot;</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在切入点方法抛出异常时执行</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;txPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;回滚事务&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和一个业务 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String user)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>启动时扫描到 <code>TxAspect</code>，生成一个 <code>DefaultPointcutAdvisor</code>，其中封装了 <code>AspectJMethodBeforeAdvice</code>、<code>AspectJAfterReturningAdvice</code>、<code>AspectJAfterThrowingAdvice</code>。</li>
<li><code>AnnotationAwareAspectJAutoProxyCreator</code> 在 <code>postProcessAfterInitialization(userServiceImpl, &quot;userService&quot;)</code> 时：
<ul>
<li>发现该 Bean 类匹配切点 → 创建 <code>ProxyFactory</code> → 组装所有 AdviceChain → 调用 <code>getProxy()</code>。</li>
</ul>
</li>
<li>对外暴露的 <code>userService</code> 实际是一个代理。</li>
<li>当客户端调用 <code>userService.register(&quot;zhang&quot;)</code> 时：
<ul>
<li>代理的 <code>invoke()</code>（或 <code>intercept()</code>）被触发 → 构建 <code>MethodInvocation</code> 链 → 执行：
<ol>
<li><code>AspectJMethodBeforeAdvice</code>（开启事务）</li>
<li>目标方法 <code>register</code></li>
<li><code>AspectJAfterReturningAdvice</code>（提交事务）</li>
<li>如果抛异常，则执行 <code>AspectJAfterThrowingAdvice</code>（回滚事务）</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1>0522</h1>
<h2 id="Java中static和final关键字的联系与区别">Java中static和final关键字的联系与区别</h2>
<h3 id="核心区别">核心区别</h3>
<p><code>static</code>和<code>final</code>是Java中两个独立但经常结合使用的关键字，它们的主要区别在于：</p>
<ul>
<li><code>static</code>表示&quot;静态的&quot;，强调<strong>属于类而非对象</strong>，所有实例共享同一份拷贝</li>
<li><code>final</code>表示&quot;最终的&quot;，强调<strong>不可修改</strong>，变量值不能改、方法不能重写、类不能继承</li>
</ul>
<h3 id="1-修饰变量时的区别">1. 修饰变量时的区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>static变量</th>
<th>final变量</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>访问方式</strong></td>
<td>可通过类名直接访问</td>
<td>需通过对象实例访问(除非也是static)</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全(需同步)</td>
<td>线程安全(不可变)</td>
</tr>
<tr>
<td><strong>初始化时机</strong></td>
<td>类加载时初始化</td>
<td>声明时或构造函数中初始化</td>
</tr>
<tr>
<td><strong>共享性</strong></td>
<td>所有实例共享同一份</td>
<td>每个实例可以有自己的final变量</td>
</tr>
<tr>
<td><strong>存储位置</strong></td>
<td>方法区的静态区域</td>
<td>基本类型在栈，引用类型在堆</td>
</tr>
<tr>
<td><strong>修改性</strong></td>
<td>可以修改</td>
<td>初始化后不能修改</td>
</tr>
</tbody>
</table>
<h3 id="2-修饰方法时的区别">2. 修饰方法时的区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>static方法</th>
<th>final方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>调用方式</strong></td>
<td>通过类名调用</td>
<td>通过对象实例调用</td>
</tr>
<tr>
<td><strong>重写性</strong></td>
<td>可被继承但不能重写(隐藏)</td>
<td>不能被子类重写</td>
</tr>
<tr>
<td><strong>访问限制</strong></td>
<td>只能访问静态成员</td>
<td>可以访问所有成员</td>
</tr>
<tr>
<td><strong>多态性</strong></td>
<td>不支持多态(静态绑定)</td>
<td>支持多态(除非private)</td>
</tr>
</tbody>
</table>
<h3 id="3-修饰类时的区别">3. 修饰类时的区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>static类(仅内部类)</th>
<th>final类</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义范围</strong></td>
<td>只能是内部类</td>
<td>可以是任何类</td>
</tr>
<tr>
<td><strong>继承性</strong></td>
<td>可以继承其他类</td>
<td>不能被继承</td>
</tr>
<tr>
<td><strong>实例化</strong></td>
<td>不依赖外部类实例</td>
<td>可以正常实例化</td>
</tr>
<tr>
<td><strong>方法默认修饰</strong></td>
<td>方法不默认final</td>
<td>所有方法隐式final</td>
</tr>
</tbody>
</table>
<h2 id="JVM动态绑定">JVM动态绑定</h2>
<p>JVM使用虚方法表(vtable)实现动态绑定：</p>
<p>每个类都有一个虚方法表，包含该类所有可重写方法的入口地址</p>
<p>子类继承父类的虚方法表，然后替换重写方法的入口地址</p>
<p>调用方法时，JVM根据对象的实际类查找虚方法表，找到正确的方法实现</p>
<h2 id="read-commit-vs-serializable">read commit vs serializable</h2>
<h3 id="关键区别总结"><strong>关键区别总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Read Committed</strong></th>
<th><strong>Serializable</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁范围</strong></td>
<td>仅锁定现有行和部分间隙</td>
<td>锁定所有可能影响的间隙（Next-Key Lock）</td>
</tr>
<tr>
<td><strong>锁释放时机</strong></td>
<td>行锁在读取后立即释放</td>
<td>锁持续到事务结束</td>
</tr>
<tr>
<td><strong>索引依赖</strong></td>
<td>未覆盖的索引间隙可能导致幻读</td>
<td>所有索引范围被锁定</td>
</tr>
<tr>
<td><strong>并发性能</strong></td>
<td>高</td>
<td>低（锁冲突多）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="实现细节（以-MySQL-InnoDB-为例）"><strong>实现细节（以 MySQL InnoDB 为例）</strong></h3>
<ul>
<li>
<p><strong>Read Committed</strong>：</p>
<ul>
<li>仅对访问到的行加行锁，间隙锁仅在唯一索引唯一性检查时使用。</li>
<li>允许其他事务在未锁定的间隙插入数据。</li>
</ul>
</li>
<li>
<p><strong>Serializable</strong>：</p>
<ul>
<li>所有读取操作自动转换为 <code>SELECT ... FOR SHARE</code>，对查询涉及的索引范围加 Next-Key Lock。</li>
<li>完全禁止其他事务在锁定范围内插入或删除。</li>
</ul>
</li>
</ul>
<h2 id="HashMap">HashMap</h2>
<hr>
<h2 id="1-HashMap-的基本工作原理">1. HashMap 的基本工作原理</h2>
<p>HashMap 底层是一个 Node&lt;K,V&gt;[] 数组（JDK 1.7 叫 Entry[]），每个元素要么为 null，要么是一个链表／红黑树的头节点。</p>
<ul>
<li>
<p><strong>put(K key, V value)</strong></p>
<ol>
<li>计算 hash = hash(key)；</li>
<li>如果 table 未初始化，则调用 resize() 初始化（默认容量 16）；</li>
<li>根据 index = (table.length–1) &amp; hash 定位桶位置；</li>
<li>若 table[index] 为 null，直接创建 new Node(key, value) 放入；</li>
<li>否则遍历链表／树：
<ul>
<li>找到相同 key，则覆盖 value；</li>
<li>否则插入新节点（JDK 1.7 链表头插，JDK 1.8 链表尾插并可能触发“树化”）；</li>
</ul>
</li>
<li>插入后若 size &gt; threshold(=capacity×loadFactor)，则触发 resize() 扩容。</li>
</ol>
</li>
<li>
<p><strong>get(Object key)</strong></p>
<ol>
<li>计算 hash 和 index；</li>
<li>遍历 table[index] 上的链表／树，按 key.equals() 找到即返回 value，否则返回 null。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">  Node&lt;K,V&gt; e = table[(n-<span class="number">1</span>) &amp; hash];</span><br><span class="line">  <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.hash==hash &amp;&amp; Objects.equals(e.key, key))</span><br><span class="line">      <span class="keyword">return</span> e.value;</span><br><span class="line">    e = e.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="concurrentHashMap">concurrentHashMap</h3>
<h4 id="JDK-1-8-实现（CAS-synchronized-链表-树化）">JDK 1.8 实现（CAS + synchronized + 链表/树化）</h4>
<ul>
<li>去掉 Segment，底层直接是 <code>Node&lt;K,V&gt;[] table</code>；</li>
<li><strong>初始化 table</strong>：采用 CAS 保证只有一个线程完成第一次初始化；</li>
<li><strong>put 操作</strong>：
<ol>
<li>CAS 尝试将新节点放入空桶；</li>
<li>若 CAS 失败（已有节点或并发竞争），对该桶头节点加 <code>synchronized(bin)</code> 锁，安全地在链表尾部插入或在必要时树化；</li>
<li>解锁后，如需扩容，则发起一次 “单线程” 扩容（转移节点时用 CAS 标记前驱为 forwardingNode，其它线程在访问时可以帮忙迁移）；</li>
</ol>
</li>
<li><strong>get 操作</strong>：
<ul>
<li>全程无锁，只做 volatile 读 + 链表／树遍历。</li>
</ul>
</li>
<li><strong>扩容（resize）</strong>：
<ul>
<li>不再一次性锁整个 table，而是通过 CAS+forwardingNode 让多个线程协作“分段”搬运节点；</li>
</ul>
</li>
<li>优点：更轻量级的并发控制，高并发下性能优；内存开销更小。</li>
</ul>
<h2 id="Bean">Bean</h2>
<p>以下是整理的 Spring Bean 生命周期执行过程的逻辑流程图，按阶段划分并标注关键步骤：</p>
<hr>
<h3 id="Spring-Bean-生命周期完整流程"><strong>Spring Bean 生命周期完整流程</strong></h3>
<h4 id="1-实例化阶段"><strong>1. 实例化阶段</strong></h4>
<ul>
<li><strong>步骤1</strong>：Spring 容器启动，扫描并加载 Bean 定义（BeanDefinition）。</li>
<li><strong>步骤2</strong>：通过反射调用构造方法实例化 Bean（默认使用无参构造，或指定构造器）。</li>
</ul>
<h4 id="2-属性注入阶段"><strong>2. 属性注入阶段</strong></h4>
<ul>
<li><strong>步骤3</strong>：依赖注入（DI），通过 setter 或字段注入完成 Bean 的属性赋值（如 <code>@Autowired</code>、<code>@Value</code>）。</li>
</ul>
<h4 id="3-Aware-接口回调（感知容器信息）"><strong>3. Aware 接口回调（感知容器信息）</strong></h4>
<ul>
<li><strong>步骤4</strong>：若实现 <code>BeanNameAware</code>，调用 <code>setBeanName(String beanId)</code> 传入 Bean 的 ID。</li>
<li><strong>步骤5</strong>：若实现 <code>BeanFactoryAware</code>，调用 <code>setBeanFactory(BeanFactory factory)</code> 传入工厂实例。</li>
<li><strong>步骤6</strong>：若实现 <code>ApplicationContextAware</code>，调用 <code>setApplicationContext(ApplicationContext ctx)</code> 传入应用上下文。</li>
</ul>
<h4 id="4-初始化前阶段（BeanPostProcessor-前置处理）"><strong>4. 初始化前阶段（<code>BeanPostProcessor</code> 前置处理）</strong></h4>
<ul>
<li><strong>步骤7</strong>：若存在 <code>BeanPostProcessor</code>，调用 <code>postProcessBeforeInitialization(Object bean, String beanName)</code>（AOP 代理在此生成）。</li>
</ul>
<h4 id="5-初始化阶段"><strong>5. 初始化阶段</strong></h4>
<ul>
<li><strong>步骤8</strong>：若实现 <code>InitializingBean</code>，调用 <code>afterPropertiesSet()</code> 方法。</li>
<li><strong>步骤9</strong>：若配置了 <code>init-method</code> 或使用 <code>@PostConstruct</code>，调用指定的初始化方法。</li>
</ul>
<h4 id="6-初始化后阶段（BeanPostProcessor-后置处理）"><strong>6. 初始化后阶段（<code>BeanPostProcessor</code> 后置处理）</strong></h4>
<ul>
<li><strong>步骤10</strong>：若存在 <code>BeanPostProcessor</code>，调用 <code>postProcessAfterInitialization(Object bean, String beanName)</code>。此时 Bean 已完全就绪，可被使用。</li>
</ul>
<h4 id="7-使用阶段"><strong>7. 使用阶段</strong></h4>
<ul>
<li><strong>步骤11</strong>：
<ul>
<li><strong>Singleton</strong>：Bean 被放入 Spring IoC 单例缓存池，由容器管理生命周期。</li>
<li><strong>Prototype</strong>：Bean 交给调用方管理，Spring 不再跟踪其生命周期。</li>
</ul>
</li>
</ul>
<h4 id="8-销毁阶段"><strong>8. 销毁阶段</strong></h4>
<ul>
<li><strong>步骤12</strong>：若实现 <code>DisposableBean</code>，调用 <code>destroy()</code> 方法。</li>
<li><strong>步骤13</strong>：若配置了 <code>destroy-method</code> 或使用 <code>@PreDestroy</code>，调用指定的销毁方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87/" class="post-title-link" itemprop="url">项目问题准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:27:03" itemprop="dateCreated datePublished" datetime="2025-06-23T12:27:03+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="索引">索引</h2>
<p>一、索引类型分类</p>
<ol>
<li>普通索引 (Standard Index)<br>
用户表(users)</li>
</ol>
<p>idx_users_username: 普通索引</p>
<p>idx_users_email: 普通索引</p>
<p>idx_users_telephone: 普通索引</p>
<p>商品表(products)</p>
<p>idx_products_title: 普通索引</p>
<p>idx_products_price: 普通索引</p>
<p>idx_products_rate: 普通索引</p>
<p>库存表(stockpiles)</p>
<p>idx_stockpiles_amount: 普通索引</p>
<ol start="2">
<li>外键索引 (Foreign Key Index)<br>
规格表(specifications)</li>
</ol>
<p>idx_specifications_product_id: 外键索引</p>
<p>库存表(stockpiles)</p>
<p>idx_stockpiles_product_id: 外键索引</p>
<p>广告表(advertisements)</p>
<p>idx_product_id: 外键索引</p>
<ol start="3">
<li>复合索引 (Composite Index)<br>
规格表(specifications)</li>
</ol>
<p>idx_specifications_item_value: 复合索引(item, value)</p>
<p>购物车表(carts)</p>
<p>idx_carts_user_product: 复合索引(user_id, product_id)</p>
<ol start="4">
<li>唯一索引 (已存在)<br>
用户表(users)</li>
</ol>
<p>telephone字段已定义为UNIQUE，自动创建唯一索引</p>
<p>二、各类索引的得失分析</p>
<ol>
<li>普通索引<br>
优点:</li>
</ol>
<p>加速WHERE条件查询</p>
<p>提高ORDER BY排序效率</p>
<p>支持覆盖索引查询(当查询只包含索引列时)</p>
<p>缺点:</p>
<p>占用额外存储空间</p>
<p>降低INSERT/UPDATE/DELETE速度(需要维护索引)</p>
<p>可能导致优化器选择不理想的执行计划</p>
<p>适用场景:</p>
<p>高频查询条件字段</p>
<p>需要排序或分组的字段</p>
<p>选择性高的字段(不同值多的字段)</p>
<ol start="2">
<li>外键索引<br>
优点:</li>
</ol>
<p>加速表连接操作</p>
<p>保证参照完整性</p>
<p>优化关联查询性能</p>
<p>缺点:</p>
<p>增加外键约束检查开销</p>
<p>可能影响批量导入性能</p>
<p>级联操作可能带来性能问题</p>
<p>适用场景:</p>
<p>所有外键关系字段都应建立</p>
<p>频繁进行JOIN操作的表</p>
<ol start="3">
<li>复合索引<br>
优点:</li>
</ol>
<p>支持多列组合查询</p>
<p>可以实现索引覆盖</p>
<p>减少单列索引数量</p>
<p>缺点:</p>
<p>列顺序很重要，设计不当会失效</p>
<p>只对最左前缀有效</p>
<p>占用更多空间</p>
<p>适用场景:</p>
<p>经常同时查询多个字段</p>
<p>有固定查询模式的场景</p>
<p>需要覆盖索引优化查询</p>
<h3 id="一、阿里巴巴手册对外键的建议">一、阿里巴巴手册对外键的建议</h3>
<p>阿里巴巴《Java开发手册》确实建议：</p>
<ol>
<li><strong>不要使用数据库外键约束</strong>（FOREIGN KEY constraint）</li>
<li><strong>但需要建立外键索引</strong>（即在外键字段上创建普通索引）</li>
</ol>
<h3 id="原因分析：">原因分析：</h3>
<ol>
<li>
<p><strong>外键约束的缺点</strong>：</p>
<ul>
<li>性能开销：每次DML操作都需要检查外键约束</li>
<li>并发问题：容易引发死锁</li>
<li>扩展困难：分库分表时难以维护外键关系</li>
<li>耦合度高：业务逻辑与数据强耦合</li>
</ul>
</li>
<li>
<p><strong>外键索引的优点</strong>：</p>
<ul>
<li>提高JOIN查询性能</li>
<li>保证查询优化器能选择最优执行计划</li>
<li>不引入约束检查的开销</li>
</ul>
</li>
</ol>
<h3 id="二、外键索引的原理">二、外键索引的原理</h3>
<h3 id="1-基本工作原理">1. 基本工作原理</h3>
<p>外键索引本质上是一个普通的B+树索引，只是它建立在外键字段上，用于：</p>
<ul>
<li>加速表连接操作</li>
<li>优化关联查询</li>
<li>支持嵌套循环连接(Nested Loop Join)算法</li>
</ul>
<h3 id="2-与有约束外键的区别">2. 与有约束外键的区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>有约束的外键</th>
<th>外键索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>分库分表兼容性</td>
<td>难以实现</td>
<td>容易实现</td>
</tr>
<tr>
<td>约束检查</td>
<td>有，保证数据完整性</td>
<td>无</td>
</tr>
<tr>
<td>存储结构</td>
<td>约束+索引</td>
<td>纯索引</td>
</tr>
<tr>
<td>级联操作</td>
<td>支持CASCADE/SET NULL等</td>
<td>不支持</td>
</tr>
<tr>
<td>性能影响</td>
<td>DML操作有额外开销</td>
<td>只有查询优化</td>
</tr>
</tbody>
</table>
<h3 id="3-索引选择算法">3. 索引选择算法</h3>
<p>当执行JOIN查询时，优化器会：</p>
<ol>
<li>检查连接字段是否有索引</li>
<li>评估不同连接算法(Nested Loop, Hash Join, Merge Join)的成本</li>
<li>优先选择有索引的字段作为驱动表</li>
</ol>
<h3 id="三、实际应用建议">三、实际应用建议</h3>
<h3 id="1-应该建立外键索引的情况">1. 应该建立外键索引的情况</h3>
<ul>
<li>所有需要JOIN的关联字段</li>
<li>高频查询的关联条件</li>
<li>OLTP系统中核心业务表的关联字段</li>
</ul>
<h3 id="2-不建议建立的情况">2. 不建议建立的情况</h3>
<ul>
<li>极少参与查询的关联字段</li>
<li>数据量极小(如配置表)的关联</li>
<li>写多读少的场景</li>
</ul>
<h3 id="3-最佳实践示例">3. 最佳实践示例</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不建议（添加外键约束）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> orders <span class="keyword">ADD CONSTRAINT</span> fk_user_id <span class="keyword">FOREIGN KEY</span> (user_id) <span class="keyword">REFERENCES</span> users(user_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建议（只创建外键索引）</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_orders_user_id <span class="keyword">ON</span> orders(user_id);</span><br></pre></td></tr></table></figure>
<h3 id="四、性能影响对比">四、性能影响对比</h3>
<h3 id="1-有外键约束时">1. 有外键约束时</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入订单时需要检查用户是否存在</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> orders(user_id, ...) <span class="keyword">VALUES</span> (<span class="number">100</span>, ...);</span><br><span class="line"><span class="comment">-- 数据库需要执行：</span></span><br><span class="line"><span class="comment">-- 1. 检查users表中是否存在user_id=100的记录</span></span><br><span class="line"><span class="comment">-- 2. 如果不存在则拒绝插入</span></span><br><span class="line"><span class="comment">-- 3. 如果存在则完成插入</span></span><br></pre></td></tr></table></figure>
<h3 id="2-只有外键索引时">2. 只有外键索引时</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入订单时没有约束检查</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> orders(user_id, ...) <span class="keyword">VALUES</span> (<span class="number">100</span>, ...);</span><br><span class="line"><span class="comment">-- 数据库只需：</span></span><br><span class="line"><span class="comment">-- 1. 直接插入数据</span></span><br><span class="line"><span class="comment">-- 2. 更新索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询时仍能高效JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">JOIN</span> users <span class="keyword">ON</span> orders.user_id <span class="operator">=</span> users.user_id;</span><br><span class="line"><span class="comment">-- 可以使用orders.user_id上的索引加速连接</span></span><br></pre></td></tr></table></figure>
<h3 id="五、总结">五、总结</h3>
<ol>
<li><strong>外键索引≠外键约束</strong>：前者是性能优化手段，后者是数据完整性机制</li>
<li><strong>互联网应用推荐做法</strong>：
<ul>
<li>应用层维护数据一致性</li>
<li>数据库层建立外键索引优化查询</li>
<li>避免使用数据库外键约束</li>
</ul>
</li>
<li><strong>索引选择原则</strong>：
<ul>
<li>评估查询模式</li>
<li>监控索引使用情况</li>
<li>定期优化冗余索引</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>算法</th>
<th>有无索引要求</th>
<th>时间复杂度</th>
<th>内存消耗</th>
<th>适用场景</th>
<th>外键索引优势</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Nested Loop</strong></td>
<td>内表连接字段需索引</td>
<td>O(M * log N)</td>
<td>低</td>
<td>中小表连接，驱动表小</td>
<td>大幅降低内表查找成本</td>
</tr>
<tr>
<td><strong>Hash Join</strong></td>
<td>无需索引</td>
<td>O(M + N)</td>
<td>高</td>
<td>大表等值连接，无索引场景</td>
<td>无直接优势</td>
</tr>
<tr>
<td><strong>Merge Join</strong></td>
<td>两表都需有序</td>
<td>O(M + N)</td>
<td>低</td>
<td>已排序的大表连接</td>
<td>间接优势（索引可帮助排序）</td>
</tr>
</tbody>
</table>
<h2 id="Caffeine">Caffeine</h2>
<p>一、Caffeine 核心原理</p>
<ol>
<li>整体架构<br>
Caffeine 是一个高性能的 Java 缓存库，基于 Google Guava 缓存 API 重新设计，具有以下核心组件：</li>
</ol>
<p>哈希表：使用并发哈希表存储缓存条目</p>
<p>访问队列：维护 LRU (最近最少使用) 顺序</p>
<p>写入队列：维护写入顺序</p>
<p>淘汰策略：基于大小、时间和引用类型的组合策略</p>
<ol start="2">
<li>缓存淘汰算法<br>
Caffeine 采用 Window TinyLFU 算法，结合了：</li>
</ol>
<p>TinyLFU：频率草图(count-min sketch)统计访问频率</p>
<p>LRU：保留最近访问的项目</p>
<p>分段缓存：分为主缓存区、保护区和边缓存区</p>
<ol start="3">
<li>并发控制<br>
使用 Striped 非阻塞数据结构</li>
</ol>
<p>读写分离设计</p>
<p>无锁并发优化</p>
<h1>问题群 2: 业务逻辑与服务层实现</h1>
<h2 id="1-基础问题-请简要描述一下订单服务的功能和流程。">1. <strong>基础问题</strong>: 请简要描述一下订单服务的功能和流程。</h2>
<p>核心流程：</p>
<p>​用户结算：从购物车中选择商品，触发 /api/cart/checkout 接口。<br>
​创建订单：生成订单并预占库存（OrderService.createOrder()）。<br>
​支付跳转：调用支付宝接口生成支付页面（OrderController.pay()）。<br>
​异步回调：支付宝回调通知支付结果（OrderController.payNotify()）。<br>
​状态更新：根据回调更新订单状态为“支付成功”并扣减库存。<br>
​超时释放：通过 RabbitMQ 延迟队列自动释放超时订单的库存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OrderController 中的支付跳转逻辑</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/&#123;orderId&#125;/pay&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="meta">@PathVariable</span> Integer orderId, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getOrderById(orderId);</span><br><span class="line">    <span class="comment">// 生成支付宝支付链接并返回给前端</span></span><br><span class="line">    <span class="type">AlipayClient</span> <span class="variable">alipayClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(...);</span><br><span class="line">    <span class="type">AlipayTradePagePayRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePagePayRequest</span>();</span><br><span class="line">    request.setBizContent(...); <span class="comment">// 封装订单信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">form</span> <span class="operator">=</span> alipayClient.pageExecute(request).getBody();</span><br><span class="line">    response.getWriter().write(form); <span class="comment">// 返回支付页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>问题群 3: 缓存策略与使用</h1>
<ol>
<li><strong>基础问题</strong>: 你在项目中使用了哪些缓存技术？它们的作用是什么？</li>
</ol>
<p>答案：<br>
项目中使用了 ​Redis 和 ​Caffeine 两种缓存技术：</p>
<p>​Redis：<br>
​作用：作为分布式缓存，存储高频访问数据（如广告信息、商品详情），支持跨服务节点的数据共享和一致性。<br>
​代码体现：RedisConfig 中配置了多个 RedisTemplate（如 advertisementRedisTemplate 和 productRedisTemplate），用于不同类型数据的序列化。<br>
​Caffeine：<br>
​作用：作为本地缓存（JVM 级别），缓存访问频率极高的数据（如广告元数据），减少 Redis 的网络开销。<br>
​代码体现：CacheConfig 中配置了 Caffeine 缓存管理器，设置容量和过期时间。<br>
​Redisson：<br>
​作用：提供分布式锁（如 RLock），防止缓存击穿。<br>
​代码体现：RedissonConfig 中初始化 RedissonClient。</p>
<ol>
<li>
<p><strong>深入问题</strong>: 请解释一下你是如何实现缓存穿透的防护的？使用了哪些策略？</p>
</li>
<li>
<p><strong>优化问题</strong>: 在缓存失效时，你如何使用分布式锁来防止缓存击穿？具体的实现是什么样的？</p>
</li>
<li>
<p><strong>复杂问题</strong>: 你能描述一下在预热缓存时的具体步骤吗？为什么要定期更新缓存？</p>
</li>
<li>
<p><strong>进一步挖掘</strong>: 对于缓存的命中率，你如何进行监控和分析？如果发现缓存命中率低，你会采取什么措施？</p>
<p>经过测试：在10000并发请求下还能保证错误率为0<br>
以下为原理：<br>
1. 缓存穿透防护<br>
空值缓存：当数据库查询结果为空时，缓存空列表（Collections.emptyList()），并设置较短的TTL（NULL_CACHE_TTL）。避免恶意请求穿透缓存直接访问数据库。<br>
双重检查锁：在未命中缓存时，通过分布式锁控制仅一个线程查询数据库，其他线程等待或降级，防止并发穿透。</p>
</li>
<li>
<p>缓存击穿防护<br>
分布式锁（Redisson）：使用 RLock 实现分布式锁，确保缓存失效时仅一个线程重建数据。<br>
非阻塞锁竞争：通过 tryLock(100ms) 控制锁等待时间，避免线程长时间阻塞，超时后触发降级逻辑，保障可用性。</p>
</li>
<li>
<p>缓存雪崩防护<br>
分片存储与随机TTL：将数据分片为多个键（如 PRODUCT_LIST_CACHE_KEY::chunk_0），每个分片设置基础TTL加随机偏移值（ThreadLocalRandom.current().nextInt(30_000)），避免所有缓存同时失效。<br>
异步批量写入：使用Redis Pipeline批量写入分片数据，减少网络开销，提升性能。</p>
</li>
<li>
<p>高并发查询优化<br>
分页加载数据库：通过分页查询（Pageable）避免单次大数据量查询导致数据库或内存压力。<br>
异步缓存重建：主线程返回数据后异步执行缓存重建，减少用户请求延迟，通过分片存储和Pipeline写入提升效率。</p>
</li>
<li>
<p>降级与回退策略<br>
锁超时降级：若获取锁失败或超时（如100ms内未获得锁），直接查询数据库并返回部分数据（如 PageRequest.of(0, 100)），避免系统雪崩。<br>
异常捕获：捕获分布式锁和缓存操作异常，降级到数据库查询，确保最终可用性。</p>
</li>
</ol>
<p>代码逻辑：</p>
<p><strong>1. 构建缓存 Key:</strong></p>
<ul>
<li>1.1 根据商品 <code>id</code> 构建 Redis 缓存 Key: <code>PRODUCT_CACHE_KEY + id</code></li>
</ul>
<p><strong>2. 尝试从缓存中获取:</strong></p>
<ul>
<li>
<p>2.1 使用 <code>productRedisTemplate.opsForValue().get(key)</code> 从 Redis 缓存中获取 <code>Product</code> 对象。</p>
</li>
<li>
<p>2.2 <strong>如果缓存命中:</strong></p>
<ul>
<li>2.2.1 <strong>空值判断:</strong>
<ul>
<li>2.2.1.1 检查 <code>product.getId() == -1</code></li>
<li>2.2.1.2 如果是 <code>true</code> (空值):
<ul>
<li>记录日志: “命中空值缓存，商品ID：{}”</li>
<li>返回 <code>null</code> (防止缓存穿透)</li>
</ul>
</li>
</ul>
</li>
<li>2.2.2 <strong>正常缓存:</strong>
<ul>
<li>2.2.2.1 如果 <code>product.getId() != -1</code>
<ul>
<li>记录日志: “从缓存中获取商品信息，商品ID：{}”</li>
<li>返回 <code>product</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>2.3 <strong>如果缓存未命中:</strong></p>
<ul>
<li>进入步骤 3 (从数据库加载)</li>
</ul>
</li>
</ul>
<p><strong>3. 防止缓存击穿 (使用分布式锁):</strong></p>
<ul>
<li>
<p>3.1 获取分布式锁: 使用 Redisson 获取名为 <code>&quot;product_lock_&quot; + id</code> 的锁</p>
</li>
<li>
<p>3.2 尝试获取锁:  <code>lock.lock()</code></p>
</li>
<li>
<p>3.3 <strong>双重检查:</strong> (获取锁后再次检查缓存)</p>
<ul>
<li>3.3.1 再次使用 <code>productRedisTemplate.opsForValue().get(key)</code> 从 Redis 获取 Product</li>
<li>3.3.2 <strong>如果缓存命中:</strong>
<ul>
<li>记录日志: “从缓存中获取商品信息，商品ID：{}”</li>
<li>返回 <code>product</code></li>
</ul>
</li>
<li>3.3.3 <strong>如果缓存仍然未命中:</strong>
<ul>
<li>进入步骤 4 (从数据库加载)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>4. 从数据库加载数据:</strong></p>
<ul>
<li>4.1 调用 <code>productRepository.findByIdWithSpecifications(id)</code> 从数据库获取 <code>Product</code> 对象</li>
</ul>
<p><strong>5. 处理数据库查询结果:</strong></p>
<ul>
<li>
<p>5.1 <strong>如果数据库中不存在该商品 (<code>product == null</code>):</strong></p>
<ul>
<li>5.1.1 <strong>防止缓存穿透:</strong>
<ul>
<li>创建一个新的 <code>Product</code> 对象</li>
<li>设置 <code>product.setId(-1)</code> (标记为空值)</li>
<li><code>productRedisTemplate.opsForValue().set(key, product, NULL_CACHE_TTL)</code> (缓存空值并设置过期时间)</li>
<li>记录日志: “缓存空值，商品ID：{}”</li>
<li>返回 <code>null</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>5.2 <strong>如果数据库中存在该商品 (<code>product != null</code>):</strong></p>
<ul>
<li>5.2.1 <strong>防止缓存雪崩:</strong>
<ul>
<li>计算随机过期时间:  <code>randomTtl = CACHE_TTL.toMillis() + (long)(Math.random() * 60000)</code></li>
</ul>
</li>
<li>5.2.2 <code>productRedisTemplate.opsForValue().set(key, product, randomTtl, TimeUnit.MILLISECONDS)</code> (将商品信息存入缓存并设置随机过期时间)</li>
<li>记录日志: “将商品信息存入缓存，商品ID：{}”</li>
<li>返回 <code>product</code></li>
</ul>
</li>
</ul>
<p><strong>6. 释放锁:</strong></p>
<ul>
<li>6.1  在 <code>finally</code> 块中执行 <code>lock.unlock()</code> (确保锁始终被释放，避免死锁)</li>
</ul>
<p><strong>空值缓存</strong>实现简单，能精确判断数据是否存在，但内存消耗不可控，易受恶意攻击，适合小型系统。<br>
<strong>布隆过滤器</strong>内存效率高，抗攻击性强，但存在误判率，数据更新复杂，适合大型系统。</p>
<p>实际应用中，<strong>建议采用组合方案：布隆过滤器 + 空值缓存 + 分布式锁</strong>，构建多层防御体系。</p>
<p><strong>选型策略方面：</strong></p>
<ul>
<li><strong>小型系统、高一致性要求：</strong> 优先使用空值缓存 + 分布式锁。</li>
<li><strong>大型系统、高并发随机Key攻击风险：</strong> 必须引入布隆过滤器，建议组合使用。</li>
<li><strong>金融级系统：</strong> 可考虑使用支持删除操作的。</li>
<li><strong>超高并发场景：</strong> 在Nginx层添加Lua + Bloom Filter实现前置拦截。</li>
</ul>
<p><strong>生产环境建议：</strong></p>
<ul>
<li><strong>监控告警：</strong> 监控Redis内存使用率（空值缓存）和误判率（布隆过滤器）。</li>
<li><strong>兜底策略：</strong> 始终保留空值缓存作为最后防线。</li>
<li><strong>过滤器优化：</strong> 使用Redisson的RBloomFilter或布谷鸟过滤器。</li>
<li><strong>冷启动方案：</strong> 分批次异步加载数据到过滤器。</li>
</ul>
<h2 id="JWT">JWT</h2>
<p>JWT结构： 由Header、Payload和Signature三部分组成。Header和Payload可解码，但Signature是防篡改的关键。<br>
防篡改机制： JWT通过Signature来防止Payload被篡改。篡改Payload会导致Signature无效，服务器会拒绝该Token。用户无法在不知道密钥的情况下生成有效的Signature。<br>
加密类型：<br>
对称加密 (HMAC + SHA256)： 使用同一密钥签名和验证，速度快但密钥共享存在安全风险。<br>
非对称加密 (RSA/ECDSA)： 使用私钥签名，公钥验证，安全性更高但计算开销更大。<br>
实践建议：<br>
客户端只需验证Token的场景 (API访问) 推荐使用非对称加密。<br>
内部服务间通信可考虑使用对称加密。<br>
务必安全存储密钥。<br>
敏感信息不要放在Payload中。</p>
<h2 id="问题群-5-消息队列与异步处理">问题群 5: 消息队列与异步处理</h2>
<ol>
<li><strong>基础问题</strong>: 请简要介绍一下你在项目中使用的消息队列技术。</li>
<li><strong>深入问题</strong>: 在订单处理中，为什么选择使用消息队列？它带来了哪些好处？</li>
<li><strong>优化问题</strong>: 如何确保消息的可靠性和顺序性？你在实现中考虑了哪些细节？</li>
<li><strong>复杂问题</strong>: 如果消费者处理消息失败，系统会如何恢复？你在设计中是否考虑了死信队列？</li>
<li><strong>进一步挖掘</strong>: 请描述一下如何使用RabbitMQ实现延迟队列？在实际应用中遇到了哪些挑战？</li>
</ol>
<p>库存释放机制<br>
主要机制：OrderTimeoutConsumer 监听延迟队列，超时后调用 handleExpiredOrder 释放库存。</p>
<p>兜底机制：ScheduledTask 定时扫描过期订单，防止消息丢失或处理失败。</p>
<p>冗余设计：确保极端情况下（如 RabbitMQ 宕机）仍能通过定时任务恢复。</p>
<h2 id="Redis-AND-Caffeine">Redis AND Caffeine</h2>
<h2 id="1-数据访问特性">1. 数据访问特性</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Caffeine（本地）</th>
<th>Redis（分布式）</th>
</tr>
</thead>
<tbody>
<tr>
<td>延迟</td>
<td>&lt; 1 μs（纯内存，无网络）</td>
<td>≈ 0.2–2 ms（网络＋内存）</td>
</tr>
<tr>
<td>吞吐</td>
<td>极高（线程局部，几百万 QPS）</td>
<td>高（依赖网络、单线程事件循环）</td>
</tr>
<tr>
<td>容量</td>
<td>受单机 JVM 堆内存限制（几十 MB–几 GB）</td>
<td>水平可扩展，受集群内存限制</td>
</tr>
<tr>
<td>一致性／共享</td>
<td>不支持跨实例共享，只在同一 JVM 内可见</td>
<td>多客户端／多实例可见，天然分布式</td>
</tr>
<tr>
<td>持久化</td>
<td>不支持；JVM 重启即空</td>
<td>支持 RDB/AOF 持久化</td>
</tr>
<tr>
<td>高级数据结构</td>
<td>仅简单 Key→Value</td>
<td>list、set、zset、hash、stream、bitmaps、geospatial…</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="2-适用场景">2. 适用场景</h2>
<h3 id="2-1-当选-Caffeine">2.1 当选 Caffeine</h3>
<ul>
<li><strong>单机或无须跨实例共享</strong>
<ul>
<li>方法结果缓存（<code>@Cacheable</code> 场景）：计算密集型、重复调用的纯函数（如费率限流、业务规则校验等）。</li>
<li>配置／元数据、白名单、字典表等小体量静态参照。</li>
<li>热点数据，一秒内多次读写：如本地计数器、短期限流、短期重试次数。</li>
</ul>
</li>
<li><strong>超低延迟要求</strong>
<ul>
<li>频繁访问、毫秒级以下延迟场景，完全消除网络抖动。</li>
</ul>
</li>
<li><strong>资源隔离</strong>
<ul>
<li>避免所有缓存压力打到集中式 Redis，利用本地内存分摊热点。</li>
</ul>
</li>
<li><strong>SLA 容忍度低</strong>
<ul>
<li>即使 Redis 故障，服务本地缓存依然可用（降级模式）。</li>
</ul>
</li>
</ul>
<h3 id="2-2-当选-Redis">2.2 当选 Redis</h3>
<ul>
<li><strong>跨实例／跨进程共享</strong>
<ul>
<li>分布式 Session、统一权限信息、用户登录态集中管理。</li>
<li>分布式限流、漏桶／令牌桶全局计数器。</li>
</ul>
</li>
<li><strong>大容量或长生命周期</strong>
<ul>
<li>多 GB—TB 级别的数据缓存（商品图片元数据、大规模配置）。</li>
<li>缓存持久化后可冷启动。</li>
</ul>
</li>
<li><strong>复杂数据结构与功能</strong>
<ul>
<li>排行榜（Sorted Set）、消息队列（List/Stream）、社交关系（Set）、地理位置（GEO）。</li>
<li>发布/订阅、事务、Lua 脚本、Bitmaps/HyperLogLog 等。</li>
</ul>
</li>
<li><strong>高可用／可扩展</strong>
<ul>
<li>主从复制、哨兵、Cluster 分片，支持线上扩容、故障切换。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-混合使用：二级缓存策略">3. 混合使用：二级缓存策略</h2>
<p>常见做法是在 <strong>应用内层</strong> 用 Caffeine 作「近缓存（L1）」、在 <strong>网络层</strong> 用 Redis 作「主缓存（L2）」，以兼顾超低延迟和数据一致性／共享。</p>
<p>工作流程示例：</p>
<ol>
<li>读请求先查 L1（Caffeine）</li>
<li>未命中再查 L2（Redis），并回填 L1</li>
<li>写／更新同时写 Redis，再 Invalid L1／主动刷新 L1</li>
</ol>
<p>这样可以</p>
<ul>
<li>显著降低 Redis 压力</li>
<li>保证分布式一致性（短期内有小概率读到过期 L1，可配合 TTL 或消息总线做通知）</li>
</ul>
<h2 id="缓存策略对比">缓存策略对比</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>Cache Aside（旁路缓存）</th>
<th>Write-Through（同步写入）</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>应用主动管理：读操作先查缓存，未命中时从后端加载并写入缓存；写操作更新数据库后再或删除缓存。</td>
<td>写操作同时写入缓存和数据库，保证写入过程中的强一致性；读操作只查缓存（未命中可回源并填充缓存）。</td>
</tr>
<tr>
<td>读流程</td>
<td>1. 应用→缓存查询<br>2. 缓存未命中 → 应用→数据库查询<br>3. 将结果写入缓存 → 返回结果</td>
<td>1. 应用→缓存查询<br>2. 缓存未命中 → 应用→数据库查询并写入缓存 → 返回结果</td>
</tr>
<tr>
<td>写流程</td>
<td>1. 应用→数据库写入<br>2. 写成功后，应用显式删除或更新缓存（使后续读到最新数据）</td>
<td>1. 应用→数据库写入<br>2. 同步更新缓存（写数据到缓存后才返回）</td>
</tr>
<tr>
<td>优点</td>
<td>- 简单灵活，读多写少场景常用<br>- 缓存只存热数据，避免无用缓存<br>- 可自行控制缓存失效时机</td>
<td>- 写入实时更新缓存，读操作命中率高<br>- 保证缓存与数据库强一致性<br>- 应用逻辑更简单，无需显式管理缓存失效</td>
</tr>
<tr>
<td>缺点</td>
<td>- 写操作后需手动维护缓存；若忘记删除/更新缓存会导致读到旧数据<br>- 首次读有额外的数据库延迟</td>
<td>- 每次写都要双写，写延迟增加、数据库负载较大<br>- 若缓存写入失败，需要额外补偿或重试机制</td>
</tr>
<tr>
<td>适用场景</td>
<td>- 读多写少、能容忍一定数据短暂不一致<br>- 热点数据自下而上加载<br>- 应用能严格控制何时失效或更新缓存</td>
<td>- 强一致性要求高的场景<br>- 写入频率适中，能接受写延迟<br>- 希望简化应用层缓存管理逻辑</td>
</tr>
</tbody>
</table>
<p>redis-cli INFO memory | grep used_memory<br>
redis-cli INFO keyspace | grep “^db”</p>
<h2 id="为什么用消息队列">为什么用消息队列</h2>
<p>​解耦性：<br>
支付和订单超时处理是核心业务，但它们的执行时长和成功率不应阻塞主流程。通过消息队列，支付回调（payNotify）只需发送消息到MQ，后续处理（如更新订单状态、库存扣减）由消费者异步完成，避免支付宝回调接口因处理时间长而超时。<br>
示例：OrderController.payNotify 发送消息到 payment.exchange 后立即返回&quot;success&quot;，避免支付宝重复回调。<br>
​异步提速：<br>
同步处理需等待所有步骤完成（如支付验证、订单更新、库存操作），而异步将耗时操作（如库存锁定）交给消费者，缩短接口响应时间。<br>
​可靠性：<br>
消息队列提供持久化、重试和死信机制。例如，在 PaymentResultConsumer 中，若处理支付结果失败，可通过 basicNack 重试或进入死信队列，避免数据不一致。<br>
​流量削峰：<br>
高并发时，MQ作为缓冲区，避免瞬间流量压垮数据库。订单创建和支付回调的高峰期，消息可堆积在队列中逐步消费。</p>
<p>TTL+DLX vs 插件：优缺点对比**<br>
​方案	​优点	​缺点	​适用场景<br>
TTL+DLX	无需插件，兼容性好	队列级固定TTL，无法单消息定制延迟	所有订单统一超时时间<br>
x-delayed-message	消息级延迟，灵活控制	需安装插件，运维复杂	动态延迟（如不同订单）<br>
​项目选择插件的原因：<br>
订单超时时间可能动态调整（例如促销活动延长支付时间），插件支持每条消息独立设置延迟。</p>
<p>手动确认 vs 自动确认**<br>
​手动确认优势：<br>
确保消息处理成功后才确认。例如，在 PaymentResultConsumer 中，只有订单状态更新成功后才发送 basicAck，避免消息丢失。<br>
自动确认在消费者接收消息后立即确认，若后续处理失败，消息无法恢复。</p>
<h2 id="login">login</h2>
<p>Q4.1（认证流程）<br>
认证流程：​</p>
<p>​提交凭证：用户发送登录请求到 AccountController.login，携带用户名和密码。<br>
​验证凭证：服务层校验密码（BCrypt 哈希比对）。<br>
​生成令牌：JwtUtil 生成 JWT，载荷包含 userId、username、role，签名使用密钥。<br>
​返回令牌：令牌通过响应头返回客户端。<br>
​后续请求：客户端在 Authorization 头携带 Bearer <token>。<br>
​拦截器验证：JwtInterceptor 验证签名、过期时间，解析出 userId 和 username 存入请求属性。<br>
​控制器访问：通过 @RequestAttribute(“userId”) 获取用户身份。<br>
JWT 载荷信息：​</p>
<p>​包含字段：userId（唯一标识用户）、username（显示用）、role（授权用）。<br>
​安全考量：<br>
​不存储敏感信息​（如密码）。<br>
​签名防篡改：确保令牌完整性。<br>
​短期有效期：通过 exp 字段限制令牌生命周期。</p>
<h2 id="JPA">JPA</h2>
<p>当你先执行一条查询拿到 N 条父实体（例如：SELECT * FROM product），然后在循环里依次访问其延迟加载的子集合（如 product.getSpecifications()），就会针对每一个父实体再发起一次子查询。<br>
总共产生 1（父查询）+ N（每个父实体一个子查询） 条 SQL，故称 N+1 问题。<br>
SELECT p.<em>, s.</em><br>
FROM product p<br>
LEFT JOIN specification s ON s.product_id = <a target="_blank" rel="noopener" href="http://p.id">p.id</a>;<br>
通过 JPQL 的 JOIN FETCH，Hibernate 会在一条 SQL 里同时把 Product 和它的 specifications 一并加载</p>
<h1>花旗杯</h1>
<h2 id="拦截器-等等">拦截器 等等</h2>
<p>LoginInterceptor 与 CorsFilter 的执行顺序及跨域鉴权协作<br>
执行顺序：</p>
<p>CorsFilter 作为 @Order(Ordered.HIGHEST_PRECEDENCE)，优先执行，处理跨域请求的CORS头。<br>
LoginInterceptor 作为后续拦截器，进行鉴权。<br>
跨域与鉴权的协作：</p>
<p>CorsFilter确保浏览器允许跨域请求（设置Access-Control-Allow-Origin等），使请求能到达后端。<br>
后端的LoginInterceptor在请求到达后，校验请求头中的token，确认用户身份。<br>
这样即使跨域请求允许发起，鉴权也能在请求到达后端进行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%870603/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%870603/" class="post-title-link" itemprop="url">准备0603</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:27:03" itemprop="dateCreated datePublished" datetime="2025-06-23T12:27:03+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据库中B-树相对于B树的优点总结">数据库中B+树相对于B树的优点总结</h2>
<ol>
<li>
<p><strong>更高效的磁盘I/O</strong></p>
<ul>
<li>B+树的非叶子节点仅存储键值和指针（不存储实际数据），使得单个节点能容纳更多索引项，从而降低树的高度，减少磁盘I/O次数。</li>
<li>所有数据仅存储在叶子节点，查询时需访问叶子节点，但通过减少中间节点的数据冗余，整体I/O效率更高。</li>
<li></li>
</ul>
</li>
<li>
<p><strong>更优的范围查询性能</strong></p>
<ul>
<li>B+树的叶子节点通过链表相连，范围查询时只需遍历链表即可，无需回溯上层节点；而B树需多次跨层访问。</li>
<li>例如，查询区间<code>[a, b]</code>时，B+树只需定位到起始叶子节点后顺序扫描，时间复杂度接近O(n)。</li>
</ul>
</li>
<li>
<p><strong>更稳定的查询性能</strong></p>
<ul>
<li>B+树的查询必须到达叶子节点，路径长度固定，性能稳定；B树可能在中间节点提前终止查询，导致性能波动。</li>
</ul>
</li>
<li>
<p><strong>更适合顺序访问与全表扫描</strong></p>
<ul>
<li>叶子节点的链表结构支持高效顺序遍历，适合全表扫描或排序操作；B树需复杂的中序遍历。</li>
</ul>
</li>
<li>
<p><strong>更优的并发控制</strong>  ！！</p>
<ul>
<li>B+树的叶子节点独立存储数据，更新操作通常仅影响局部叶子节点，减少锁竞争，适合高并发场景。</li>
<li>B树的分裂/合并可能涉及更多层级，并发控制复杂度更高。</li>
</ul>
</li>
<li>
<p><strong>缓存友好性</strong></p>
<ul>
<li>B+树的数据集中在叶子节点且连续存储，预读机制能更高效利用磁盘缓存。</li>
</ul>
</li>
<li>
<p><strong>适应大规模数据</strong></p>
<ul>
<li>B+树的扁平化结构使其在处理海量数据时仍能保持较低高度，而B树可能因数据分散导致深度增加。</li>
</ul>
</li>
</ol>
<h2 id="索引失效的常见场景">索引失效的常见场景</h2>
<p>违反最左前缀原则：联合索引未从最左列开始使用18</p>
<p>使用OR条件：查询条件包含OR且OR两边字段不全有索引58</p>
<p>对索引列运算：如WHERE age+1=20或使用函数WHERE YEAR(create_time)=202318</p>
<p>类型不一致：字符串列与数字比较WHERE name=1232</p>
<p>LIKE以通配符开头：WHERE name LIKE '%张’12</p>
<p>使用!=或&lt;&gt;：WHERE status != 128 范围查询(&gt;,&lt;,BETWEEN,LIKE)会使右侧列索引失效</p>
<p>IS NULL/IS NOT NULL：某些情况下会导致索引失效2</p>
<p>全表扫描更快：当MySQL优化器判断全表扫描比索引更快时8</p>
<p>InnoDB的MVCC（多版本并发控制）机制通过隐藏列、Undo Log和Read View协同工作，实现高并发下的数据一致性。以下是插入和访问数据的完整过程及底层细节：</p>
<hr>
<h2 id="MVCC-插入and查找数据的完整过程">MVCC 插入and查找数据的完整过程</h2>
<h3 id="一、插入数据的完整过程"><strong>一、插入数据的完整过程</strong></h3>
<ol>
<li>
<p><strong>分配事务ID</strong><br>
事务开始时，系统分配一个全局递增的事务ID（<code>trx_id</code>），例如<code>trx_id=100</code>。</p>
</li>
<li>
<p><strong>写入隐藏列</strong><br>
插入新行时，InnoDB为数据行添加三个隐藏字段：</p>
<ul>
<li><code>DB_ROW_ID</code>：唯一行ID（若未显式定义主键则自动生成）。</li>
<li><code>DB_TRX_ID</code>：记录操作该行的事务ID（即<code>trx_id=100</code>）。</li>
<li><code>DB_ROLL_PTR</code>（回滚指针）：指向该行在Undo Log中的历史版本，初始为<code>NULL</code>（因无历史版本）。</li>
</ul>
</li>
<li>
<p><strong>生成Undo Log记录</strong><br>
在Undo Log中记录插入前的状态（逻辑为空），用于事务回滚时删除该行。</p>
</li>
<li>
<p><strong>更新聚簇索引</strong><br>
数据写入聚簇索引的叶子节点，同时更新非聚簇索引（若有）。</p>
</li>
</ol>
<hr>
<h3 id="二、访问（查询）数据的完整过程"><strong>二、访问（查询）数据的完整过程</strong></h3>
<h4 id="步骤1：创建Read-View（可见性判断依据）"><strong>步骤1：创建Read View（可见性判断依据）</strong></h4>
<p>事务首次执行<code>SELECT</code>时生成Read View，包含：</p>
<ul>
<li><code>trx_ids</code>：当前所有活跃事务ID列表（如<code>[101, 102]</code>）。</li>
<li><code>up_limit_id</code>：最小活跃事务ID（如<code>101</code>）。</li>
<li><code>low_limit_id</code>：系统下一个将分配的事务ID（如<code>103</code>）。</li>
</ul>
<h4 id="步骤2：遍历版本链，判断可见性"><strong>步骤2：遍历版本链，判断可见性</strong></h4>
<p>对于目标数据行，从最新版本开始，沿<code>DB_ROLL_PTR</code>回溯版本链，按规则判断可见性：</p>
<ol>
<li><strong>若行记录的<code>DB_TRX_ID &lt; up_limit_id</code></strong><br>
说明该版本在Read View创建前已提交，<strong>可见</strong>（例如<code>DB_TRX_ID=99</code>）。</li>
<li><strong>若<code>DB_TRX_ID &gt;= low_limit_id</code></strong><br>
说明该版本在Read View创建后才生成，<strong>不可见</strong>（例如<code>DB_TRX_ID=103</code>）。</li>
<li><strong>若<code>DB_TRX_ID</code>在<code>[up_limit_id, low_limit_id)</code>区间</strong>：
<ul>
<li><strong>在<code>trx_ids</code>列表中</strong>：生成该版本的事务仍活跃（未提交），<strong>不可见</strong>（如<code>DB_TRX_ID=101</code>）。</li>
<li><strong>不在<code>trx_ids</code>列表中</strong>：生成该版本的事务已提交，<strong>可见</strong>（如<code>DB_TRX_ID=95</code>）。</li>
</ul>
</li>
</ol>
<h4 id="步骤3：返回匹配版本"><strong>步骤3：返回匹配版本</strong></h4>
<p>找到首个可见版本后返回数据；若全不可见则返回空。</p>
<blockquote>
<p><strong>示例场景</strong>（事务ID=100查询某行）：</p>
<ul>
<li>版本链：<code>当前版本(trx_id=102) → 历史版本(trx_id=90)</code></li>
<li>Read View：<code>trx_ids=[101, 102]</code>, <code>up_limit_id=101</code>, <code>low_limit_id=103</code></li>
<li>判断：
<ul>
<li>当前版本<code>trx_id=102</code>在<code>trx_ids</code>中 → 不可见。</li>
<li>历史版本<code>trx_id=90 &lt; up_limit_id(101)</code> → 可见，返回此版本数据。</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="三、关键机制详解"><strong>三、关键机制详解</strong></h3>
<ol>
<li>
<p><strong>版本链管理</strong></p>
<ul>
<li>每次更新/删除时，旧数据拷贝至Undo Log，新行<code>DB_TRX_ID</code>更新为当前事务ID，<code>DB_ROLL_PTR</code>指向旧版本。</li>
<li>删除操作标记<code>DB_TRX_ID</code>为删除事务ID，不立即物理删除。</li>
</ul>
</li>
<li>
<p><strong>隔离级别的影响</strong></p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>Read View生成策略</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>读已提交 (RC)</strong></td>
<td>每次<code>SELECT</code>都生成新Read View</td>
<td>可能读到其他事务已提交的修改</td>
</tr>
<tr>
<td><strong>可重复读 (RR)</strong></td>
<td>事务首次<code>SELECT</code>生成Read View并复用</td>
<td>全程读取同一快照，避免不可重复读</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Purge机制</strong><br>
后台线程定期清理不再被任何事务引用的Undo Log版本（如已提交事务的旧版本）。</p>
</li>
</ol>
<hr>
<h3 id="四、流程图解"><strong>四、流程图解</strong></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[事务开始] --&gt; B[插入数据]</span><br><span class="line">    B --&gt; C1[分配trx_id]</span><br><span class="line">    C1 --&gt; C2[写入隐藏字段]</span><br><span class="line">    C2 --&gt; C3[生成Undo Log]</span><br><span class="line">    C3 --&gt; D[更新索引]</span><br><span class="line"></span><br><span class="line">    E[查询数据] --&gt; F&#123;首次SELECT?&#125;</span><br><span class="line">    F --&gt;|是| G[创建Read View]</span><br><span class="line">    F --&gt;|否| H[复用Read View]</span><br><span class="line">    G/H --&gt; I[遍历版本链]</span><br><span class="line">    I --&gt; J&#123;检查DB_TRX_ID&#125;</span><br><span class="line">    J --&gt;|可见| K[返回数据]</span><br><span class="line">    J --&gt;|不可见| L[回溯上一版本]</span><br><span class="line">    L --&gt; J</span><br></pre></td></tr></table></figure>
<p>此机制确保：</p>
<ul>
<li>插入时：生成新版本并关联事务ID。</li>
<li>查询时：通过Read View过滤版本链，实现无锁快照读。</li>
<li>更新/删除时：创建新版本，旧版本进入Undo Log。</li>
</ul>
<h2 id="限流与降级">限流与降级</h2>
<p>多级降级策略：</p>
<p>一级降级：关闭非核心服务（如推荐、评论）</p>
<p>二级降级：简化核心业务流程（如跳过风控检查）</p>
<p>三级降级：静态化返回结果（如直接返回&quot;秒杀已结束&quot;）<br>
用户请求<br>
↓ (100万QPS)<br>
前端限流（验证码、按钮控制）<br>
↓ (30万QPS)<br>
Nginx限流（IP限制、频率控制）<br>
↓ (10万QPS)<br>
网关限流（API配额、集群限流）<br>
↓ (1万QPS)<br>
服务限流（线程池、信号量）<br>
↓ (1000QPS)<br>
数据库（最终写入）</p>
<p>用户在前端点击秒杀按钮<br>
前端进行防重复点击和请求频率限制<br>
请求发出，后端进行限流（QPS/IP限制）<br>
请求进入排队队列（如果系统压力大）<br>
排队到达，后端确认库存（预减库存）<br>
若库存充足，订单成功，库存减一<br>
若库存不足或系统压力大，采取降级措施（快速失败、功能降级）<br>
前端根据后端返回显示用户最终状态（成功/失败/排队中）</p>
<h2 id="线程池">线程池</h2>
<p>当前线程数 &lt; corePoolSize<br>
​行为：直接创建新线程（核心线程）处理任务。<br>
​示例：若corePoolSize=2，提交第1、2个任务时会立即创建2个线程执行。<br>
​当前线程数 ≥ corePoolSize 且队列未满<br>
​行为：任务放入队列等待执行。<br>
​示例：corePoolSize=2，队列容量=3。提交第3、4、5个任务时，任务进入队列，由空闲的核心线程处理。<br>
​队列已满且线程数 &lt; maximumPoolSize<br>
​行为：创建非核心线程处理新任务。<br>
​示例：maximumPoolSize=5，队列已满时，提交第6、7个任务会创建第3、4个线程（非核心线程）。<br>
​线程数 = maximumPoolSize 且队列已满<br>
​行为：触发拒绝策略（如抛出异常AbortPolicy或由调用线程执行CallerRunsPolicy）。<br>
​示例：maximumPoolSize=5，队列已满时，提交第8个任务会触发拒绝策略。</p>
<p>如何选择队列？<br>
场景	推荐队列	理由<br>
高吞吐，允许任务积压	LinkedBlockingQueue	避免频繁创建/销毁线程，但需警惕OOM。<br>
严格控制队列长度	ArrayBlockingQueue	防止资源耗尽，配合maximumPoolSize实现弹性扩容。<br>
低延迟，拒绝任务堆积	SynchronousQueue	任务直接执行或拒绝，适合短任务且要求快速响应的场景。<br>
按优先级处理任务	PriorityBlockingQueue	适用于任务有明确优先级的场景（如VIP用户请求优先）。<br>
​<br>
<img src="image.png" alt="alt text"></p>
<h2 id="spring单例模式">spring单例模式</h2>
<p>Spring 框架中的单例模式是其 IoC 容器的核心设计之一，通过<strong>单例注册表</strong>（如 <code>ConcurrentHashMap</code>）实现 Bean 的全局唯一性。以下从实现机制、线程安全、作用域对比和应用场景四个维度详细解析：</p>
<hr>
<h3 id="⚙️-一、实现机制：单例注册表与缓存">⚙️ 一、实现机制：单例注册表与缓存</h3>
<ol>
<li>
<p><strong>单例注册表（<code>singletonObjects</code>）</strong><br>
Spring 使用 <code>DefaultSingletonBeanRegistry</code> 类管理单例 Bean，其核心是一个线程安全的 <code>ConcurrentHashMap</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 注册单例 Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">        singletonObjects.put(beanName, singletonObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取单例 Bean</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singletonObjects.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>首次请求</strong>时创建 Bean 实例并存入注册表。</li>
<li><strong>后续请求</strong>直接返回缓存中的实例，避免重复创建。</li>
</ul>
</li>
<li>
<p><strong>Bean 生命周期管理</strong></p>
<ul>
<li><strong>初始化</strong>：容器启动时默认初始化单例 Bean（可通过 <code>@Lazy</code> 改为延迟加载）。</li>
<li><strong>依赖注入</strong>：通过 <code>@Autowired</code> 注入的依赖均为同一实例。</li>
<li><strong>销毁</strong>：容器关闭时调用单例 Bean 的销毁方法（如 <code>@PreDestroy</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="🔒-二、线程安全：容器安全-≠-Bean-安全">🔒 二、线程安全：容器安全 ≠ Bean 安全</h3>
<p>Spring 仅<strong>保证实例唯一性</strong>，不保证 Bean 内部状态的线程安全：</p>
<ul>
<li><strong>容器层安全</strong>：注册表使用 <code>ConcurrentHashMap</code> 和双重检查锁（DCL），避免多线程重复创建。</li>
<li><strong>业务层风险</strong>：若单例 Bean 含<strong>可变状态</strong>（如计数器），需开发者自行同步：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 可变状态</span></span><br><span class="line">    <span class="comment">// 需同步保护</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>解决方案</strong>：
<ul>
<li>无状态设计（推荐）：避免成员变量，用局部变量或参数传递数据。</li>
<li>同步机制：<code>synchronized</code>、<code>ReentrantLock</code>。</li>
<li>线程安全类：如 <code>AtomicInteger</code>、<code>ConcurrentHashMap</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="🔄-三、作用域对比：单例-vs-其他作用域">🔄 三、作用域对比：单例 vs 其他作用域</h3>
<p>Spring 支持 6 种 Bean 作用域，单例（<code>singleton</code>）为默认值：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>生命周期</th>
<th>适用场景</th>
<th>线程安全需求</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Singleton</strong></td>
<td>容器启动到关闭</td>
<td>无状态服务（如工具类、配置）</td>
<td>需开发者保障</td>
</tr>
<tr>
<td>Prototype</td>
<td>每次请求创建新实例</td>
<td>有状态对象（如用户会话）</td>
<td>实例隔离，无需同步</td>
</tr>
<tr>
<td>Request</td>
<td>HTTP 请求内有效</td>
<td>Web 请求级数据（如表单对象）</td>
<td>实例隔离</td>
</tr>
<tr>
<td>Session</td>
<td>HTTP 会话内有效</td>
<td>用户会话数据（如购物车）</td>
<td>实例隔离</td>
</tr>
</tbody>
</table>
<blockquote>
<p>💡 <strong>为何默认单例？</strong></p>
<ul>
<li><strong>性能优势</strong>：减少对象创建/GC 开销。</li>
<li><strong>资源复用</strong>：如数据库连接池、配置信息。</li>
<li>符合 Spring 设计哲学：容器管理无状态服务。</li>
</ul>
</blockquote>
<hr>
<h3 id="🛠️-四、典型应用场景">🛠️ 四、典型应用场景</h3>
<ol>
<li><strong>基础设施 Bean</strong><br>
数据库连接池（<code>DataSource</code>）、事务管理器（<code>TransactionManager</code>）等全局唯一资源。</li>
<li><strong>无状态服务</strong><br>
工具类（<code>StringUtils</code>）、业务逻辑层（<code>Service</code>）。</li>
<li><strong>配置类 Bean</strong><br>
系统配置（<code>@Configuration</code> 类），如 API 密钥、路径常量。</li>
</ol>
<hr>
<h3 id="⚠️-注意事项">⚠️ 注意事项</h3>
<ol>
<li><strong>循环依赖</strong>：单例 Bean 的循环依赖通过<strong>三级缓存</strong>解决（早期暴露引用）。</li>
<li><strong>作用域切换</strong>：需非单例时，显式声明 <code>@Scope(&quot;prototype&quot;)</code>。</li>
<li><strong>测试影响</strong>：单例的全局状态可能污染单元测试，建议用 <code>@DirtiesContext</code> 重置容器。</li>
</ol>
<hr>
<h3 id="💎-总结">💎 总结</h3>
<p>Spring 的单例模式通过<strong>注册表缓存</strong>实现 Bean 全局唯一，默认适用于无状态服务以提升性能。其线程安全性需开发者根据业务状态设计保障，多线程共享可变数据时需同步控制。理解单例与其他作用域的差异（如原型模式隔离状态），是合理设计 Spring 应用的关键。</p>
<h2 id="spring适配器">spring适配器</h2>
<p>当然可以！下面我会为你深入讲解<strong>适配器模式（Adapter Pattern）</strong>，特别是在<strong>Spring MVC 中 Controller 的实现</strong>场景下的应用与设计思想。</p>
<hr>
<h1>一、适配器模式（Adapter Pattern）简介</h1>
<h2 id="1-定义">1. 定义</h2>
<ul>
<li>适配器模式属于结构型设计模式，其核心思想是在接口不兼容的两个类之间引入一个“适配器”，使得原本不兼容的接口可以协同工作。</li>
<li><strong>意图</strong>：让原本因接口不匹配而无法一起工作的类能够合作。</li>
</ul>
<h2 id="2-经典示意">2. 经典示意</h2>
<ul>
<li><strong>目标接口（Target）</strong>：客户端期待的接口。</li>
<li><strong>适配者（Adaptee）</strong>：现有的接口或类，不符合目标接口。</li>
<li><strong>适配器（Adapter）</strong>：实现目标接口，内部调用适配者的方法，从而实现兼容。</li>
</ul>
<hr>
<h1>二、Spring MVC 中的适配器模式应用</h1>
<h2 id="1-背景">1. 背景</h2>
<ul>
<li>在Spring MVC中，<strong>不同类型的Controller</strong>（如 <code>@Controller</code>、<code>HttpRequestHandler</code>、<code>Controller</code>接口实现）可能有不同的调用方式和接口定义。</li>
<li><strong>为了统一调用入口</strong>，Spring定义了**<code>HandlerAdapter</code>**接口，作为“适配器”角色，将各种不同的Controller封装成一致的调用方式。</li>
</ul>
<h2 id="2-核心设计">2. 核心设计</h2>
<ul>
<li>
<p><strong>目标接口（Target）</strong>：<code>HandlerAdapter</code>，定义了统一的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line">    ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>适配者（Adaptee）</strong>：各种Controller实现（如 <code>Controller</code>、<code>HttpRequestHandler</code>等），它们有不同的调用方法。</p>
</li>
<li>
<p><strong>适配器（Adapter）</strong>：实现<code>HandlerAdapter</code>接口，为不同Controller类型提供统一的调用逻辑。</p>
</li>
</ul>
<hr>
<h1>三、设计细节</h1>
<h2 id="1-作用">1. 作用</h2>
<ul>
<li>让Spring MVC框架可以支持多种Controller类型（如<code>@Controller</code>注解的类、<code>Controller</code>接口实现、<code>HttpRequestHandler</code>等），无需在框架内硬编码不同Controller的调用方式。</li>
<li>通过引入多个<code>HandlerAdapter</code>实现类（如<code>RequestMappingHandlerAdapter</code>、<code>HttpRequestHandlerAdapter</code>等），实现多样化Controller的支持。</li>
</ul>
<h2 id="2-典型实现">2. 典型实现</h2>
<ul>
<li><strong><code>HttpRequestHandlerAdapter</code></strong>：支持实现了<code>HttpRequestHandler</code>接口的Controller。</li>
<li><strong><code>RequestMappingHandlerAdapter</code></strong>：支持基于<code>@RequestMapping</code>的Controller。</li>
</ul>
<p>每个适配器内部都实现了<code>supports()</code>方法，判断当前handler是否支持，如果支持，则调用<code>handle()</code>方法完成请求处理。</p>
<hr>
<h1>四、深入设计示意（伪代码）</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口（统一调用接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line">    ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配者（不同Controller类型）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpRequestHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器实现（将不同Controller适配到目标接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="type">Controller</span> <span class="variable">controller</span> <span class="operator">=</span> (Controller) handler;</span><br><span class="line">        <span class="keyword">return</span> controller.handleRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpRequestHandler</span> <span class="variable">httpHandler</span> <span class="operator">=</span> (HttpRequestHandler) handler;</span><br><span class="line">        httpHandler.handleRequest(request, response);</span><br><span class="line">        <span class="comment">// 可能不返回ModelAndView，或返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>调用流程：</strong></p>
<ul>
<li>DispatcherServlet收到请求。</li>
<li>根据handler对象（Controller、HttpRequestHandler等），遍历支持的HandlerAdapter，找到支持的适配器。</li>
<li>由适配器调用实际Controller的处理方法，实现接口统一。</li>
</ul>
<hr>
<h1>五、总结</h1>
<table>
<thead>
<tr>
<th><strong>角色</strong></th>
<th><strong>定义</strong></th>
<th><strong>在Spring MVC中的体现</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>目标接口（Target）</td>
<td>一致的调用接口</td>
<td><code>HandlerAdapter</code>，定义统一的处理方法</td>
</tr>
<tr>
<td>适配者（Adaptee）</td>
<td>不同类型的Controller</td>
<td><code>Controller</code>、<code>HttpRequestHandler</code>等</td>
</tr>
<tr>
<td>适配器（Adapter）</td>
<td>实现目标接口，调用适配者</td>
<td><code>ControllerHandlerAdapter</code>、<code>HttpRequestHandlerAdapter</code>等</td>
</tr>
</tbody>
</table>
<p><strong>核心思想</strong>：通过引入“适配器”层，将不同类型的Controller统一封装到相同的调用接口中，从而实现Spring MVC对多样Controller的支持，增强了框架的扩展性和灵活性。</p>
<p>LangChain4j 的工具调用（Function Calling/Tools）机制是其最强大的功能之一，它允许大语言模型（LLM）动态调用开发者定义的业务逻辑 API。以下是其工作原理的详细解析：</p>
<hr>
<h3 id="核心原理：工具调用流程"><strong>核心原理：工具调用流程</strong></h3>
<ol>
<li>
<p><strong>工具注册</strong></p>
<ul>
<li>开发者使用 <code>@Tool</code> 注解标记业务方法（如数据库操作、API 调用等）</li>
<li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppointmentTools</span> &#123;</span><br><span class="line">    <span class="meta">@Tool(&quot;预约挂号&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">bookAppointment</span><span class="params">(Appointment appointment)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑：调用数据库服务</span></span><br><span class="line">        <span class="keyword">return</span> appointmentService.save(appointment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>元数据生成</strong><br>
LangChain4j 在运行时自动生成工具的 <strong>JSON Schema</strong> 描述，包括：</p>
<ul>
<li>工具名称（<code>name</code>）</li>
<li>功能描述（<code>description</code>）</li>
<li>参数结构（<code>parameters</code> 的 JSON Schema）</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bookAppointment&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;预约挂号&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;department&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;username&quot;</span><span class="punctuation">,</span> <span class="string">&quot;department&quot;</span><span class="punctuation">,</span> <span class="string">&quot;date&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>模型决策</strong></p>
<ul>
<li>用户提问时，LangChain4j 将 <strong>工具描述</strong> 和 <strong>用户问题</strong> 一起发送给 LLM</li>
<li>LLM 判断是否需要调用工具：
<ul>
<li>若需要 → 返回工具调用请求（而非直接回答）</li>
<li>若不需要 → 直接生成文本回复</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>本地执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">  LLM-&gt;&gt;LangChain4j: 返回工具调用请求（JSON）</span><br><span class="line">  LangChain4j-&gt;&gt;ToolExecutor: 解析参数</span><br><span class="line">  ToolExecutor-&gt;&gt;业务方法: 反射调用 bookAppointment(...)</span><br><span class="line">  业务方法-&gt;&gt;数据库: 执行SQL/API调用</span><br><span class="line">  业务方法--&gt;&gt;ToolExecutor: 返回结果</span><br><span class="line">  ToolExecutor-&gt;&gt;LLM: 封装工具执行结果</span><br><span class="line">  LLM-&gt;&gt;用户: 生成最终回答</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="关键技术实现"><strong>关键技术实现</strong></h3>
<h4 id="1-动态参数绑定">1. <strong>动态参数绑定</strong></h4>
<ul>
<li><strong>JSON → Java 对象转换</strong><br>
LangChain4j 使用 <strong>Jackson</strong> 将 LLM 返回的 JSON 参数自动反序列化为 Java 对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LLM 返回的 JSON 参数</span></span><br><span class="line">&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;department&quot;</span>:<span class="string">&quot;内科&quot;</span>, <span class="string">&quot;date&quot;</span>:<span class="string">&quot;2025-04-14&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动转换为 Appointment 对象</span></span><br><span class="line"><span class="type">Appointment</span> <span class="variable">appt</span> <span class="operator">=</span> objectMapper.readValue(json, Appointment.class);</span><br><span class="line">bookAppointment(appt); <span class="comment">// 反射调用业务方法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-工具执行器（ToolExecutor）">2. <strong>工具执行器（ToolExecutor）</strong></h4>
<ul>
<li>核心组件 <code>DefaultToolExecutor</code> 处理：
<ul>
<li>匹配工具名称</li>
<li>参数反序列化</li>
<li>通过反射调用目标方法</li>
<li>捕获异常并转换为 LLM 可理解的错误消息</li>
</ul>
</li>
</ul>
<h4 id="3-对话管理">3. <strong>对话管理</strong></h4>
<ul>
<li>当 LLM 决定调用工具时，对话流程变为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户问题 </span><br><span class="line">→ LLM 返回工具调用请求（AiMessage） </span><br><span class="line">→ 执行本地工具 </span><br><span class="line">→ 将结果作为 ToolExecutionResultMessage 发送给 LLM </span><br><span class="line">→ LLM 生成最终回复</span><br></pre></td></tr></table></figure>
</li>
<li>关键代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Message&gt; messages = Arrays.asList(</span><br><span class="line">  UserMessage.from(question),</span><br><span class="line">  AiMessage.from(toolCallRequest),       <span class="comment">// 工具调用请求</span></span><br><span class="line">  ToolExecutionResultMessage.from(result) <span class="comment">// 工具执行结果</span></span><br><span class="line">);</span><br><span class="line"><span class="type">ChatResponse</span> <span class="variable">response</span> <span class="operator">=</span> model.generate(messages);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="为什么能安全调用业务逻辑？"><strong>为什么能安全调用业务逻辑？</strong></h3>
<ol>
<li>
<p><strong>沙箱化执行</strong></p>
<ul>
<li>工具方法在 <strong>当前 JVM</strong> 中执行，与业务代码共享安全上下文</li>
<li>无需暴露 API 给外部网络</li>
</ul>
</li>
<li>
<p><strong>参数校验机制</strong></p>
<ul>
<li>通过 <code>@P</code> 注解定义参数约束：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tool</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cancelAppointment</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@P(value=&quot;身份证号&quot;, required=true)</span> String idCard,</span></span><br><span class="line"><span class="params">    <span class="meta">@P(value=&quot;预约日期&quot;)</span> String date</span></span><br><span class="line"><span class="params">)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>LangChain4j 自动生成参数校验规则，LLM 必须提供合法参数</li>
</ul>
</li>
<li>
<p><strong>权限控制</strong><br>
可通过 <code>@ToolMemoryId</code> 绑定用户会话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tool</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProfile</span><span class="params">(<span class="meta">@ToolMemoryId</span> String userId)</span> &#123;</span><br><span class="line">  <span class="comment">// 根据 userId 查询数据</span></span><br><span class="line">  <span class="keyword">return</span> userService.getProfile(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="与普通-API-调用的本质区别"><strong>与普通 API 调用的本质区别</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>传统 API 调用</th>
<th>LangChain4j 工具调用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>触发方式</strong></td>
<td>开发者显式调用</td>
<td>LLM 动态决策触发</td>
</tr>
<tr>
<td><strong>参数传递</strong></td>
<td>手动构造参数对象</td>
<td>LLM 自动生成合规参数</td>
</tr>
<tr>
<td><strong>执行上下文</strong></td>
<td>独立 HTTP 请求</td>
<td>当前 JVM 进程内执行</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>开发者手动处理</td>
<td>自动转换异常为 LLM 可读消息</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>确定性业务流</td>
<td>需自然语言理解的灵活场景</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="实战示例：挂号系统工具调用"><strong>实战示例：挂号系统工具调用</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tool(name=&quot;预约挂号&quot;, value=&quot;先检查号源再预约&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">bookAppointment</span><span class="params">(Appointment request)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 检查号源是否可用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> queryDepartment(</span><br><span class="line">        request.getDepartment(), </span><br><span class="line">        request.getDate(), </span><br><span class="line">        request.getTime()</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 执行业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (available) &#123;</span><br><span class="line">        appointmentService.save(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该时段无号源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用流程</span></span><br><span class="line"><span class="comment">// 用户提问 → &quot;我想预约内科4月14日上午的号&quot;</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="comment">// LLM 返回工具调用：</span></span><br><span class="line"><span class="comment">//   bookAppointment(&#123;</span></span><br><span class="line"><span class="comment">//     &quot;department&quot;: &quot;内科&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;date&quot;: &quot;2025-04-14&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;time&quot;: &quot;上午&quot;</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="comment">// LangChain4j 执行 bookAppointment(...)</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="comment">// 返回结果 → LLM 生成最终回复</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="总结：核心价值"><strong>总结：核心价值</strong></h3>
<ol>
<li>
<p><strong>自然语言接口</strong><br>
用户用自然语言触发复杂业务逻辑（如“取消我周二的预约”）</p>
</li>
<li>
<p><strong>业务逻辑解耦</strong><br>
业务代码无需感知 AI 模型，只需关注功能实现</p>
</li>
<li>
<p><strong>动态决策能力</strong><br>
LLM 根据问题语义自动选择工具并生成合规参数</p>
</li>
<li>
<p><strong>安全执行</strong><br>
通过 JVM 沙箱、参数校验、会话隔离保障安全性</p>
</li>
</ol>
<p>这种设计使 LangChain4j 成为连接大语言模型与传统业务系统的桥梁，特别适合需要自然语言交互的复杂业务场景（如医疗挂号、订单管理等）。</p>
<h2 id="方法区里到底有什么">方法区里到底有什么</h2>
<p>Java 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在虚拟机启动时创建，用于存放对象实例。从内存回收角度，堆被划分为新生代和老年代，新生代又分为 Eden 区和两个 Survivor 区（From Survivor 和 To Survivor）。如果在堆中没有内存完成实例分配，并且堆也无法扩展时会抛出 OutOfMemoryError 异常。<br>
方法区（元空间）：在 JDK 1.8 及以后的版本中，方法区被元空间取代，使用本地内存。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。虽然方法区被描述为堆的逻辑部分，但有 “非堆” 的别名。方法区可以选择不实现垃圾收集，内存不足时会抛出 OutOfMemoryError 异常。</p>
<hr>
<h3 id="1-核心职责不同"><strong>1. 核心职责不同</strong></h3>
<ul>
<li>
<p><strong>堆（Heap）</strong><br>
<strong>对象生存的土壤</strong>：所有通过 <code>new</code> 创建的对象实例（包括数组）都存储于此。<br>
<strong>核心作用</strong>：支撑 Java 程序运行时 <strong>对象的动态分配和生命周期管理</strong>，是垃圾回收（GC）的主战场。</p>
</li>
<li>
<p><strong>方法区（Method Area / Metaspace）</strong><br>
<strong>类元数据的基石</strong>：存储与类结构相关的静态信息（不是对象！）。<br>
<strong>核心作用</strong>：支撑 JVM 的 <strong>类加载机制</strong>，记录类的“设计蓝图”（如类名、方法字节码、字段定义等），是程序静态结构的仓库。</p>
</li>
</ul>
<hr>
<h3 id="2-存储内容不同"><strong>2. 存储内容不同</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>堆（Heap）</strong></th>
<th><strong>方法区（元空间）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>存储对象</strong></td>
<td>✅ 所有对象实例、数组</td>
<td>❌ 不存储任何对象实例</td>
</tr>
<tr>
<td><strong>类信息</strong></td>
<td>❌</td>
<td>✅ 类名、父类、接口、访问修饰符</td>
</tr>
<tr>
<td><strong>方法字节码</strong></td>
<td>❌</td>
<td>✅ 方法的代码指令（编译后的字节码）</td>
</tr>
<tr>
<td><strong>运行时常量池</strong></td>
<td>❌（但字符串常量池在堆中）</td>
<td>✅ 类的字面量、符号引用等（在元空间内）</td>
</tr>
<tr>
<td><strong>静态变量</strong></td>
<td>❌</td>
<td>✅ 静态变量（<code>static</code> 修饰的变量）</td>
</tr>
<tr>
<td><strong>字符串常量池</strong></td>
<td>✅（JDK7+ 从方法区移至堆）</td>
<td>❌（JDK7 后不再存储在方法区）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>📌 <strong>关键差异</strong>：堆存“对象”，方法区存“类的描述信息”。</p>
</blockquote>
<hr>
<h3 id="3-内存特性不同"><strong>3. 内存特性不同</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>堆（Heap）</strong></th>
<th><strong>方法区（元空间）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>内存位置</strong></td>
<td>JVM 管理的内存区域</td>
<td>JDK8+：使用本地内存（Native Memory）</td>
</tr>
<tr>
<td><strong>垃圾回收</strong></td>
<td>✅ 频繁 GC（分代收集：新生代/老年代）</td>
<td>✅ 低频率 GC（卸载不再使用的类）</td>
</tr>
<tr>
<td><strong>内存溢出错误</strong></td>
<td><code>OutOfMemoryError: Java heap space</code></td>
<td><code>OutOfMemoryError: Metaspace</code></td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>受 <code>-Xmx</code> 限制，无法突破最大堆大小</td>
<td>默认无上限（受物理内存限制），可设 <code>-XX:MaxMetaspaceSize</code></td>
</tr>
<tr>
<td><strong>线程共享</strong></td>
<td>✅ 所有线程共享</td>
<td>✅ 所有线程共享</td>
</tr>
</tbody>
</table>
<blockquote>
<p>💡 <strong>元空间的本地内存特性</strong>：<br>
JDK8 将方法区从“堆内的永久代”迁移到“本地内存的元空间”，避免了永久代大小受限的问题（不再有 <code>PermGen OutOfMemory</code>），直接使用操作系统的内存。</p>
</blockquote>
<hr>
<h3 id="本质总结"><strong>本质总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>堆（Heap）</strong></th>
<th><strong>方法区（Metaspace）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>是什么</strong></td>
<td><strong>对象实例的运行时数据池</strong></td>
<td><strong>类元数据的存储仓库</strong></td>
</tr>
<tr>
<td><strong>存什么</strong></td>
<td><code>new</code> 出来的对象</td>
<td>类的结构信息（非对象！）</td>
</tr>
<tr>
<td><strong>存在哪</strong></td>
<td>JVM 管理的堆内存</td>
<td>操作系统本地内存（JDK8+）</td>
</tr>
<tr>
<td><strong>为何存在</strong></td>
<td>动态分配对象内存</td>
<td>支撑类加载、反射、方法调用等机制</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="场景比喻"><strong>场景比喻</strong></h3>
<ul>
<li>
<p><strong>堆</strong> → <strong>汽车工厂的组装车间</strong><br>
流水线上动态生产汽车（对象），空间不足时扩建厂房（扩容），废旧汽车拆解回收（GC）。</p>
</li>
<li>
<p><strong>方法区</strong> → <strong>工厂的设计档案室</strong><br>
存放汽车设计图纸（类信息）、生产标准（字节码）、零件规格（常量）。档案室独立于车间（本地内存），图纸陈旧时才清理（类卸载）。</p>
</li>
</ul>
<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p>类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。<br>
常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。<br>
静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。<br>
方法字节码：存储类的方法字节码，即编译后的代码。<br>
符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。<br>
运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。<br>
常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。<br>
#String保存在哪里呢？</p>
<h2 id="ThreadLocal内存泄漏">ThreadLocal内存泄漏</h2>
<p>ThreadLocal的实现中，每个Thread维护一个ThreadLocalMap映射表，key是ThreadLocal实例本身，value是真正需要存储的Object。</p>
<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。</p>
<p>如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。<br>
这条路径要记得！是ThreadLocalMap -&gt; Entry -&gt; value！这样的<br>
如何解决此问题？<br>
第一，使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除；</p>
<h2 id="对象头（Object-Header）的详细解析"><strong>对象头（Object Header）的详细解析</strong></h2>
<p>在对象创建的第四步中，<strong>对象头（Object Header）的设置</strong>是JVM对对象进行内部管理的关键环节。对象头存储了对象的元数据信息，直接影响JVM的运行时行为（如锁机制、垃圾回收等）。以下从5个维度深入分析：</p>
<hr>
<h3 id="一、对象头的结构"><strong>一、对象头的结构</strong></h3>
<p>对象头由 <strong>固定部分</strong> 和 <strong>可变部分</strong> 组成（以64位JVM为例，未开启压缩指针）：</p>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>大小（64位JVM）</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mark Word</strong></td>
<td>8字节</td>
<td>存储对象运行时数据：哈希码、GC分代年龄、锁状态等</td>
</tr>
<tr>
<td><strong>Klass Pointer</strong></td>
<td>8字节</td>
<td>指向类元数据的指针（方法区中的Class对象）</td>
</tr>
<tr>
<td><strong>数组长度</strong></td>
<td>4字节（可选）</td>
<td>仅当对象是数组时存在，记录数组长度</td>
</tr>
</tbody>
</table>
<h3 id="内存布局示例"><strong>内存布局示例</strong></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-------------------------------------------------------|</span><br><span class="line">| Mark Word (8 bytes) | Klass Pointer (8 bytes) | 数组长度 (4 bytes) | 实例数据... |</span><br><span class="line">|-------------------------------------------------------|</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二、Mark-Word的详细内容"><strong>二、Mark Word的详细内容</strong></h3>
<p>Mark Word是对象头的核心部分，其内容会<strong>根据对象状态动态变化</strong>（以HotSpot VM为例）：</p>
<h3 id="不同状态下的存储格式"><strong>不同状态下的存储格式</strong></h3>
<table>
<thead>
<tr>
<th>对象状态</th>
<th>存储内容（64位JVM）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无锁态</strong></td>
<td>25位哈希码 + 4位分代年龄 + 1位偏向锁标志（0） + 2位锁标志（01） + 32位未使用</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>54位线程ID + 2位Epoch + 4位分代年龄 + 1位偏向锁标志（1） + 2位锁标志（01）</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>62位指向栈中锁记录的指针 + 2位锁标志（00）</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>62位指向监视器（Monitor）的指针 + 2位锁标志（10）</td>
</tr>
<tr>
<td><strong>GC标记</strong></td>
<td>62位空（用于标记可回收对象） + 2位锁标志（11）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🔥 <strong>关键点</strong>：</p>
<ul>
<li>锁标志位（最后2位）决定当前对象的锁状态（01=无锁/偏向锁，00=轻量级锁，10=重量级锁，11=GC标记）。</li>
<li><strong>哈希码延迟计算</strong>：调用<code>System.identityHashCode()</code>时才生成并存入Mark Word。</li>
</ul>
</blockquote>
<hr>
<h3 id="三、Klass-Pointer的作用"><strong>三、Klass Pointer的作用</strong></h3>
<p>Klass Pointer指向方法区中的<strong>类元数据</strong>（即Class对象），使JVM能够：</p>
<ol>
<li><strong>确定对象类型</strong>：在运行时识别对象属于哪个类。</li>
<li><strong>访问类信息</strong>：通过该指针找到方法表、字段定义等元数据。</li>
<li><strong>支持多态</strong>：结合方法表实现虚方法调用。</li>
</ol>
<h3 id="压缩指针优化（-XX-UseCompressedOops）"><strong>压缩指针优化（-XX:+UseCompressedOops）</strong></h3>
<ul>
<li>开启后，Klass Pointer从8字节压缩为4字节，节省内存。</li>
<li>要求堆内存不超过32GB（否则指针无法压缩）。</li>
</ul>
<hr>
<h3 id="四、数组长度的特殊处理"><strong>四、数组长度的特殊处理</strong></h3>
<p>当对象是数组时，对象头会额外增加4字节存储<strong>数组长度</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];  <span class="comment">// 对象头包含长度字段</span></span><br></pre></td></tr></table></figure>
<ul>
<li>长度字段的存在让JVM能快速检查数组越界（如<code>ArrayIndexOutOfBoundsException</code>）。</li>
<li>非数组对象没有此字段。</li>
</ul>
<hr>
<h3 id="五、对象头与JVM功能的关联"><strong>五、对象头与JVM功能的关联</strong></h3>
<h3 id="1-锁机制"><strong>1. 锁机制</strong></h3>
<ul>
<li><strong>偏向锁</strong>：通过Mark Word中的线程ID实现，减少同步开销。</li>
<li><strong>轻量级锁</strong>：将Mark Word替换为指向线程栈锁记录的指针。</li>
<li><strong>重量级锁</strong>：指向Monitor对象（操作系统层面的互斥量）。</li>
</ul>
<h3 id="2-垃圾回收"><strong>2. 垃圾回收</strong></h3>
<ul>
<li><strong>分代年龄</strong>：4位存储（最大15），触发GC时年龄+1，超过阈值则晋升老年代。</li>
<li><strong>GC标记</strong>：标记阶段用特殊位标识可回收对象。</li>
</ul>
<h3 id="3-内存布局优化"><strong>3. 内存布局优化</strong></h3>
<ul>
<li><strong>字段重排序</strong>：JVM可能根据对象头信息调整实例字段的排列顺序，以节省内存。</li>
</ul>
<h2 id="Java静态初始化（-clinit-）与对象初始化（-init-）总结"><strong>Java静态初始化（<code>&lt;clinit&gt;</code>）与对象初始化（<code>&lt;init&gt;</code>）总结</strong></h2>
<p>在Java虚拟机（JVM）中，类的初始化过程被细分为两个截然不同的阶段：<strong>静态初始化</strong>（对应JVM的<code>&lt;clinit&gt;</code>方法）和<strong>对象初始化</strong>（对应JVM的<code>&lt;init&gt;</code>方法）。理解这两者的区别对于掌握Java类的生命周期、内存管理以及编写健程、高效的代码至关重要。</p>
<p><strong>核心差异概述</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>静态初始化 (<code>&lt;clinit&gt;</code>)</th>
<th>对象初始化 (<code>&lt;init&gt;</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>作用范围</strong></td>
<td>类级别</td>
<td>对象实例级别</td>
</tr>
<tr>
<td><strong>执行次数</strong></td>
<td>每个类在JVM生命周期中仅执行<strong>一次</strong></td>
<td>每次创建对象实例时执行</td>
</tr>
<tr>
<td><strong>触发时机</strong></td>
<td>类首次被主动使用时（如第一次 <code>new</code>、访问静态成员、反射加载类并初始化）</td>
<td>每次执行 <code>new</code> 操作时</td>
</tr>
<tr>
<td><strong>内容</strong></td>
<td>静态变量赋初值、静态代码块</td>
<td>实例变量赋初值、实例代码块、构造方法</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>由JVM隐式保证（线程安全）</td>
<td>需开发者自行处理（非线程安全）</td>
</tr>
<tr>
<td><strong>底层方法</strong></td>
<td><code>&lt;clinit&gt;</code></td>
<td><code>&lt;init&gt;</code></td>
</tr>
</tbody>
</table>
<p><strong>静态初始化（<code>&lt;clinit&gt;</code>）详解</strong></p>
<p><code>&lt;clinit&gt;</code> 方法是编译器自动为每个类生成的，它汇集了源码中所有<strong>静态变量的显式赋值</strong>和<strong>静态代码块</strong>（<code>static &#123;&#125;</code>）中的逻辑。它的主要作用是完成类本身相关的准备工作，例如初始化静态字段、加载配置等类级别的资源。</p>
<p><code>&lt;clinit&gt;</code> 的触发严格且高效。只有在类被首次“主动使用”时（如通过 <code>new</code> 关键字创建实例、直接访问静态变量/方法、通过反射强制初始化等），JVM才会执行 <code>&lt;clinit&gt;</code>。一个类一旦完成初始化，后续的所有使用都不会再次触发 <code>&lt;clinit&gt;</code>。</p>
<p>尤其重要的是，JVM为 <code>&lt;clinit&gt;</code> 方法的执行提供了<strong>线程安全性保证</strong>。当多个线程同时尝试初始化同一个类时，JVM会确保只有一个线程执行 <code>&lt;clinit&gt;</code>，其他线程会阻塞等待，直到初始化完成。这使得静态初始化成为实现简单线程安全单例模式的天然温床。</p>
<p>反编译字节码可以清晰地看到 <code>&lt;clinit&gt;</code> 方法的存在，它按照源码中静态变量和静态块出现的顺序依次执行。</p>
<p><strong>对象初始化（<code>&lt;init&gt;</code>）详解</strong></p>
<p><code>&lt;init&gt;</code> 方法则与类的实例（对象）紧密相关。它也是编译器自动生成的，合并了<strong>实例变量的显式赋值</strong>、<strong>实例代码块</strong>（<code>&#123;&#125;</code>）以及<strong>构造方法</strong>中的逻辑。每次通过 <code>new</code> 关键字创建一个对象时，都会调用该对象的 <code>&lt;init&gt;</code> 方法来初始化该实例特有的状态。</p>
<p>与 <code>&lt;clinit&gt;</code> 不同，<code>&lt;init&gt;</code> <strong>每次</strong>创建新对象时都会执行。这意味着同一个类的不同对象会执行各自独立的初始化过程。<code>&lt;init&gt;</code> 的执行顺序在继承体系中尤为关键：它总是先调用<strong>父类的 <code>&lt;init&gt;</code> 方法</strong>（通过 <code>invokespecial</code> 指令，对应父类构造器的执行），然后执行<strong>当前类的实例变量赋值和实例代码块</strong>，最后执行<strong>当前类的构造方法体</strong>。</p>
<p><code>&lt;init&gt;</code> 方法的执行<strong>不是线程安全的</strong>。多个线程创建各自的对象实例时，它们会独立地执行 <code>&lt;init&gt;</code>。如果对象的初始化逻辑（特别是构造方法或实例块中的代码）涉及到共享资源的修改，开发者必须自行实现同步机制（如使用 <code>synchronized</code> 关键字）来保证线程安全。</p>
<p>反编译字节码同样会展示 <code>&lt;init&gt;</code> 方法，其中包含了对父类 <code>&lt;init&gt;</code> 的调用以及本类实例变量和实例块的初始化指令。</p>
<p><strong>关键对比与应用场景</strong></p>
<ol>
<li>
<p><strong>初始化顺序：</strong> 在一个继承体系中，当创建一个子类对象时，完整的初始化流程是：<br>
父类静态初始化 (<code>Parent.&lt;clinit&gt;</code>) -&gt; 子类静态初始化 (<code>Child.&lt;clinit&gt;</code>) -&gt; 父类对象初始化 (<code>Parent.&lt;init&gt;</code>) -&gt; 子类对象初始化 (<code>Child.&lt;init&gt;</code>)。静态初始化只发生一次，而对象初始化每次创建子类对象时都会重复。</p>
</li>
<li>
<p><strong>线程安全性：</strong> 利用 <code>&lt;clinit&gt;</code> 的线程安全特性可以轻松实现饿汉式单例模式，如 <code>private static Singleton instance = new Singleton();</code>，JVM保证在类加载时安全地创建实例。而懒汉式或其他复杂的对象创建若需线程安全，则需要在 <code>&lt;init&gt;</code> 或调用 <code>&lt;init&gt;</code> 的外部（如工厂方法）进行同步控制。</p>
</li>
<li>
<p><strong>异常处理：</strong> <code>&lt;clinit&gt;</code> 执行失败会导致 JVM 抛出 <code>NoClassDefFoundError</code>（而非 <code>ClassNotFoundException</code>），这个类在整个应用生命周期内将无法被正常使用，影响范围广。而 <code>&lt;init&gt;</code> 执行失败通常抛出正常的运行时异常，只影响当前对象的创建，不影响类的可用性或其他对象。</p>
</li>
</ol>
<p>标记-清除是非移动式回收算法​（Non-Moving），其设计决定了必须：</p>
<p>标记阶段：全堆扫描以保证准确性。<br>
清除阶段：全堆扫描以释放内存。<br>
所以慢</p>
<h2 id="各种垃圾回收器">各种垃圾回收器</h2>
<p>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；<br>
ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；<br>
Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；<br>
Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；<br>
Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；<br>
CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。<br>
G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代</p>
<h2 id="CMS与G1的标记过程对比及STW阶段分析"><strong>CMS与G1的标记过程对比及STW阶段分析</strong></h2>
<p>CMS（Concurrent Mark-Sweep）和G1（Garbage-First）是两种不同的垃圾回收器，它们在标记过程和STW（Stop-The-World）行为上有显著差异。以下是详细对比：</p>
<hr>
<h3 id="一、CMS的标记过程与STW阶段"><strong>一、CMS的标记过程与STW阶段</strong></h3>
<p>CMS的设计目标是<strong>最小化老年代回收的停顿时间</strong>，其标记过程分为以下阶段：</p>
<h3 id="1-初始标记（Initial-Mark）"><strong>1. 初始标记（Initial Mark）</strong></h3>
<ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：仅标记<strong>GC Roots直接引用的老年代对象</strong>（不递归标记）。</li>
<li><strong>耗时</strong>：极短（通常几毫秒），因为只扫描直接引用。</li>
</ul>
<h3 id="2-并发标记（Concurrent-Marking）"><strong>2. 并发标记（Concurrent Marking）</strong></h3>
<ul>
<li><strong>并发执行</strong>：与用户线程同时运行。</li>
<li><strong>任务</strong>：从初始标记的对象出发，递归标记所有<strong>老年代可达对象</strong>。</li>
<li><strong>耗时</strong>：较长（取决于老年代对象数量），但无需STW。</li>
<li><strong>问题</strong>：可能产生<strong>浮动垃圾</strong>（标记期间新产生的垃圾）。</li>
</ul>
<h3 id="3-重新标记（Remark）"><strong>3. 重新标记（Remark）</strong></h3>
<ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：修正并发标记期间因用户线程运行导致的<strong>引用变化</strong>（如新增或删除的引用）。</li>
<li><strong>优化技术</strong>：使用**增量更新（Incremental Update）<strong>或</strong>卡表（Card Table）**减少扫描范围。</li>
<li><strong>耗时</strong>：比初始标记长，但远短于并发标记（通常10-100ms）。</li>
</ul>
<h3 id="4-并发清除（Concurrent-Sweep）"><strong>4. 并发清除（Concurrent Sweep）</strong></h3>
<ul>
<li><strong>并发执行</strong>：与用户线程同时运行。</li>
<li><strong>任务</strong>：清理未被标记的垃圾对象（不整理内存，导致碎片化）。</li>
<li><strong>耗时</strong>：较长，但无需STW。</li>
</ul>
<hr>
<h3 id="二、G1的标记过程与STW阶段"><strong>二、G1的标记过程与STW阶段</strong></h3>
<p>G1的设计目标是<strong>平衡吞吐量和低延迟</strong>，其标记过程更复杂，覆盖整个堆（新生代+老年代）：</p>
<h3 id="1-初始标记（Initial-Mark）-2"><strong>1. 初始标记（Initial Mark）</strong></h3>
<ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：标记GC Roots直接引用的对象（类似CMS）。</li>
<li><strong>附加工作</strong>：与**年轻代GC（Young GC）**一起执行（借道Young GC的STW）。</li>
<li><strong>耗时</strong>：极短（通常几毫秒）。</li>
</ul>
<h3 id="2-并发标记（Concurrent-Marking）-2"><strong>2. 并发标记（Concurrent Marking）</strong></h3>
<ul>
<li><strong>并发执行</strong>：与用户线程同时运行。</li>
<li><strong>任务</strong>：递归标记整个堆（包括新生代和老年代）的可达对象。</li>
<li><strong>优化技术</strong>：使用**Snapshot-At-The-Beginning（SATB）**算法记录初始快照，减少重新标记工作量。</li>
<li><strong>耗时</strong>：较长，但无需STW。</li>
</ul>
<h3 id="3-最终标记（Final-Marking）"><strong>3. 最终标记（Final Marking）</strong></h3>
<ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：处理SATB队列中的引用变化，完成标记。</li>
<li><strong>耗时</strong>：比CMS的重新标记更可控（通常10-50ms）。</li>
</ul>
<h3 id="4-清理阶段（Cleanup）"><strong>4. 清理阶段（Cleanup）</strong></h3>
<ul>
<li><strong>部分STW</strong>：
<ul>
<li><strong>STW部分</strong>：统计存活对象，选择回收收益高的Region（基于G1的回收优先级）。</li>
<li><strong>并发部分</strong>：重置空Region的标记状态。</li>
</ul>
</li>
<li><strong>耗时</strong>：通常很短（几毫秒）。</li>
</ul>
<h3 id="5-复制阶段（Evacuation）"><strong>5. 复制阶段（Evacuation）</strong></h3>
<ul>
<li><strong>STW</strong>：暂停所有应用线程。</li>
<li><strong>任务</strong>：将存活对象从待回收Region复制到空闲Region（压缩内存）。</li>
<li><strong>耗时</strong>：取决于存活对象数量（通常10-200ms）。</li>
</ul>
<hr>
<h3 id="三、CMS与G1的关键差异"><strong>三、CMS与G1的关键差异</strong></h3>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>CMS</strong></th>
<th><strong>G1</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>作用区域</strong></td>
<td>仅老年代</td>
<td>整个堆（新生代+老年代）</td>
</tr>
<tr>
<td><strong>标记范围</strong></td>
<td>仅老年代对象</td>
<td>全堆对象</td>
</tr>
<tr>
<td><strong>STW阶段</strong></td>
<td>初始标记、重新标记</td>
<td>初始标记、最终标记、清理（部分）、复制</td>
</tr>
<tr>
<td><strong>并发阶段</strong></td>
<td>并发标记、并发清除</td>
<td>并发标记</td>
</tr>
<tr>
<td><strong>内存整理</strong></td>
<td>不整理（碎片化严重）</td>
<td>复制阶段整理（减少碎片）</td>
</tr>
<tr>
<td><strong>触发条件</strong></td>
<td>老年代空间不足</td>
<td>基于Region的回收阈值（默认45%堆占用）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>低延迟老年代回收</td>
<td>大堆内存、平衡吞吐量与延迟</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="四、STW阶段的本质差异"><strong>四、STW阶段的本质差异</strong></h3>
<h3 id="1-CMS的STW更少但不可控"><strong>1. CMS的STW更少但不可控</strong></h3>
<ul>
<li><strong>优点</strong>：仅初始标记和重新标记需要STW，适合对延迟敏感的老年代回收。</li>
<li><strong>缺点</strong>：
<ul>
<li>并发清除不整理内存，最终可能触发Full GC（Serial Old）整理碎片。</li>
<li>重新标记时间可能因引用变化量波动。</li>
</ul>
</li>
</ul>
<h3 id="2-G1的STW更多但可预测"><strong>2. G1的STW更多但可预测</strong></h3>
<ul>
<li><strong>优点</strong>：
<ul>
<li>通过<strong>SATB算法</strong>和<strong>Region分区</strong>，使最终标记时间更稳定。</li>
<li>复制阶段整理内存，避免碎片化问题。</li>
</ul>
</li>
<li><strong>缺点</strong>：总体STW时间比CMS长，但通过<strong>停顿预测模型</strong>（-XX:MaxGCPauseMillis）控制。</li>
</ul>
<hr>
<h2 id="五、如何选择？"><strong>五、如何选择？</strong></h2>
<ul>
<li><strong>选择CMS</strong>：若应用需要<strong>极低的老年代停顿</strong>（如延迟敏感型服务），且堆内存较小（如4-6GB以下）。</li>
<li><strong>选择G1</strong>：若堆内存较大（如6GB以上），或需要<strong>平衡吞吐量与延迟</strong>（如大数据处理）。<br>
四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。<br>
因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW</li>
</ul>
<h2 id="浮动垃圾（Floating-Garbage）深度解析与CMS-G1差异总结"><strong>浮动垃圾（Floating Garbage）深度解析与CMS/G1差异总结</strong></h2>
<p>在并发垃圾回收器中，为了减少或消除GC时对用户线程的长时间暂停（Stop-The-World, STW），垃圾回收过程的部分或大部分是与用户线程并行进行的。然而，这种并发性引入了一个特有的问题：<strong>浮动垃圾</strong>（Floating Garbage）。</p>
<p><strong>什么是浮动垃圾？</strong></p>
<p>浮动垃圾是指在垃圾回收器执行并发阶段（如并发标记或并发清理）时，由于用户线程仍在运行并修改对象引用关系，导致原本被认为是存活的对象变得不可达（即成为垃圾）。这些新产生的垃圾对象因为它们“出现”在标记或清理过程的“之后”，本轮GC无法识别并回收它们，它们就像“浮”在水面上一样，只能等待下一轮GC周期才能被清理。</p>
<p>简单来说，如果在并发标记阶段，一个对象 <code>A</code> 被标记为存活，但随后用户线程将指向 <code>A</code> 的唯一引用设置为 <code>null</code>，那么 <code>A</code> 就成为了本轮GC的浮动垃圾。</p>
<p><strong>CMS 回收器与浮动垃圾</strong></p>
<p>CMS（Concurrent Mark Sweep）回收器是典型的处理老年代的并发回收器。其核心思想是希望大部分标记和清理工作能够与用户线程并发进行。然而，CMS的设计决定了它必然会产生浮动垃圾，并且浮动垃圾可能导致严重的问题。</p>
<p>CMS 的主要步骤包括：</p>
<ol>
<li><strong>初始标记 (STW)</strong>：标记GC Roots直接关联的对象。</li>
<li><strong>并发标记 (Concurrent)</strong>：从GC Roots开始遍历对象图，标记所有存活对象。<em>此阶段用户线程运行，可能创建新对象、断开引用，产生浮动垃圾。</em></li>
<li><strong>重新标记 (STW)</strong>：修正并发标记期间因用户线程活动导致的对象引用变化。虽然尝试修正，但仍无法完全捕捉所有变化。</li>
<li><strong>并发清理 (Concurrent)</strong>：扫描堆，回收未被标记的对象。<em>此阶段用户线程也运行，会继续创建新对象并可能产生新的垃圾，这些新垃圾也成为浮动垃圾。</em></li>
</ol>
<p>CMS 回收的特点是<strong>非移动式</strong>的（Non-moving），即它只负责标记和清除死对象占据的空间，但不整理内存，会产生内存碎片。由于清理是并发进行的，CMS 无法实时地追踪和处理用户线程新产生的浮动垃圾。这些浮动垃圾会一直占据内存空间，直到下一轮GC周期才能被回收。</p>
<p>为了应对浮动垃圾可能导致的内存不足问题，CMS 必须预留一部分老年代空间。如果预留空间被浮动垃圾耗尽，而用户线程此时需要分配内存或对象需要晋升到老年代，就会触发 <strong>Concurrent Mode Failure</strong>，此时JVM会紧急启动一个 Full GC（通常是 Serial Old 回收器），这是一个全堆范围的、单线程的、STW的回收过程，会导致应用长时间停顿，严重影响性能。因此，CMS 的一个重要调优参数 <code>-XX:CMSInitiatingOccupancyFraction</code> 就是控制老年代在何种占用比例下启动GC，以尽早回收，留出足够的空间容纳浮动垃圾和新晋升的对象。</p>
<p><strong>G1 回收器与浮动垃圾</strong></p>
<p>G1（Garbage-First）回收器是面向大堆的、区域（Region）化的并发回收器。虽然G1也是并发回收器，它也产生浮动垃圾，但处理方式和影响与CMS有显著不同，通常认为G1没有CMS那样突出的“浮动垃圾问题”。</p>
<p>G1通过以下机制来缓解浮动垃圾的影响：</p>
<ol>
<li><strong>Region 分区</strong>：G1将堆划分为多个大小相等的 Region。GC时可以针对性地回收部分 Region。</li>
<li><strong>SATB 标记算法 (Snapshot-At-The-Beginning)</strong>：G1在并发标记阶段使用的是 SATB 算法。SATB 会记录标记开始时的对象引用图<strong>快照</strong>。在并发标记过程中，如果用户线程删除了一个引用，SATB 会通过 Remembered Set 记录下来。SATB 的核心思想是：所有在标记开始时被快照认为是存活的对象，都会被视为存活，即使它们在标记过程中变成了垃圾。这意味着 SATB 会<strong>有意地将一部分本应是垃圾的对象标记为存活</strong>——这些就是G1中的浮动垃圾。</li>
<li><strong>筛选回收 (Evacuation)</strong>：G1的清理阶段本质上是<strong>并行复制</strong>。在 Evacuation 阶段（通常有较短的STW），G1会将选中区域（包括新生代和部分老年代）中的存活对象复制到新的空闲 Region 中。原先的 Region 整个被释放。这个复制过程是并行的，且在STW下进行，因此不会产生新的浮动垃圾。</li>
</ol>
<p>G1的SATB算法产生的浮动垃圾不会导致像CMS那样的 Concurrent Mode Failure。被SATB错误标记为存活的浮动垃圾对象会被复制到新Region中，它们只是延迟到<strong>下一轮</strong>GC周期才会被回收。G1通过控制每次 Evacuation 回收的 Region 数量（基于用户设置的目标暂停时间）来管理内存回收速率，而不是依赖预留空间来应对随时可能溢出的浮动垃圾。即使G1的并发标记跟不上用户线程分配速率，导致没有足够的空闲Region进行Evacuation，它会增加 Evacuation 的 Region 数量或临时 Full GC，但这种 Full GC 的触发原因和CMS的 CM Failure 不同，也通常优化得比 Serial Old 好。</p>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>CMS</strong></th>
<th><strong>G1</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>标记算法</strong></td>
<td>增量更新 (Incremental Update)</td>
<td>原始快照 (SATB - Snapshot-At-The-Beginning)</td>
</tr>
<tr>
<td><strong>清理方式</strong></td>
<td>并发清理 (Sweep - Non-moving)</td>
<td>并行复制 (Evacuation - Moving)</td>
</tr>
<tr>
<td><strong>浮动垃圾来源</strong></td>
<td>并发标记和并发清理阶段用户线程修改引用</td>
<td>并发标记阶段用户线程修改引用 (SATB特性)</td>
</tr>
<tr>
<td><strong>浮动垃圾影响</strong></td>
<td>累积可能导致内存不足，触发 CM Failure (STW)</td>
<td>被SATB标记为存活，延迟到下一轮回收，不直接导致 CM Failure</td>
</tr>
<tr>
<td><strong>应对策略</strong></td>
<td>预留内存空间 (<code>CMSInitiatingOccupancyFraction</code>)</td>
<td>SATB + Region化 + 并行复制 (延迟清理)</td>
</tr>
</tbody>
</table>
<p>核心差异在于，CMS的非移动式并发清理与浮动垃圾的产生直接冲突，需要预留空间避免失败；而G1的SATB标记和并行复制机制虽然也产生浮动垃圾，但将其处理推迟到下一轮，并通过Region的管理和复制的方式避免了CMS那种因浮动垃圾填满老年代导致的紧急STW退化。因此，理解浮动垃圾的产生及其在不同回收器中的处理方式，对于选择合适的GC回收器和进行性能调优至关重要。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">         <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">         Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; nums[q.getLast()] &lt;= nums[i])&#123;</span><br><span class="line">               q.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            q.addLast();</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; i - q.getFirst() &gt;= k)&#123;</span><br><span class="line">               q.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k)&#123;</span><br><span class="line">               ans[i-k+<span class="number">1</span>] = q.getFirst();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E4%BD%9C%E4%B8%9A2PV%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E4%BD%9C%E4%B8%9A2PV%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">作业2PV题目整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:25:29" itemprop="dateCreated datePublished" datetime="2025-06-23T12:25:29+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下是整理后的代码，调整了格式、缩进和变量命名以提高可读性（纯文本格式）：</p>
<hr>
<h3 id="1-使用信号量和P、V操作实现"><strong>(1) 使用信号量和P、V操作实现</strong></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    char readerName[10];</span><br><span class="line">    int seatNumber;</span><br><span class="line">&#125; Seat[100];  // 阅览室座位数组</span><br><span class="line"></span><br><span class="line">semaphore mutex, availableSeats;</span><br><span class="line">int i;</span><br><span class="line">mutex = 1;       // 互斥信号量，初始为1</span><br><span class="line">availableSeats = 100;  // 空闲座位数，初始为100</span><br><span class="line"></span><br><span class="line">// 初始化座位</span><br><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    Seat[i].seatNumber = i;</span><br><span class="line">    Seat[i].readerName = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">process Reader_i(char readerName[]) &#123;  // i = 1, 2, ...</span><br><span class="line">    P(availableSeats);  // 申请一个空闲座位</span><br><span class="line">    P(mutex);           // 进入临界区</span><br><span class="line">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        if (Seat[i].readerName == NULL) &#123;</span><br><span class="line">            Seat[i].readerName = readerName;</span><br><span class="line">            int assignedSeat = Seat[i].seatNumber;  // 读者获得座位号i</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V(mutex);           // 离开临界区</span><br><span class="line"></span><br><span class="line">    // 读者在阅览室读书...</span><br><span class="line">    P(mutex);           // 再次进入临界区</span><br><span class="line">    Seat[i].readerName = NULL;  // 释放座位</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(availableSeats);  // 增加空闲座位数</span><br><span class="line"></span><br><span class="line">    // 离开阅览室</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-使用管程实现"><strong>(2) 使用管程实现</strong></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">type ReadingRoom = MONITOR &#123;</span><br><span class="line">    semaphore R;</span><br><span class="line">    int waitingReaders, currentReaders, totalSeats;</span><br><span class="line">    char seatOccupants[100];  // 记录每个座位的读者名</span><br><span class="line">    totalSeats = 0;           // 已占用座位数初始为0</span><br><span class="line"></span><br><span class="line">    // 管程接口定义</span><br><span class="line">    DEFINE enterRoom(), leaveRoom();</span><br><span class="line">    USE enter(), leave(), wait(), signal();</span><br><span class="line"></span><br><span class="line">    // 读者进入阅览室</span><br><span class="line">    void enterRoom(char readerName[]) &#123;</span><br><span class="line">        enter();</span><br><span class="line">        if (totalSeats &gt;= 100) &#123;</span><br><span class="line">            wait(R, waitingReaders);  // 无座位则等待</span><br><span class="line">        &#125;</span><br><span class="line">        totalSeats++;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            if (seatOccupants[i] == NULL) &#123;</span><br><span class="line">                seatOccupants[i] = readerName;</span><br><span class="line">                int assignedSeat = i;  // 读者获得座位号i</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leave();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读者离开阅览室</span><br><span class="line">    void leaveRoom(char readerName[]) &#123;</span><br><span class="line">        enter();</span><br><span class="line">        totalSeats--;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            if (seatOccupants[i] == readerName) &#123;</span><br><span class="line">                seatOccupants[i] = NULL;  // 释放座位</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        signal(R, waitingReaders);  // 唤醒一个等待的读者</span><br><span class="line">        leave();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">process Reader_i() &#123;  // i = 1, 2, ...</span><br><span class="line">    ReadingRoom.enterRoom(readerName);  // 进入阅览室</span><br><span class="line">    // 读书...</span><br><span class="line">    ReadingRoom.leaveRoom(readerName);  // 离开阅览室</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>
<p>以下是整理后的代码，调整了格式、缩进和变量命名以提高可读性（纯文本格式）：</p>
<hr>
<h3 id="1-使用信号量实现黑白子拣选">(1) 使用信号量实现黑白子拣选</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">semaphore whiteSem, blackSem;</span><br><span class="line">whiteSem = 1;  // 初始可以拣白子</span><br><span class="line">blackSem = 0;  // 初始不能拣黑子</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">process WhiteStonePicker() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        P(whiteSem);    // 申请拣白子权限</span><br><span class="line">        PickWhiteStone(); // 拣白子操作</span><br><span class="line">        V(blackSem);    // 允许拣黑子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process BlackStonePicker() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        P(blackSem);    // 申请拣黑子权限</span><br><span class="line">        PickBlackStone(); // 拣黑子操作</span><br><span class="line">        V(whiteSem);    // 允许拣白子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-使用管程实现黑白子拣选">(2) 使用管程实现黑白子拣选</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">type ChessPicker = MONITOR &#123;</span><br><span class="line">    bool canPickWhite;  // 当前是否可以拣白子</span><br><span class="line">    semaphore blackQueue, whiteQueue;  // 等待队列</span><br><span class="line">    int blackWaitCount, whiteWaitCount;  // 等待进程数</span><br><span class="line">    </span><br><span class="line">    InterfaceModule IM;</span><br><span class="line">    DEFINE pickBlack, pickWhite;</span><br><span class="line">    USE enter, leave, wait, signal;</span><br><span class="line"></span><br><span class="line">    void pickBlack() &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        if (!canPickWhite) &#123;  // 如果不能拣黑子</span><br><span class="line">            wait(blackQueue, blackWaitCount, IM);  // 加入黑子等待队列</span><br><span class="line">        &#125;</span><br><span class="line">        canPickWhite = true;  // 设置下次可以拣白子</span><br><span class="line">        PickBlackStone();     // 拣黑子操作</span><br><span class="line">        signal(whiteQueue, whiteWaitCount, IM);  // 唤醒拣白子进程</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pickWhite() &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        if (canPickWhite) &#123;   // 如果不能拣白子</span><br><span class="line">            wait(whiteQueue, whiteWaitCount, IM);  // 加入白子等待队列</span><br><span class="line">        &#125;</span><br><span class="line">        canPickWhite = false;  // 设置下次可以拣黑子</span><br><span class="line">        PickWhiteStone();      // 拣白子操作</span><br><span class="line">        signal(blackQueue, blackWaitCount, IM);  // 唤醒拣黑子进程</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">process BlackPicker() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        ChessPicker.pickBlack();</span><br><span class="line">        // 其他操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process WhitePicker() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        ChessPicker.pickWhite();</span><br><span class="line">        // 其他操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>
<p>以下是整理后的生产者-消费者问题解决方案，包含信号量和管程两种实现方式（纯文本格式）：</p>
<hr>
<h3 id="1-信号量实现（生产者每次生产3个，消费者每次消费1个）">(1) 信号量实现（生产者每次生产3个，消费者每次消费1个）</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 共享缓冲区定义</span><br><span class="line">int buffer[9];          // 环形缓冲区</span><br><span class="line">int count = 0;          // 当前缓冲区数据量</span><br><span class="line">int getPtr = 0;         // 消费者指针</span><br><span class="line">int putPtr = 0;         // 生产者指针</span><br><span class="line"></span><br><span class="line">// 信号量定义</span><br><span class="line">semaphore mutexPut = 1;  // 生产者互斥锁</span><br><span class="line">semaphore mutexGet = 1;  // 消费者互斥锁</span><br><span class="line">semaphore emptySlots = 3; // 可生产空间（初始可生产3个）</span><br><span class="line">semaphore filledSlots = 0; // 可消费数据（初始无可消费）</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        producer_i();</span><br><span class="line">        consumer_j();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process producer_i() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 生产3个整数</span><br><span class="line">        int item1, item2, item3 = generateItems(); </span><br><span class="line"></span><br><span class="line">        P(emptySlots);      // 检查是否有至少3个空位</span><br><span class="line">        P(mutexPut);        // 获取生产者锁</span><br><span class="line">        </span><br><span class="line">        // 放入缓冲区</span><br><span class="line">        buffer[putPtr] = item1;</span><br><span class="line">        putPtr = (putPtr + 1) % 9;</span><br><span class="line">        buffer[putPtr] = item2;</span><br><span class="line">        putPtr = (putPtr + 1) % 9;</span><br><span class="line">        buffer[putPtr] = item3;</span><br><span class="line">        putPtr = (putPtr + 1) % 9;</span><br><span class="line">        </span><br><span class="line">        V(mutexPut);        // 释放生产者锁</span><br><span class="line">        V(filledSlots);     // 增加3个可消费项</span><br><span class="line">        V(filledSlots);</span><br><span class="line">        V(filledSlots);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process consumer_j() &#123;</span><br><span class="line">    int consumedItem;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        P(filledSlots);     // 检查是否有可消费项</span><br><span class="line">        P(mutexGet);        // 获取消费者锁</span><br><span class="line">        </span><br><span class="line">        consumedItem = buffer[getPtr];</span><br><span class="line">        getPtr = (getPtr + 1) % 9;</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        // 每消费3个释放1次生产权限</span><br><span class="line">        if (count == 3) &#123;</span><br><span class="line">            count = 0;</span><br><span class="line">            V(emptySlots);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        V(mutexGet);        // 释放消费者锁</span><br><span class="line">        processItem(consumedItem); // 消费数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-管程实现">(2) 管程实现</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">type BufferManager = MONITOR &#123;</span><br><span class="line">    int buffer[9];         // 环形缓冲区</span><br><span class="line">    int count = 0;         // 当前数据量</span><br><span class="line">    int getPtr = 0;        // 消费位置</span><br><span class="line">    int putPtr = 0;        // 生产位置</span><br><span class="line">    </span><br><span class="line">    semaphore producerWait, consumerWait;  // 等待队列</span><br><span class="line">    int waitingProducers = 0, waitingConsumers = 0;</span><br><span class="line">    </span><br><span class="line">    InterfaceModule IM;</span><br><span class="line">    DEFINE putItems, getItem;</span><br><span class="line">    USE enter, leave, wait, signal;</span><br><span class="line"></span><br><span class="line">    procedure putItems(int item1, int item2, int item3) &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        // 如果剩余空间不足3个则等待</span><br><span class="line">        if (count &gt; 6) &#123;</span><br><span class="line">            wait(producerWait, waitingProducers, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 放入3个数据</span><br><span class="line">        buffer[putPtr] = item1;</span><br><span class="line">        putPtr = (putPtr + 1) % 9;</span><br><span class="line">        buffer[putPtr] = item2;</span><br><span class="line">        putPtr = (putPtr + 1) % 9;</span><br><span class="line">        buffer[putPtr] = item3;</span><br><span class="line">        putPtr = (putPtr + 1) % 9;</span><br><span class="line">        count += 3;</span><br><span class="line">        </span><br><span class="line">        // 唤醒可能等待的消费者</span><br><span class="line">        signal(consumerWait, waitingConsumers, IM);</span><br><span class="line">        signal(consumerWait, waitingConsumers, IM);</span><br><span class="line">        signal(consumerWait, waitingConsumers, IM);</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    procedure getItem(ref int output) &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        // 缓冲区为空则等待</span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            wait(consumerWait, waitingConsumers, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        output = buffer[getPtr];</span><br><span class="line">        getPtr = (getPtr + 1) % 9;</span><br><span class="line">        count--;</span><br><span class="line">        </span><br><span class="line">        // 当缓冲区有空闲时唤醒生产者</span><br><span class="line">        if (count &lt; 7) &#123;</span><br><span class="line">            signal(producerWait, waitingProducers, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果还有数据则唤醒其他消费者</span><br><span class="line">        else if (count &gt; 0) &#123;</span><br><span class="line">            signal(consumerWait, waitingConsumers, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 进程定义</span><br><span class="line">cobegin</span><br><span class="line">process producer_i() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        int a, b, c = generateItems();</span><br><span class="line">        BufferManager.putItems(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process consumer_j() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        int data;</span><br><span class="line">        BufferManager.getItem(data);</span><br><span class="line">        consumeItem(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>(1) 系统处于安全状态，存在安全序列：P0, P3, P4, P1, P2.</strong></p>
<table>
<thead>
<tr>
<th>Process</th>
<th>Current Avail (A,B,C,D)</th>
<th>C<sub>ki</sub> - A<sub>ki</sub> (A,B,C,D)</th>
<th>Allocation (A,B,C,D)</th>
<th>Current Avail + Allocation (A,B,C,D)</th>
<th>Possible</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>1, 6, 2, 2</td>
<td>0, 0, 1, 2</td>
<td>0, 0, 3, 2</td>
<td>1, 6, 5, 4</td>
<td>True</td>
</tr>
<tr>
<td>P3</td>
<td>1, 6, 5, 4</td>
<td>0, 6, 5, 2</td>
<td>0, 3, 3, 2</td>
<td>1, 9, 8, 6</td>
<td>True</td>
</tr>
<tr>
<td>P4</td>
<td>1, 9, 8, 6</td>
<td>0, 6, 5, 6</td>
<td>0, 0, 1, 4</td>
<td>1, 9, 9, 10</td>
<td>True</td>
</tr>
<tr>
<td>P1</td>
<td>1, 9, 9, 10</td>
<td>1, 7, 5, 0</td>
<td>1, 0, 0, 0</td>
<td>2, 9, 9, 10</td>
<td>True</td>
</tr>
<tr>
<td>P2</td>
<td>2, 9, 9, 10</td>
<td>2, 3, 5, 6</td>
<td>1, 3, 5, 4</td>
<td>3, 12, 14, 14</td>
<td>True</td>
</tr>
</tbody>
</table>
<p><strong>(2) 不能分配，系统会处于不安全状态。</strong></p>
<p>若我执行 P2 发出的 request(1, 2, 2, 2)，Available = (0, 4, 0, 0)，那后续分配就不能继续满足了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">操作系统：第二章复习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-06-23 12:25:29 / 修改时间：12:26:41" itemprop="dateCreated datePublished" datetime="2025-06-23T12:25:29+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PSW">PSW</h2>
<p>程序状态字PSW<br>
PSW既是操作系统的概念，指记录当前程序运行的动态信息，通常包含：<br>
程序计数器、指令寄存器、条件码<br>
中断字、中断允许/禁止、中断屏蔽、处理器模式、内存保护、调试控制<br>
PSW也是计算机系统的寄存器<br>
通常设置一组控制与状态寄存器<br>
也可以专设一个PSW寄存器<br>
标志划分为三组:状态标志、控制标志和系统标志(更多见P58)<br>
状态标志：使得一条指令的执行结果影响其后指令的执行，比如溢出等标志<br>
控制指令：控制操作系统行为，比如模式转换等。<br>
系统标志：与进程管理有关，用于保护模式。</p>
<blockquote>
<p>不同架构的实现差异<br>
​x86：称为标志寄存器（FLAGS）​，包含CF、ZF、OF等标志。<br>
​ARM：使用CPSR​（当前程序状态寄存器），包含模式位和条件码。<br>
​单片机（如8051）​：8位PSW，含CY、AC、OV等位。</p>
</blockquote>
<h2 id="内核态">内核态</h2>
<p>内核态（Kernel Mode）是操作系统内核运行的特权模式，其本质是CPU的一种硬件级权限状态，用于隔离和保护系统核心资源，确保操作系统的安全性和稳定性。<br>
​特性	​内核态	​用户态<br>
​权限	可执行所有指令，访问全部资源	仅限非特权指令，受限内存访问<br>
​切换触发	系统调用、异常、硬件中断	主动请求内核服务（如open()）<br>
​典型场景	中断处理、进程调度、驱动交互	应用程序运行（如浏览器、编辑器）<br>
tips：内存映射文件：<br>
mmap()可将文件映射到用户空间，但首次访问会触发缺页异常，由内核加载数据到内存。</p>
<h2 id="以下三种方式是唯一能触发用户模式-内核模式的方式">以下三种方式是唯一能触发用户模式-&gt;内核模式的方式</h2>
<p>中断、异常或系统异常等事件导致用户程序向OS内核切换，触发：用户模式-&gt;内核模式，以下三种方式是唯一能触发的方式:<br>
程序请求操作系统服务，执行系统调用<br>
程序运行时发生异常(如发生程序性中断，或者目态执行特权指令)<br>
程序运行时发生并响应中断(一般是I/O中断)</p>
<h2 id="内核栈">内核栈</h2>
<p>内核栈是操作系统内核运行时使用的栈空间，用于保存内核函数调用的上下文信息，包括参数、局部变量、返回地址等。<strong>每个进程只有一个核心栈</strong><br>
用户栈运行在用户态（低特权级），而内核栈运行在内核态（高特权级）。硬件栈指针（如x86的ESP）在特权级切换时会自动指向当前进程的内核栈，避免用户程序通过栈操作破坏内核数据。这种隔离是硬件设计的要求。<br>
硬件栈指针唯一，但每个进程通过操作系统的动态管理拥有逻辑上独立的用户栈和内核栈，实际切换由CPU和内核协作完成</p>
<h2 id="中断与异常">中断与异常</h2>
<p>中断 vs 异常的本质区别<br>
特性	中断（Interrupt）	异常（Exception）<br>
触发方式	异步（由外部硬件设备触发，与CPU当前执行无关）	同步（由CPU执行指令时触发，如除零、缺页、非法指令）<br>
来源	外部硬件（如键盘、网卡、定时器）	CPU内部（指令执行错误、缺页、系统调用等）<br>
是否可预测	不可预测（随机发生）	可预测（特定指令必然触发）<br>
2. 处理时的上下文（用户态/内核态）<br>
上下文	中断	异常<br>
用户态 vs 内核态	全部在内核态处理（硬件直接触发CPU切换到内核态）	大部分在内核态，但缺页异常可能发生在用户态（如访问未映射的内存）<br>
是否需要进程参与	不依赖当前进程（如磁盘IO完成中断）	依赖当前进程（如缺页异常、除零错误）<br>
关键点：</p>
<p>缺页异常（Page Fault）是<strong>唯一可能在用户态触发的异常</strong>，因为用户程序访问无效内存时，CPU会先尝试处理（如加载页面），而不是直接杀死进程。</p>
<p>其他异常（如非法指令）一般直接终止进程或由内核处理。</p>
<ol start="3">
<li>
<p>处理逻辑的差异<br>
处理逻辑	中断	异常<br>
是否与当前进程相关	通常无关（如定时器中断、外设中断）	直接相关（如缺页异常影响当前进程的内存访问）<br>
能否被阻塞	不能（要求快速响应，不可睡眠）	可以阻塞（如缺页异常可能触发磁盘IO）<br>
嵌套性	允许嵌套（高优先级中断可打断低优先级中断）	通常单重（异常处理中一般不再触发同类异常）</p>
</li>
<li>
<p>相互打断的关系<br>
打断关系	中断	异常<br>
能否被中断打断	可以（高优先级中断可嵌套）	可以（异常处理中可能被中断插入）<br>
能否被异常打断	不能（中断处理时一般关闭异常）	通常不能（异常处理是同步的，不会自发触发）</p>
</li>
</ol>
<p>典型例子<br>
中断的例子：<br>
键盘输入、网卡收到数据、硬盘IO完成、定时器中断。<br>
异常的例子：<br>
缺页异常（访问未分配的内存）、除零错误、非法指令、系统调用（通过软中断/异常触发）</p>
<h2 id="中断or异常的触发">中断or异常的触发</h2>
<ol>
<li>中断/异常的触发<br>
中断：由外部硬件设备（如键盘、网卡、定时器）异步触发。</li>
</ol>
<p>异常：由CPU执行指令时同步触发（如缺页、除零、非法指令）。</p>
<ol start="2">
<li>中断/异常响应流程<br>
(1) 发现中断源，提出请求<br>
中断：CPU在每个指令周期末尾检查中断引脚（如x86的INTR/NMI），确认是否有硬件中断请求。<br>
异常：CPU在执行指令时直接检测到错误（如访问非法地址），主动触发异常。<br>
(2) 检查中断/异常是否被屏蔽<br>
(3) 优先级仲裁<br>
(4) 保存现场（上下文切换）<br>
CPU自动完成以下操作：<br>
保存PSW（程序状态字）：包括标志寄存器（如EFLAGS）、中断屏蔽状态等。<br>
保存PC（程序计数器）：即下一条待执行指令的地址。<br>
切换到内核态：将CPU模式从用户态切换到内核态（通过修改CS段寄存器等）。<br>
保存其他寄存器：部分架构可能需手动保存通用寄存器（如x86的中断处理程序需保存eax、ecx等）。<br>
(5) 跳转到处理程序<br>
CPU根据中断向量表（如x86的IDT）找到对应的中断/异常处理程序地址，并跳转执行。<br>
中断：调用外设驱动的中断服务例程（ISR）。<br>
异常：调用内核的异常处理程序（如缺页处理、终止进程等）。<br>
(6) 处理程序执行<br>
(7) 恢复现场<br>
(8) 返回原程序</li>
</ol>
<h2 id="中断屏蔽与中断优先级">中断屏蔽与中断优先级</h2>
<p>对比维度	中断屏蔽	中断优先级<br>
定义	通过软件或硬件手段暂时禁止CPU响应某些中断。	硬件或软件规定的中断响应顺序，高优先级中断可抢占低优先级。<br>
核心作用	选择性关闭中断，确保关键代码不被干扰。	决定中断处理的顺序，解决多个中断同时发生的竞争问题。<br>
目的	避免中断干扰（确保原子性、实时性）。	协调中断竞争（确定谁先被处理）。<br>
动态性	可随时通过软件动态启用/禁用。	优先级通常静态配置（启动时由硬件/OS设定）。<br>
影响范围	全局或部分中断失效。	仅影响响应顺序，不禁止中断。</p>
<h2 id="Linux内核处理流程">Linux内核处理流程</h2>
<p>用户态进程运行<br>
│<br>
├─ 中断触发 → 快中断 → 保存部分寄存器 → 快速处理 → ret_from_intr → 返回用户态<br>
│               │<br>
│               └─ 慢中断 → 保存全部寄存器 → 上半部处理 → 调度下半部（do_softirq）<br>
│                                               │<br>
├─ 异常触发 → 系统调用 → 保存现场 → 调用sys_call_table → ret_from_sys_call<br>
│               │                              │<br>
│               └─ 缺页异常 → 分配内存 → 重试指令<br>
│<br>
└─ 返回路径公共部分：<br>
├─ 检查TIF_NEED_RESCHED → 调用schedule()<br>
├─ 处理信号（do_signal）<br>
└─ 恢复用户态（iret）</p>
<p>上半部 vs 下半部：<br>
上半部：立即执行（如硬件应答），不可中断。<br>
下半部：延迟处理（如网络协议栈），可被新中断打断。</p>
<h2 id="进程的定义">进程的定义</h2>
<p>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动<br>
进程是操作系统进行资源分配和调度的一个独立单位<br>
一个进程包括五个实体部分，分别是：<br>
(OS管理运行程序的)数据结构P（就是进程控制块PCB）<br>
(运行程序的)内存代码C<br>
(运行程序的)内存数据D<br>
(运行程序的)通用寄存器信息R<br>
(OS控制程序执行的)程序状态字信息PSW</p>
<blockquote>
<p>PCB内容：​进程标识符（PID）​：唯一标识进程的数字或字符串。<br>
​进程状态：如运行（running）、就绪（ready）、阻塞（blocked）等。<br>
​CPU现场信息：通用寄存器、指令计数器（PC）、栈指针（SP）、程序状态字（PSW）等，用于进程切换时恢复执行现场。<br>
​资源清单：分配的内存、打开的文件、I/O设备等。<br>
​调度信息：优先级、等待事件（如等待I/O完成）。<br>
​同步与通信机制：信号量、消息队列等，用于进程间同步和通信。</p>
</blockquote>
<h2 id="四种状态转换">四种状态转换</h2>
<p>运行态→等待态：等待资源、I/O、信号量<br>
等待态→就绪态：资源满足、I/O结束、信号量完成<br>
运行态→就绪态：运行时间片到(倒计时到，不缺少其他东西，只缺少CPU，退回就绪态)、有更高优先权进程，低级调度问题<br>
以上四个状态转换，一个不能少，一个也不能多，其他的转换不存在的原因如下：<br>
没有就绪态到等待态:到等待态需要内核参与。<br>
没有等待态到运行态:等待的资源还没有就绪，无法进入运行态。</p>
<h2 id="七个状态">七个状态</h2>
<p>新添加的状态<br>
新建态:对应于进程被创建的状态，尚未进入就绪队列，创建进程的两个步骤<br>
为新进程分配所需资源和建立必要的管理信息<br>
设置进程为就绪态，等待被调度执行<br>
终止态:<br>
进程完成认为到达正常结束点<br>
出现无法克服的错误而异常终止<br>
操作系统及有终止权的进程所终止时所处的状态，处于终止态的进程不再被调度执行<br>
下一步就将被系统撤销，最终从系统中消失。<br>
挂起就绪态:表明进程具备运行条件，但目前在外存中，只有它被对换到内存才能调度执行。<br>
挂起等待态:表明进程正在等待某一个事件发生且在外存中。</p>
<blockquote>
<p>进程挂起的源头<br>
到目前为止:随着不断创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起，对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度，起到平滑系统负荷的目的；也可能系统出现故障，需要暂时挂起一些进程，以便故障消除后再接触挂起并恢复进程运行。<br>
进程挂起的原因是多种多样的。<br>
解决办法：剥夺某些进程的内存及其他资源，调入OS管理的对换区，不参加进程调度，待适当时候再调入内存、恢复资源、参与运行，这就是进程挂起<br>
挂起态与等待态有着本质区别<br>
进程挂起:没有任何资源<br>
进程等待:占有已申请到的资源处于等待</p>
</blockquote>
<h2 id="进程映像到底是个什么玩意">进程映像到底是个什么玩意</h2>
<p>进程映像是进程在某一时刻的完整快照，包括其代码、数据、状态以及执行环境</p>
<table>
<thead>
<tr>
<th><strong>组成部分</strong></th>
<th><strong>描述</strong></th>
<th><strong>存储位置</strong></th>
<th><strong>是否共享</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进程控制块（PCB, Process Control Block）</strong></td>
<td>内核数据结构，存储进程的标识、状态、资源占用、调度信息等（如 <code>task_struct</code> in Linux）。</td>
<td>内核内存</td>
<td>否（每个进程独立）</td>
</tr>
<tr>
<td><strong>进程程序块（Text Segment / Code Segment）</strong></td>
<td>可执行代码（机器指令），通常是只读的（如程序的 <code>.text</code> 段）。</td>
<td>内存（代码区）</td>
<td>是（多个进程可共享同一代码，如 <code>fork()</code> 后的父子进程）</td>
</tr>
<tr>
<td><strong>进程数据块（Data Segment）</strong></td>
<td>包含全局变量、静态变量（<code>.data</code> 段）、堆（<code>heap</code>，动态分配内存）、栈（<code>stack</code>，局部变量和函数调用链）。</td>
<td>内存（数据区）</td>
<td>否（私有地址空间）</td>
</tr>
<tr>
<td><strong>进程核心栈（Kernel Stack）</strong></td>
<td>进程在内核态执行时使用的栈（如系统调用、中断处理），存储函数调用帧、局部变量等。</td>
<td>内核内存</td>
<td>否（每个进程独立）</td>
</tr>
<tr>
<td><strong>环境变量和命令行参数</strong></td>
<td>进程启动时传递的参数（<code>argv</code>）和环境变量（<code>envp</code>）。</td>
<td>用户栈附近的内存区域</td>
<td>否</td>
</tr>
<tr>
<td><strong>打开的文件描述符表</strong></td>
<td>记录进程打开的文件、套接字等资源（如 <code>fd_table</code>）。</td>
<td>内核内存</td>
<td>否（但子进程可继承）</td>
</tr>
<tr>
<td><strong>寄存器上下文（Register Context）</strong></td>
<td>进程被切换时保存的 CPU 寄存器值（如 <code>eax</code>、<code>eip</code>、<code>esp</code>）。</td>
<td>PCB 或内核栈</td>
<td>否</td>
</tr>
<tr>
<td>后面三个不是考试的内容</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="PCB内容">PCB内容</h2>
<p>10.2.1. 标识信息<br>
用于存放唯一标识该进程的信息</p>
<p>系统分配的标识号<br>
系统分配的进程组标识号<br>
用户定义的进程名<br>
用户定义的进程组名<br>
10.2.2. 现场信息<br>
用于存放该进程运行时的处理器现场信息</p>
<p>用户可见寄存器内容：数据寄存器、地址寄存器<br>
控制与状态寄存器内容：PC、IR、PSW<br>
栈指针内容：核心栈与用户栈指针<br>
10.2.3. 控制信息<br>
用于存放与管理、调度进程相关的信息</p>
<p>调度相关信息：状态、等待事件/原因、优先级<br>
进程组成信息：代码/数据地址、外存映像地址<br>
队列指引元：进程队列指针、父子兄弟进程指针<br>
通信相关信息：消息队列、信号量、锁<br>
进程特权信息：如内存访问权限、处理器特权<br>
处理器使用信息：占用的处理器、时间片、处理器使用时间/已执行总时间、记账信息<br>
资源清单信息：如正占有的资源、已使用的资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 标识信息</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                      <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="type">pid_t</span> pgrp;                     <span class="comment">// 进程组ID</span></span><br><span class="line">    <span class="type">char</span> comm[<span class="number">16</span>];                  <span class="comment">// 进程名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现场信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">thread</span>;</span>         <span class="comment">// 寄存器上下文</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> kstack;           <span class="comment">// 内核栈指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制信息</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state;            <span class="comment">// 进程状态</span></span><br><span class="line">    <span class="type">int</span> prio;                       <span class="comment">// 优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>           <span class="comment">// 内存管理（代码/数据地址）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>     <span class="comment">// 文件描述符表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>      <span class="comment">// 子进程链表</span></span><br><span class="line">    u64 utime, stime;               <span class="comment">// CPU 时间统计</span></span><br><span class="line">    <span class="comment">// ... 其他字段（信号处理、命名空间等）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="原语">原语</h2>
<p>原语是由若干条指令构成的完成某种特定功能的程序，执行上具有不可分割性(保证对核心资源的访问是正确的，原语涉及到的资源都是共享核心资源，只能是唯一的)，进入原语区间，立刻关闭中断完成，然后再开中断响应。</p>
<h2 id="处理器模式切换与上下文状态">处理器模式切换与上下文状态</h2>
<ol>
<li>用户空间 - 进程上下文<br>
场景：普通应用程序在用户态运行<br>
特点：<br>
资源访问：受限，不能执行特权指令<br>
调度：可以被抢占或主动让出CP</li>
<li>内核空间 - 进程上下文<br>
场景：内核代表某个进程在内核态执行（如处理系统调用）<br>
特点：<br>
特权级别：运行在内核态（Ring 0/x86）<br>
内存访问：可以访问全部内存空间<br>
栈使用：使用核心栈（每个进程有独立的内核栈）<br>
关联性：与特定进程关联，可以访问进程的task_struct<br>
可调度性：可以被抢占（现代内核支持内核态抢占）<br>
典型情况：系统调用执行、某些类型的异常处理</li>
<li>内核空间 - 中断上下文<br>
场景：硬件中断触发的中断服务例程(ISR)执行<br>
特点：<br>
触发方式：由硬件中断异步触发<br>
关联性：<strong>不与任何特定进程关联</strong><br>
栈使用：可能使用中断栈或当前进程的内核栈（架构依赖）<br>
限制：<br>
不能睡眠或调用可能引起调度的函数<br>
不能访问用户空间内存<br>
应该尽快完成处理<br>
典型情况：硬件中断处理（网络包到达、磁盘IO完成等）</li>
<li>内核线程<br>
场景：纯内核线程的执行（如kswapd、kworker等）<br>
特点：<br>
特权级别：内核态<br>
内存访问：只有内核空间，没有用户空间映射<br>
栈使用：使用独立的内核栈<br>
调度：像普通进程一样被调度<br>
用途：执行<strong>后台维护任务</strong>，可以执行需要睡眠的操作<br>
实际例子<br>
用户进程调用read()：</li>
</ol>
<p>开始：用户态进程上下文</p>
<p>执行syscall指令→切换到内核进程上下文</p>
<p>可能需要等待磁盘→进程睡眠</p>
<p>磁盘中断到达→中断上下文处理</p>
<p>中断处理完成后唤醒进程→回到内核进程上下文</p>
<p>系统调用返回→回到用户进程上下文</p>
<p>内存回收：</p>
<p>kswapd内核线程（内核线程上下文）定期运行</p>
<p>当内存不足时触发缺页异常→进入内核进程上下文</p>
<p>可能需要从磁盘换入页面→发送IO请求</p>
<p>磁盘中断到达→中断上下文处理完成IO</p>
<p>唤醒等待进程</p>
<p><img src="image.png" alt="alt text"></p>
<h2 id="自问：linux中task-struct里面都有什么？尽量完整的给出？他是如何区分进程和线程的？">自问：linux中task_struct里面都有什么？尽量完整的给出？他是如何区分进程和线程的？</h2>
<p>​1. 进程/线程标识<br>
​<strong>pid_t pid</strong>：进程 ID（唯一标识）。<br>
​<strong>pid_t tgid</strong>：线程组 ID（同一进程的线程共享 tgid，主线程的 pid == tgid）。<br>
​<em><em>struct task_struct <em>group_leader</em></em>：线程组的领头线程（主线程）。<br>
​</em><em>struct list_head thread_group</em>*：同一线程组的所有线程链表。<br>
​2. 进程状态<br>
​<strong>volatile long state</strong>：进程状态，取值包括：<br>
TASK_RUNNING（运行/就绪）<br>
TASK_INTERRUPTIBLE（可中断睡眠）<br>
TASK_UNINTERRUPTIBLE（不可中断睡眠）<br>
TASK_STOPPED（暂停）<br>
EXIT_ZOMBIE（僵尸状态）。<br>
​3. 调度信息<br>
​<strong>int prio, static_prio, normal_prio</strong>：优先级（静态、动态）。<br>
​<strong>unsigned int rt_priority</strong>：实时进程优先级。<br>
​<strong>struct sched_entity se</strong>：CFS 调度实体（时间片、权重等）。<br>
​<em><em>struct sched_class <em>sched_class</em></em>：调度策略（SCHED_FIFO、SCHED_RR、SCHED_OTHER）。<br>
​4. 内存管理<br>
​</em><em>struct mm_struct <em>mm</em></em>：进程内存描述符（代码段、堆栈、页表等）。<br>
​<em><em>struct mm_struct <em>active_mm</em></em>：活跃内存（内核线程可能借用用户进程的 mm）。<br>
​</em><em>unsigned long stack</em>*：内核栈指针。<br>
​5. 文件系统<br>
​<em><em>struct files_struct <em>files</em></em>：打开的文件描述符表。<br>
​</em><em>struct fs_struct <em>fs</em></em>：文件系统信息（如当前工作目录）。<br>
​6. 信号处理<br>
​<em><em>struct signal_struct <em>signal</em></em>：信号描述符。<br>
​</em><em>sigset_t blocked</em>*：阻塞的信号掩码。<br>
​<strong>struct sigpending pending</strong>：待处理的信号队列。<br>
​7. 进程关系<br>
​<em><em>struct task_struct <em>parent</em></em>：父进程。<br>
​</em><em>struct list_head children</em>*：子进程链表。<br>
​<strong>struct list_head sibling</strong>：兄弟进程链表。<br>
​8. 其他关键字段<br>
​<strong>struct thread_struct thread</strong>：CPU 寄存器状态（上下文切换时保存）。<br>
​<em><em>struct exec_domain <em>exec_domain</em></em>：可执行文件格式（如 ELF）。<br>
​</em><em>struct ptrace_context <em>ptrace</em></em>：调试跟踪信息。<br>
​如何区分进程和线程？<br>
Linux 内核不严格区分进程和线程，均用 task_struct 表示，区别在于资源共享方式：<br>
​进程：<br>
独立的 mm_struct（内存空间）。<br>
独立的 files_struct（文件描述符）。<br>
独立的 signal_struct（信号处理）。<br>
通过 fork() 创建，默认不共享资源。<br>
​线程：<br>
共享父进程的 mm_struct、files_struct、signal_struct。<br>
通过 clone() 创建，指定标志如 CLONE_VM（共享内存）、CLONE_FILES（共享文件）。<br>
同一线程组的线程 tgid 相同。</p>
<h2 id="线程共享的和独立的资源">线程共享的和独立的资源</h2>
<h3 id="线程共享的资源">线程共享的资源</h3>
<p>同一进程中的所有线程<strong>完全共享</strong>以下资源：</p>
<ol>
<li><strong>内存地址空间</strong>（代码段、数据段、堆、共享库等）
<ul>
<li>一个线程修改全局变量会立即影响其他线程</li>
<li>动态分配的内存(malloc/new)对所有线程可见</li>
</ul>
</li>
<li><strong>文件描述符表</strong>
<ul>
<li>一个线程打开的文件其他线程可以直接使用</li>
</ul>
</li>
<li><strong>信号处理程序</strong>
<ul>
<li>信号处理函数是进程级别的设置</li>
</ul>
</li>
<li><strong>进程属性</strong>
<ul>
<li>用户ID、组ID、工作目录等</li>
</ul>
</li>
</ol>
<h3 id="线程独立的资源">线程独立的资源</h3>
<h3 id="1-线程执行状态">1. 线程执行状态</h3>
<h3 id="2-线程上下文（保护现场）">2. 线程上下文（保护现场）</h3>
<h3 id="3-独立的程序计数器（PC）">3. 独立的程序计数器（PC）</h3>
<h3 id="4-执行堆栈">4. 执行堆栈</h3>
<h3 id="5-静态存储区的局部变量">5. 静态存储区的局部变量</h3>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __thread <span class="type">int</span> tls_var;  <span class="comment">// 每个线程有独立副本</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不同于普通的静态变量（所有线程共享）</li>
</ul>
<h3 id="6-线程控制块-TCB">6. 线程控制块(TCB)</h3>
<h3 id="实际内存布局示例">实际内存布局示例</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进程地址空间</span><br><span class="line">├── 代码段 (所有线程共享)</span><br><span class="line">├── 数据段 (全局变量，共享)</span><br><span class="line">├── 堆 (动态分配内存，共享)</span><br><span class="line">├── 共享库 (共享)</span><br><span class="line">├── 线程1栈 (私有)</span><br><span class="line">├── 线程2栈 (私有)</span><br><span class="line">├── ...</span><br><span class="line">└── 线程局部存储区 (TLS，每个线程有独立副本)</span><br></pre></td></tr></table></figure>
<p>辨析：在单线程进程中：进程栈就是线程栈，两者是同一个栈结构<br>
在多线程进程中：主线程的栈就是传统意义上的&quot;进程栈&quot;，其他线程有自己的独立栈<br>
在Linux中：<br>
主线程栈通常位于地址空间的高地址区域（如x86_64上约在0x7ffffffff000）<br>
新线程栈通过mmap()分配（默认约8MB，含保护页）</p>
<h3 id="注意：内核级线程是内核调度的基本单元，因此同一进程的多个线程可被分配到不同CPU核心并行执行。">注意：内核级线程是内核调度的基本单元，因此同一进程的多个线程可被分配到不同CPU核心并行执行。</h3>
<p>维度	进程（资源）	线程（执行）<br>
管理内容	内存、文件、权限等静态资源	CPU时间片、执行状态等动态资源<br>
操作者	内核资源管理器	内核调度器<br>
共享性	进程间资源默认隔离	同一进程的线程共享所有资源<br>
您提到的这些线程操作实际上是传统操作系统理论中对线程状态转换的抽象描述，可能来自教材或特定系统的术语。下面我将结合现代操作系统的通用实现，为您逐一解释这些操作的含义及其与线程状态的关系：</p>
<h2 id="线程操作与状态转换对应关系">线程操作与状态转换对应关系</h2>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>触发动作</strong></th>
<th><strong>状态变化</strong></th>
<th><strong>现代系统对应操作</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>孵化</td>
<td>创建新线程</td>
<td>无→就绪</td>
<td><code>pthread_create()</code></td>
</tr>
<tr>
<td>封锁</td>
<td>线程主动/被动停止执行</td>
<td>运行→等待（阻塞）</td>
<td><code>pthread_mutex_lock()</code>/<code>read()</code></td>
</tr>
<tr>
<td>活化</td>
<td>唤醒被阻塞的线程</td>
<td>等待→就绪</td>
<td><code>pthread_cond_signal()</code></td>
</tr>
<tr>
<td>剥夺</td>
<td>强制收回线程CPU使用权</td>
<td>运行→就绪</td>
<td>时间片耗尽（内核调度）</td>
</tr>
<tr>
<td>指派</td>
<td>分配CPU给线程</td>
<td>就绪→运行</td>
<td>内核调度器选择线程</td>
</tr>
<tr>
<td>结束</td>
<td>线程执行完毕或被终止</td>
<td>运行/等待→终止</td>
<td><code>pthread_exit()</code></td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><strong>为何没有“挂起”</strong>：<br>
挂起（Suspend）通常涉及将线程/进程资源换出内存（与存储设备交互），属于<strong>资源管理</strong>范畴。线程作为执行单位，其状态仅描述CPU调度行为，故不包含挂起。</p>
</li>
<li>
<p><strong>现代系统的差异</strong>：</p>
<ul>
<li>术语差异：现代POSIX线程库可能不使用这些传统术语，但底层原理一致。</li>
<li>扩展状态：实际系统可能有更细的状态（如<code>TASK_INTERRUPTIBLE</code>）。</li>
</ul>
</li>
<li>
<p><strong>用户级线程的特殊性</strong>：<br>
若线程在用户空间管理（如协程），则“剥夺”“指派”由用户态调度器完成，不经过内核。</p>
</li>
</ol>
<h1>KLT与ULT</h1>
<h2 id="内核级线程和用户级线程的本质区别">内核级线程和用户级线程的本质区别</h2>
<ol>
<li><strong>管理主体不同</strong>：内核级线程由操作系统直接管理，用户级线程由用户态线程库管理。</li>
<li><strong>调度方式不同</strong>：内核级线程可被独立调度（支持多核并行），用户级线程由进程统一调度（阻塞会影响整个进程）。</li>
<li><strong>性能开销不同</strong>：内核级线程切换需内核介入（开销大），用户级线程切换在用户态完成（高效但无法跨核）。</li>
</ol>
<h2 id="Linux选择1-1模型的核心逻辑是：">Linux选择1:1模型的核心逻辑是：</h2>
<p>用内核的复杂性换取开发者/硬件的效率最大化。这种设计使得从嵌入式设备到超级计算机都能获得一致的线程语义，同时避免M:N模型的调试噩梦——“幽灵式卡顿”（即用户态与内核态调度器视图不一致导致的问题）。</p>
<h2 id="用户态线程是轻量级线程（仍依赖OS），协程是用户态更彻底的轻量化并发（完全自主调度）。">用户态线程是轻量级线程（仍依赖OS），协程是用户态更彻底的轻量化并发（完全自主调度）。</h2>
<h2 id="内核级线程-KLT-Kernel-Level-Threads">内核级线程 KLT, Kernel-Level Threads</h2>
<p>线程管理的所有工作由OS内核来做，并提供了一个应用程序设计接口API，供开发者使用KLT，<br>
创建时：内核为其创建进程和一个基线程，线程实行过程中通过内核的创建线程原语来创建其他线程。<br>
OS直接调度KLT，KLT用于解决物理并行性问题，内核可以感知到所有的内核级线程，可以控制器其数据结构，内核调度在线程的基础上进行。</p>
<h2 id="用户级线程ULT-User-Level-Threads">用户级线程ULT, User-Level Threads</h2>
<p>用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境。任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行<br>
线程管理的所有工作都由应用程序完成，内核没有感知到线程的存在，内核感知到的单位是进程。</p>
<p>KLT的三态模型，由系统调度负责<br>
ULT的三态模型，由用户调度负责<br>
活跃态的ULT代表绑定KLT的三态</p>
<blockquote>
<p>当ULT处于 ​活跃态 时，意味着它 ​绑定到了一个KLT，此时该ULT的状态 ​完全由KLT的状态决定：<br>
若KLT被内核调度为 ​运行态 → ULT表现为“正在执行”。<br>
若KLT被内核置为 ​阻塞态​（如发起阻塞式系统调用）→ 绑定的ULT也被迫阻塞（即使ULT本身未调用阻塞操作）。<br>
活跃态的ULT运行时可激活用户调度，非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT</p>
</blockquote>
<h2 id="linux-pthread混合模型">linux pthread混合模型</h2>
<p>为什么说它是混合模型？<br>
特性	用户级线程(ULT)特点	内核级线程(KLT)特点	Linux pthread实现<br>
线程创建/销毁	完全在用户空间	需要内核介入	用户API+内核支持<br>
调度实体	内核只看到进程	内核看到每个线程	内核看到每个线程<br>
上下文切换	用户空间完成	内核完成	内核完成<br>
多核并行	难以实现	天然支持	完全支持<br>
阻塞影响	整个进程阻塞	仅阻塞单个线程	仅阻塞单个线程<br>
线程局部存储	用户库实现	需要内核支持	两者协作实现</p>
<h2 id="自问：进程间通信方式AND线程">自问：进程间通信方式AND线程</h2>
<h1>进程间通信方式性能对比与数据验证</h1>
<p>以下是主要进程间通信(IPC)方式的性能对比，基于实际测试和文献数据，并补充了共享内存等更多通信途径的详细信息。</p>
<h2 id="进程间通信方式性能对比表">进程间通信方式性能对比表</h2>
<p>当然！我会帮你在原有的表格中加入“文件映射”这一项，并提供对应的详细信息。</p>
<hr>
<table>
<thead>
<tr>
<th>通信方式</th>
<th>数据传递路径</th>
<th>典型延迟</th>
<th>带宽</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程共享内存</strong></td>
<td>直接CPU缓存访问</td>
<td>10-100 ns</td>
<td>10-100 GB/s</td>
<td>同一进程内线程间通信</td>
</tr>
<tr>
<td><strong>进程共享内存</strong></td>
<td>内存映射文件/区域 → 用户态</td>
<td>100-500 ns</td>
<td>1-10 GB/s</td>
<td>需要高频数据交换的进程间通信</td>
</tr>
<tr>
<td><strong>管道(pipe)</strong></td>
<td>内核缓冲区拷贝 → 用户态</td>
<td>1-10 μs</td>
<td>100-500 MB/s</td>
<td>父子进程间顺序通信</td>
</tr>
<tr>
<td><strong>命名管道(FIFO)</strong></td>
<td>内核缓冲区拷贝 → 用户态</td>
<td>2-15 μs</td>
<td>100-500 MB/s</td>
<td>任意进程间顺序通信</td>
</tr>
<tr>
<td><strong>消息队列</strong></td>
<td>内核内存分配 + 两次拷贝</td>
<td>10-50 μs</td>
<td>50-200 MB/s</td>
<td>结构化消息传递</td>
</tr>
<tr>
<td><strong>Unix域套接字</strong></td>
<td>内核缓冲区拷贝 → 用户态</td>
<td>5-20 μs</td>
<td>200-800 MB/s</td>
<td>本地高性能IPC</td>
</tr>
<tr>
<td><strong>TCP套接字</strong></td>
<td>网络协议栈处理 → 内核缓冲区 → 用户态</td>
<td>50-200 μs</td>
<td>10-100 MB/s</td>
<td>跨网络通信</td>
</tr>
<tr>
<td><strong>信号</strong></td>
<td>内核信号队列 → 用户态信号处理</td>
<td>1-10 μs</td>
<td>-</td>
<td>简单事件通知</td>
</tr>
<tr>
<td><strong>文件映射（mmap）</strong></td>
<td>文件在磁盘存储 → 内存映射区域（用户态）映射到虚拟地址空间</td>
<td>100-500 ns</td>
<td>1-10 GB/s</td>
<td>大文件访问、频繁读写、跨进程共享</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="“文件映射（mmap）”">“文件映射（mmap）”</h3>
<p>映射过程：</p>
<p>进程请求将文件映射到其虚拟地址空间（调用mmap()）。<br>
操作系统在虚拟地址空间中为这块区域建立映射关系，标记为“已映射”。<br>
数据访问：</p>
<p>进程直接访问映射区域，就像访问普通内存一样。<br>
读取或修改映射区域中的数据，实际上是在操作内存缓存（页缓存）中的内容。<br>
数据同步：</p>
<p>当进程修改映射区域中的数据时，操作系统会在后台将更改同步到磁盘上的文件（如果映射是可写的）。<br>
反之，文件内容也会在磁盘上更新。<br>
数据传递路径总结：</p>
<p>用户空间内存（映射区域）&lt;→（由操作系统管理）&lt;→ 磁盘文件**<br>
这里没有显式的“拷贝”操作（除初始化映射时），是直接访问文件的内容。</p>
<h3 id="与进程共享内存对比">与进程共享内存对比</h3>
<table>
<thead>
<tr>
<th>方面</th>
<th>文件映射（mmap）</th>
<th>共享内存</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>依赖</strong></td>
<td>磁盘I/O，页缓存</td>
<td>纯内存，无磁盘依赖</td>
</tr>
<tr>
<td><strong>延迟</strong></td>
<td>较高（页面缺失，磁盘访问）</td>
<td>低（直接内存访问）</td>
</tr>
<tr>
<td><strong>操作复杂性</strong></td>
<td>依赖操作系统的页管理和同步策略</td>
<td>直接内存操作，简单快速</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>大文件访问、需要持久化的共享数据</td>
<td>高频率、低延迟的进程间通信</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="1-线程共享内存">1. <strong>线程共享内存</strong></h3>
<ul>
<li>由于它们属于同一进程，多个线程可以直接读取和写入相同的内存地址。</li>
<li>CPU的缓存（如L1、L2、L3）也会帮助加快访问速度。</li>
<li>不需要经过操作系统或内核的中转，几乎是“直接”访问。</li>
</ul>
<h3 id="2-进程共享内存">2. <strong>进程共享内存</strong></h3>
<p><strong>数据传递路径：</strong></p>
<ul>
<li>通过<strong>内存映射文件或区域</strong>（比如<code>mmap</code>）映射到两个进程的用户空间内存中。</li>
<li>进程可以直接读写这块共享内存区域。<br>
<strong>详细说明：</strong></li>
<li>操作系统创建一块共享内存区域，并映射到两个或多个进程的虚拟地址空间中。</li>
<li>进程通过访问自己的虚拟地址，间接地读写共享内存。</li>
<li>这里没有数据在内核和用户空间之间复制，除了初始化映射时。</li>
</ul>
<h3 id="3-管道-pipe">3. <strong>管道(pipe)</strong></h3>
<p><strong>数据传递路径：</strong></p>
<ul>
<li>一个进程将数据写入内核缓冲区（由内核管理）。</li>
<li>另一个进程从这个缓冲区读取数据。</li>
</ul>
<p><strong>详细说明：</strong></p>
<ul>
<li>写入方将数据写入管道的内核缓冲区（拷贝操作：用户空间→内核空间）。</li>
<li>读取方从缓冲区读取数据（拷贝：内核空间→用户空间）。</li>
<li>这是<strong>内核缓冲区</strong>扮演中介角色。</li>
</ul>
<h3 id="4-命名管道（FIFOs）">4. <strong>命名管道（FIFOs）</strong></h3>
<p><strong>数据传递路径：</strong></p>
<ul>
<li>类似普通管道，但可以在<strong>任意两个进程之间</strong>（不一定父子关系）。</li>
<li>数据写入到内核缓冲区，然后由另一端读取。</li>
</ul>
<p><strong>详细说明：</strong></p>
<ul>
<li>进程A写入数据到FIFO的内核缓冲区（用户空间→内核空间拷贝）。</li>
<li>进程B从缓冲区读取数据（内核空间→用户空间拷贝）。</li>
<li>这种方式允许不同进程之间通信。</li>
</ul>
<h3 id="5-消息队列">5. <strong>消息队列</strong></h3>
<p><strong>数据传递路径：</strong></p>
<ul>
<li>由内核管理一块特殊的内存区域，用于存储消息。</li>
<li>进程将消息放入队列（两次拷贝：用户空间→内核空间，内核空间→用户空间），</li>
<li>其他进程从队列中取出消息。</li>
<li>结构化消息传递，适合传递有格式的数据。</li>
</ul>
<h3 id="6-Unix域套接字">6. <strong>Unix域套接字</strong></h3>
<p><strong>数据传递路径：</strong></p>
<ul>
<li>通过内核缓冲区传输数据。</li>
<li>数据从发送端的用户空间拷贝到内核缓冲区，</li>
<li>接收端再从内核缓冲区拷贝到用户空间。</li>
</ul>
<h3 id="7-TCP套接字">7. <strong>TCP套接字</strong></h3>
<p><strong>数据传递路径：</strong></p>
<ul>
<li>经过网络协议栈处理（TCP/IP协议）</li>
<li>数据从用户空间拷贝到内核缓冲区，</li>
<li>经过网络传输到远端，</li>
<li>另一端的内核缓冲区再拷贝到远端用户空间。</li>
<li>数据在用户空间和内核空间之间有多次拷贝，网络传输有一定延迟。</li>
</ul>
<h3 id="8-信号">8. <strong>信号</strong></h3>
<p><strong>数据传递路径：</strong></p>
<ul>
<li>内核将信号放入信号队列（由内核管理），</li>
<li>用户空间的信号处理程序在适当时被调用。</li>
</ul>
<p><strong>详细说明：</strong></p>
<ul>
<li>信号是一种异步事件通知机制。</li>
<li>内核通知进程某个事件发生（如中断、定时器），通过信号队列。</li>
<li>用户程序在信号处理函数中响应。</li>
</ul>
<h2 id="Jacketing技术">Jacketing技术</h2>
<p>把阻塞式系统调用改造成非阻塞式的:解决一个ULT的阻塞导致整个进程阻塞，避免进程因此从运行态→阻塞态，如此的频繁切换会带来比较大的开销。<br>
当线程陷入系统调用时，执行Jacketing程序。<br>
由Jacketing程序来检查资源使用情况，以决定是否执行进程切换或传递控制权给另一个线程<br>
Jacketing 技术通过用户态拦截系统调用，模拟非阻塞行为（如立即返回 <code>EAGAIN</code>），并在后台异步检查资源就绪后补发真实调用，从而避免线程阻塞和进程切换的开销。其核心是<strong>用户态欺骗 + 异步轮询 + 延迟执行</strong>，实现阻塞操作的非阻塞化。</p>
<h2 id="自问：java线程池">自问：java线程池</h2>
<p>Java线程池通过<strong>复用内核级线程（KLT）<strong>和</strong>任务队列</strong>协调逻辑与物理并行性：</p>
<ol>
<li><strong>物理并行性</strong>：固定数量的KLT（如<code>newFixedThreadPool(4)</code>）直接执行任务，匹配CPU核心数以最大化计算加速（如矩阵运算）。</li>
<li><strong>逻辑并行性</strong>：超额任务（如10万HTTP请求）暂存于阻塞队列（如<code>LinkedBlockingQueue</code>），由KLT异步处理，实现高并发。</li>
<li><strong>动态调节</strong>：参数<code>corePoolSize</code>（常驻KLT）、<code>maxPoolSize</code>（突发扩容）和<code>workQueue</code>（队列容量）平衡资源开销与吞吐量。例如，<code>newWorkStealingPool()</code>基于ForkJoin框架自动优化并行任务调度。</li>
</ol>
<p><strong>优势</strong>：避免线程频繁创建/销毁的开销，通过队列解耦任务提交与执行，同时支持计算密集型（物理并行）和IO密集型（逻辑并发）场景。<br>
I/O密集型任务（HTTP请求多数时间在等待网络响应）<br>
线程阻塞时，线程池会自动调度其他任务</p>
<h1>处理器调度</h1>
<p><img src="image-1.png" alt="alt text"><br>
<img src="image-2.png" alt="alt text"><br>
<img src="image-3.png" alt="alt text"><br>
FCFS (先来先服务) 非抢占<br>
RR (时间片轮转) 抢占<br>
SPN (最短进程优先) 非抢占，真正操作系统没有办法使用<br>
SRT (最短剩余时间优先) 抢占，真正操作系统没有办法使用<br>
HRRF (最高响应比优先) 非抢占，真正操作系统没有办法使用<br>
Feedback (多级反馈调度) 抢占<br>
<img src="image-4.png" alt="alt text"></p>
<h3 id="SPN是一种非抢占式调度，会选择处理时间最短的进程，短进程将会越过长进程，优先获得调度，又称为SJF">SPN是一种非抢占式调度，会选择处理时间最短的进程，短进程将会越过长进程，优先获得调度，又称为SJF</h3>
<p>问题:<br>
需要预知作业所需的CPU运行时间<br>
忽略了作业的等待时间：只要持续不断地提供更短的进程，长进程就有可能饿死，同样也会服务不到。<br>
分时、实时处理仍然不理想。</p>
<h3 id="SRT，Shortest-Remaining-Time，最短剩余时间优先">SRT，Shortest Remaining Time，最短剩余时间优先</h3>
<p>SRT是一种抢占式调度，调度器总是选择预期剩余时间更短的进程<br>
当一个新进程加入就绪队列，他可能比当前运行的进程具有更短的剩余时间，只要新进程进入就绪队列，调度器就可能抢占当前正在运行的进程<br>
<img src="image-5.png" alt=""></p>
<h3 id="RR-时间片轮转调度算法">RR(时间片轮转调度算法)</h3>
<p>本质也是先来先服务，但是要按照时间片来进行调度<br>
<img src="image-6.png" alt="alt text"><br>
<img src="image-7.png" alt="alt text"><br>
<img src="image-8.png" alt="alt text"><br>
<img src="image-9.png" alt="alt text"><br>
<img src="image-10.png" alt="alt text"><br>
<img src="image-11.png" alt="alt text"><br>
<img src="image-12.png" alt="alt text"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">文件管理笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:25:29" itemprop="dateCreated datePublished" datetime="2025-06-23T12:25:29+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="用户打开文件表、系统打开文件表和主存活动inode表的作用及其相互关系：">用户打开文件表、系统打开文件表和主存活动inode表的作用及其相互关系：</h2>
<hr>
<h3 id="1-用户打开文件表（文件描述符表）">1. <strong>用户打开文件表（文件描述符表）</strong></h3>
<ul>
<li><strong>位置</strong>：位于每个进程的PCB（进程控制块）中，是一个名为<code>files_struct</code>的结构。</li>
<li><strong>作用</strong>：
<ul>
<li>每个进程独立维护自己的打开文件列表，通过**文件描述符（fd）**来索引。</li>
<li><code>fd</code>是一个整数（如0、1、2分别对应标准输入、输出、错误），是进程访问文件的句柄。</li>
</ul>
</li>
<li><strong>表项内容</strong>：
<ul>
<li>每个表项存储一个指针（<code>fp</code>），指向<strong>系统打开文件表</strong>中的某个表项（<code>file</code>结构）。</li>
</ul>
</li>
<li><strong>特点</strong>：
<ul>
<li>进程通过<code>fd</code>操作文件时，内核会通过<code>fp</code>找到系统级文件信息。</li>
<li>不同进程的<code>fd</code>可能指向同一个系统打开文件表项（例如父子进程继承文件描述符）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-系统打开文件表（file-struct）">2. <strong>系统打开文件表（file_struct）</strong></h3>
<ul>
<li><strong>位置</strong>：内核内存区，全局共享，最多256项（具体数量取决于内核配置）。</li>
<li><strong>作用</strong>：
<ul>
<li>解决多进程共享文件或同一文件被多次打开的问题。</li>
<li>每次打开文件（即使同一文件）会创建一个独立的<code>file</code>结构，记录<strong>当前操作的上下文</strong>。</li>
</ul>
</li>
<li><strong>表项内容</strong>：
<ul>
<li>文件当前偏移量（读写位置）。</li>
<li>文件访问模式（读、写、追加等）。</li>
<li>指向<strong>主存活动inode</strong>的指针。</li>
</ul>
</li>
<li><strong>关键特性</strong>：
<ul>
<li><strong>多file对应一个inode</strong>：同一文件被多次打开时，每个<code>file</code>有自己的偏移量，但共享同一个inode。</li>
<li><strong>父子进程共享</strong>：子进程继承父进程的<code>file</code>结构，共享偏移量（除非显式调用<code>dup</code>或<code>fork</code>后独立操作）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-主存活动inode表">3. <strong>主存活动inode表</strong></h3>
<ul>
<li><strong>位置</strong>：内核内存区，缓存频繁访问的磁盘inode。</li>
<li><strong>作用</strong>：
<ul>
<li>避免每次文件操作都从磁盘读取inode，提升性能。</li>
<li>维护文件的<strong>元数据</strong>（如权限、大小、磁盘块位置等）。</li>
</ul>
</li>
<li><strong>表项内容</strong>：
<ul>
<li>磁盘inode的完整信息（如UID、GID、大小、时间戳等）。</li>
<li>文件数据块的磁盘地址。</li>
<li>引用计数（被多少个<code>file</code>结构引用）。</li>
</ul>
</li>
<li><strong>关键特性</strong>：
<ul>
<li><strong>动态加载</strong>：当文件被打开时，其inode从磁盘调入内存；引用计数为0时可能被回收。</li>
<li><strong>共享与同步</strong>：多个<code>file</code>可能指向同一个inode，修改inode会反映到所有关联的<code>file</code>（如文件大小变化）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三者的协作流程">三者的协作流程</h3>
<ol>
<li>
<p><strong>进程打开文件</strong>：</p>
<ul>
<li>内核在<strong>主存活动inode表</strong>中查找或加载文件的inode。</li>
<li>创建<strong>系统打开文件表</strong>项（<code>file</code>结构），初始化偏移量等，并指向inode。</li>
<li>在进程的<strong>用户打开文件表</strong>中分配一个<code>fd</code>，指向对应的<code>file</code>结构。</li>
</ul>
</li>
<li>
<p><strong>进程读写文件</strong>：</p>
<ul>
<li>通过<code>fd</code>找到<code>file</code>结构，获取当前偏移量。</li>
<li>通过<code>file</code>找到inode，进而定位磁盘数据块。</li>
<li>更新<code>file</code>中的偏移量（除非是<code>O_APPEND</code>模式，此时直接同步inode中的文件大小）。</li>
</ul>
</li>
<li>
<p><strong>文件关闭</strong>：</p>
<ul>
<li>释放<code>fd</code>，减少<code>file</code>和inode的引用计数。</li>
<li>若inode引用计数为0，可能写回磁盘并释放内存。</li>
</ul>
</li>
</ol>
<hr>
<p>以下是文件创建过程 <code>create(&quot;path&quot;, 0775)</code> 的详细步骤解析，结合文件系统的磁盘和内存结构：</p>
<hr>
<h3 id="1-目录检索与inode分配"><strong>1. 目录检索与inode分配</strong></h3>
<ul>
<li><strong>目录检索</strong>：
<ul>
<li>内核解析路径<code>&quot;path&quot;</code>，逐级查找目录项（如<code>/</code> → <code>path</code>），确认父目录存在且用户有写权限。</li>
<li>检查<code>path</code>下是否已存在同名文件，若存在则可能报错（除非指定覆盖）。</li>
</ul>
</li>
<li><strong>分配磁盘inode</strong>：
<ul>
<li>从磁盘的<strong>空闲inode位图</strong>中找到一个未使用的inode编号（假设为<code>inode_num</code>）。</li>
<li>在磁盘的<strong>inode表</strong>中初始化该inode的元数据（如<code>i_mode=0775</code>、<code>i_nlink=1</code>、<code>i_size=0</code>等）。</li>
</ul>
</li>
<li><strong>更新目录</strong>：
<ul>
<li>在父目录的数据块中添加新目录项，格式为：<code>（文件名：newfile, inode编号：inode_num）</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-主存活动inode表初始化"><strong>2. 主存活动inode表初始化</strong></h3>
<ul>
<li><strong>加载inode到内存</strong>：
<ul>
<li>将磁盘上刚分配的<code>inode_num</code>对应的inode读入<strong>主存活动inode表</strong>。</li>
<li>初始化内存中的inode结构：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i_mode = <span class="number">0775</span>;     <span class="comment">// 文件权限：rwxrwxr-x</span></span><br><span class="line">i_nlink = <span class="number">1</span>;       <span class="comment">// 初始链接数（仅当前目录项引用）</span></span><br><span class="line">i_uid = 调用进程UID; <span class="comment">// 文件所有者</span></span><br><span class="line">i_gid = 调用进程GID; <span class="comment">// 文件所属组</span></span><br><span class="line">i_size = <span class="number">0</span>;        <span class="comment">// 初始文件大小为0</span></span><br><span class="line">i_blocks = <span class="number">0</span>;      <span class="comment">// 尚未分配磁盘块</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><strong>引用计数</strong>：活动inode的引用计数置为1（被即将创建的<code>file</code>结构引用）。</li>
</ul>
<hr>
<h3 id="3-系统打开文件表（file-struct）初始化"><strong>3. 系统打开文件表（file_struct）初始化</strong></h3>
<ul>
<li><strong>分配file结构</strong>：
<ul>
<li>在全局的<strong>系统打开文件表</strong>中分配一个空闲表项（<code>struct file</code>）。</li>
<li>初始化关键字段：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f_mode = O_WRONLY | O_CREAT; <span class="comment">// 以写方式创建</span></span><br><span class="line">f_offset = <span class="number">0</span>;                <span class="comment">// 初始读写位置为文件开头</span></span><br><span class="line">f_flags = 写特征位;           <span class="comment">// 标记为可写</span></span><br><span class="line">f_inode = 活动inode的指针;    <span class="comment">// 指向内存中的inode</span></span><br><span class="line">f_count = <span class="number">1</span>;                 <span class="comment">// 引用计数（被用户打开文件表引用）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-用户打开文件表（文件描述符表）关联"><strong>4. 用户打开文件表（文件描述符表）关联</strong></h3>
<ul>
<li><strong>分配文件描述符（fd）</strong>：
<ul>
<li>在调用进程的<code>files_struct</code>（用户打开文件表）中找到一个最小空闲序号（如<code>fd=3</code>）。</li>
<li>将该表项的指针指向刚创建的<strong>系统打开文件表项</strong>（<code>file</code>结构）。</li>
</ul>
</li>
<li><strong>返回fd</strong>：
<ul>
<li>将<code>fd</code>（如<code>3</code>）返回给用户进程，后续通过<code>fd</code>操作文件。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-指针连接关系"><strong>5. 指针连接关系</strong></h3>
<p>最终数据结构间的关联如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程PCB → files_struct[fd] → file_struct → 活动inode → 磁盘inode</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>用户层</strong>：通过<code>fd</code>（如<code>3</code>）读写文件。</li>
<li><strong>内核层</strong>：通过<code>file</code>结构管理当前打开实例的偏移量，通过<code>inode</code>管理文件元数据。</li>
</ul>
<hr>
<h3 id="示例流程"><strong>示例流程</strong></h3>
<p>用户调用<code>create(&quot;dir/newfile&quot;, 0775)</code>：</p>
<ol>
<li>检查<code>dir</code>是否存在，权限合法。</li>
<li>分配磁盘inode（假设<code>inode_num=100</code>），初始化磁盘inode。</li>
<li>在<code>dir</code>的目录数据块中添加条目：<code>(&quot;newfile&quot;, 100)</code>。</li>
<li>内存中加载inode 100，设置权限、链接数等。</li>
<li>创建<code>file</code>结构，关联inode，返回<code>fd=3</code>给进程。</li>
</ol>
<h2 id="f-count-和-i-count"><code>f_count</code> 和 <code>i_count</code></h2>
<hr>
<h3 id="1-f-count（文件表项引用计数）"><strong>1. <code>f_count</code>（文件表项引用计数）</strong></h3>
<ul>
<li><strong>位置</strong>：<br>
<code>f_count</code> 位于 <strong>系统打开文件表（File Table）的表项</strong> 中。
<ul>
<li>系统打开文件表是一个内核全局数据结构，每个表项（<code>struct file</code>）包含：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="type">mode_t</span> f_mode;      <span class="comment">// 文件访问模式</span></span><br><span class="line">    <span class="type">loff_t</span> f_pos;       <span class="comment">// 当前读写偏移（f_offset）</span></span><br><span class="line">    <span class="type">atomic_t</span> f_count;   <span class="comment">// 引用计数（f_count）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">f_inode</span>;</span> <span class="comment">// 指向对应的 inode</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><strong>作用</strong>：<br>
记录有多少个 <strong>用户打开文件表项（即进程的文件描述符）</strong> 引用了该系统打开文件表项。
<ul>
<li>当进程通过 <code>dup()</code>、<code>fork()</code> 或多次 <code>open()</code> 同一个文件时，多个文件描述符可能共享同一个系统打开文件表项，此时 <code>f_count</code> 会递增。</li>
<li>关闭文件时，<code>f_count</code> 减 1；若变为 0，则释放该系统打开文件表项。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-i-count（活动-inode-引用计数）"><strong>2. <code>i_count</code>（活动 inode 引用计数）</strong></h3>
<ul>
<li><strong>位置</strong>：<br>
<code>i_count</code> 位于 <strong>内存中的活动 inode（VFS inode）</strong> 中（<code>struct inode</code>）。
<ul>
<li>活动 inode 是内核为已打开文件维护的运行时数据结构，与磁盘上的静态 inode 分离：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> i_count;    <span class="comment">// 引用计数（i_count）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i_nlink; <span class="comment">// 磁盘 inode 的硬链接数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">i_sb</span>;</span> <span class="comment">// 所属文件系统</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><strong>作用</strong>：<br>
记录有多少个 <strong>系统打开文件表项</strong> 或 <strong>内核其他模块</strong> 引用了该活动 inode。
<ul>
<li>当不同进程通过不同路径（不同 <code>open()</code> 调用）访问同一文件时，每个 <code>open()</code> 会创建独立的系统打开文件表项，但这些表项指向同一个活动 inode，此时 <code>i_count</code> 递增。</li>
<li>关闭文件时，<code>i_count</code> 减 1；若变为 0，则将内存中的活动 inode 写回磁盘（若脏）并释放。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="关键区别"><strong>关键区别</strong></h3>
<table>
<thead>
<tr>
<th>计数器</th>
<th>存储位置</th>
<th>作用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>f_count</code></td>
<td>系统打开文件表（<code>struct file</code>）</td>
<td>跟踪共享同一个 <strong>文件偏移和状态</strong> 的进程（如 <code>fork()</code> 或 <code>dup()</code> 产生的共享）。</td>
</tr>
<tr>
<td><code>i_count</code></td>
<td>内存中的活动 inode（<code>struct inode</code>）</td>
<td>跟踪共享同一个 <strong>文件数据</strong> 的进程（如不同进程独立调用 <code>open()</code> 同一个文件）。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="示例场景"><strong>示例场景</strong></h3>
<ol>
<li>
<p><strong><code>f_count &gt; 1</code></strong>：<br>
进程 A 和 B 通过 <code>fork()</code> 共享同一个文件描述符，它们会共用同一个系统打开文件表项（<code>f_count=2</code>），读写偏移同步变化。</p>
</li>
<li>
<p><strong><code>i_count &gt; 1</code></strong>：<br>
进程 A 和 B 分别调用 <code>open(&quot;/tmp/file&quot;)</code>，生成两个独立的系统打开文件表项（<code>f_count=1</code> 每个），但指向同一个活动 inode（<code>i_count=2</code>），读写偏移独立。</p>
</li>
</ol>
<hr>
<h3 id="重点：为什么不在磁盘-inode-中？">重点：<strong>为什么不在磁盘 inode 中？</strong></h3>
<ul>
<li>磁盘上的 inode 是静态的，仅记录文件的持久属性（如权限、大小、数据块位置等）。</li>
<li><code>i_count</code> 和 <code>f_count</code> 是运行时动态共享的临时状态，由内核在内存中管理，无需持久化到磁盘。</li>
</ul>
<p>你提到的教材内容涉及<strong>文件系统的挂载（Mounting）和硬链接（Hard Link）的限制</strong>，这是操作系统管理多磁盘/分区时的重要机制。下面我会逐步拆解这段话的含义，并用实例说明。</p>
<hr>
<h3 id="1-单磁盘-vs-多磁盘的文件目录树"><strong>1. 单磁盘 vs 多磁盘的文件目录树</strong></h3>
<h4 id="1-Windows-风格（多棵目录树）"><strong>(1) Windows 风格（多棵目录树）</strong></h4>
<ul>
<li><strong>盘符分配</strong>：每个物理磁盘或分区被分配一个盘符（如 <code>C:\</code>、<code>D:\</code>），形成独立的目录树。
<ul>
<li>例如：
<ul>
<li><code>C:\Users\file.txt</code> 和 <code>D:\Data\file.txt</code> 是两棵完全独立的目录树。</li>
</ul>
</li>
<li><strong>特点</strong>：
<ul>
<li>不同磁盘的文件路径通过盘符区分，inode 号只需在各自磁盘内唯一。</li>
<li>跨磁盘访问文件需明确指定盘符（如 <code>D:\Data\file.txt</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-UNIX-Linux-风格（单棵目录树）"><strong>(2) UNIX/Linux 风格（单棵目录树）</strong></h4>
<ul>
<li><strong>挂载（Mounting）</strong>：所有磁盘/分区通过挂载到根目录（<code>/</code>）下的某个子目录，整合成一棵统一的目录树。
<ul>
<li>例如：
<ul>
<li>根文件系统挂载在 <code>/</code>，另一个磁盘挂载到 <code>/mnt/disk2</code>。</li>
<li>文件路径可能是 <code>/home/user/file.txt</code>（根磁盘）和 <code>/mnt/disk2/file.txt</code>（另一磁盘）。</li>
</ul>
</li>
<li><strong>特点</strong>：
<ul>
<li>用户看到的是单一的目录树，无需关心文件实际在哪个磁盘。</li>
<li>不同磁盘的 inode 号可能重复（因为各自文件系统独立管理 inode）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-Inode-的唯一性问题"><strong>2. Inode 的唯一性问题</strong></h3>
<ul>
<li><strong>Inode 的本质</strong>：
<ul>
<li>Inode 是文件系统内部的元数据结构，用于标识文件（存储权限、大小、数据块位置等）。</li>
<li><strong>Inode 号仅在同一个文件系统内唯一</strong>。</li>
</ul>
</li>
<li><strong>多磁盘/分区的冲突</strong>：
<ul>
<li>磁盘A 和 磁盘B 可能同时存在 inode 号为 <code>100</code> 的文件，但这两个文件完全不同。</li>
<li>当挂载后整合成一棵目录树时，系统如何区分这两个 inode <code>100</code>？</li>
</ul>
</li>
</ul>
<h4 id="解决方案："><strong>解决方案</strong>：</h4>
<ul>
<li><strong>文件系统挂载隔离</strong>：
<ul>
<li>内核会记录每个挂载点的文件系统信息（如设备ID）。</li>
<li>访问文件时，内核不仅检查 inode 号，还会确认其所属的文件系统。
<ul>
<li>例如：
<ul>
<li><code>/home/file</code>（inode 100，设备ID 1）</li>
<li><code>/mnt/disk2/file</code>（inode 100，设备ID 2）</li>
<li>系统通过设备ID + inode 号唯一标识文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-为什么禁止跨文件系统的硬链接？"><strong>3. 为什么禁止跨文件系统的硬链接？</strong></h3>
<h4 id="1-硬链接的实现原理"><strong>(1) 硬链接的实现原理</strong></h4>
<ul>
<li>硬链接本质是<strong>多个目录项指向同一个 inode</strong>。
<ul>
<li>例如：
<ul>
<li>创建硬链接：<code>ln /disk1/file /disk2/link</code>。</li>
<li>此时 <code>/disk1/file</code> 和 <code>/disk2/link</code> 的目录项会指向相同的 inode。</li>
</ul>
</li>
</ul>
</li>
<li><strong>硬链接的限制</strong>：
<ul>
<li>硬链接必须与目标文件在同一个文件系统内（即相同的设备ID）。</li>
<li>因为不同文件系统的 inode 号可能重复，无法跨文件系统唯一标识文件。</li>
</ul>
</li>
</ul>
<h4 id="2-跨文件系统的后果"><strong>(2) 跨文件系统的后果</strong></h4>
<ul>
<li>假设允许跨文件系统硬链接：
<ul>
<li><code>ln /disk1/file /disk2/link</code>（<code>disk1</code> 和 <code>disk2</code> 是不同的文件系统）。</li>
<li>若 <code>disk1</code> 的 inode <code>100</code> 和 <code>disk2</code> 的 inode <code>100</code> 冲突，系统无法区分该链接指向哪个文件。</li>
<li>文件系统卸载时，硬链接可能指向无效数据。</li>
</ul>
</li>
</ul>
<h4 id="3-替代方案：软链接（符号链接）"><strong>(3) 替代方案：软链接（符号链接）</strong></h4>
<ul>
<li>软链接是一个独立文件，存储目标文件的路径（而非 inode）。
<ul>
<li>例如：
<ul>
<li><code>ln -s /disk1/file /disk2/link</code>（允许跨文件系统）。</li>
</ul>
</li>
<li>特点：
<ul>
<li>可以跨文件系统。</li>
<li>若目标文件被删除，软链接会失效（“悬空链接”）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="成组链接法">成组链接法</h2>
<p>成组链接法是一种高效管理磁盘空闲块的方法，结合了分组和链表的思想，通过减少磁盘I/O操作提升性能。以下是其分配和归还算法的详细解释：</p>
<h3 id="成组链接法的核心结构"><strong>成组链接法的核心结构</strong></h3>
<ul>
<li><strong>分组管理</strong>：空闲块被划分为多个组，每组包含若干空闲块及指向下一组的指针。</li>
<li><strong>超级块</strong>：驻留在内存中，记录当前组的信息，包括空闲块数量、下一组指针及当前组的空闲块列表。初始时加载第一个组的信息。</li>
</ul>
<h3 id="分配算法"><strong>分配算法</strong></h3>
<ol>
<li><strong>检查当前组</strong>：若超级块中空闲块数量 &gt; 0，直接分配一个块（通常从列表末尾取出），并减少空闲块计数。</li>
<li><strong>组耗尽处理</strong>：若当前组空闲块计数减至0：
<ul>
<li>读取当前组指向的下一组的头信息（通过下一组指针）。</li>
<li>将下一组的信息加载到超级块中，更新空闲块列表和指针。</li>
<li>若无下一组（指针为空），表明无空闲块可分配，返回错误。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<ul>
<li>当前组有100个块，分配第100个块后计数为0。</li>
<li>将下一组（如块200）的信息加载到超级块，后续分配从新组继续。</li>
</ul>
<h3 id="归还算法"><strong>归还算法</strong></h3>
<ol>
<li><strong>直接归还</strong>：若当前组未满（空闲块数 &lt; 组大小上限），将释放的块加入空闲列表，计数加1。</li>
<li><strong>组已满处理</strong>：若当前组已满：
<ul>
<li>将超级块当前信息（计数、下一组指针、空闲列表）写入待释放块。</li>
<li>更新超级块：下一组指针指向该释放块，空闲列表重置为仅含此块，计数设为1。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<ul>
<li>当前组已满100块，释放块300。</li>
<li>将当前组信息存入块300，超级块指向块300，空闲列表为[300]，计数为1。</li>
</ul>
<h3 id="优势与特点"><strong>优势与特点</strong></h3>
<ul>
<li><strong>减少I/O操作</strong>：通过内存中的超级块批量处理，仅在组切换时访问磁盘。</li>
<li><strong>高效链表管理</strong>：通过分组形成链式结构，避免遍历长链表。</li>
<li><strong>动态扩展</strong>：释放时自动生成新组，适应空间变化。</li>
</ul>
<h3 id="关键细节"><strong>关键细节</strong></h3>
<ul>
<li><strong>组头结构</strong>：每个组的首个块存储下一组指针、本组空闲块数及空闲块列表。</li>
<li><strong>超级块作用</strong>：作为缓存，加速分配和释放操作。</li>
</ul>
<h3 id="总结"><strong>总结</strong></h3>
<p>成组链接法通过分组和链表的结合，优化了空闲块管理。分配时优先使用当前组，耗尽后切换；归还时若组满则创建新组。这种设计显著降低了磁盘访问频率，提升了存储管理效率。</p>
<p><img src="image.png" alt="alt text"></p>
<p>理解你的问题！你描述的流程是文件访问中<strong>从用户态系统调用到物理I/O操作</strong>的完整操作系统处理链条，包含了逻辑文件控制、访问控制、物理文件控制和I/O执行四层子系统。让我们通过一个具体例子来演示全过程：</p>
<hr>
<h3 id="📂-案例场景">📂 案例场景</h3>
<p><strong>用户操作</strong>：运行程序执行 <code>read(fd, buf, 4096)</code>，读取文件 <code>/home/user/data.txt</code> 的4KB数据（该文件大小为8KB，存储在Ext4文件系统上）</p>
<hr>
<h3 id="🔄-操作系统处理全过程（分层解析）">🔄 操作系统处理全过程（分层解析）</h3>
<h4 id="✅-第1层：用户接口与语法检查">✅ 第1层：用户接口与语法检查</h4>
<ol>
<li><strong>系统调用触发</strong>
<ul>
<li>用户程序调用 <code>read(fd, buf, 4096)</code>，通过软中断（如 <code>syscall</code>指令）进入内核态</li>
</ul>
</li>
<li><strong>语法检查</strong>
<ul>
<li>内核检查：
<ul>
<li><code>fd</code> 是否有效（是否存在进程打开文件表中）</li>
<li><code>buf</code> 地址是否在用户空间合法</li>
<li><code>size</code> 是否为非负整数</li>
</ul>
</li>
<li><strong>失败处理</strong>：如参数非法返回 <code>EINVAL</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>✅ <strong>进入逻辑文件控制子系统</strong></p>
</blockquote>
<hr>
<h4 id="✅-第2层：逻辑文件控制子系统">✅ 第2层：逻辑文件控制子系统</h4>
<ol>
<li><strong>路径解析</strong>
<ul>
<li>通过 <code>fd</code> 找到文件描述符表 → 打开文件表项 → inode编号（假设inode=123）</li>
</ul>
</li>
<li><strong>文件结构解析</strong>
<ul>
<li>查询inode元数据：
<ul>
<li>文件大小：8192 Bytes</li>
<li>块大小：4KB（Ext4默认）</li>
<li>物理结构：Extent树（现代Ext4结构）</li>
</ul>
</li>
</ul>
</li>
<li><strong>逻辑地址转换</strong>
<ul>
<li>计算当前读写位置（假设偏移量 <code>offset=0</code>）：
<ul>
<li><strong>逻辑块号</strong> = <code>offset / block_size = 0</code></li>
<li><strong>块内偏移</strong> = <code>0</code></li>
</ul>
</li>
<li>此次读取只需一个完整块（4KB）</li>
</ul>
</li>
</ol>
<blockquote>
<p>📊 输出：目标数据在<strong>逻辑块0</strong>（文件内相对位置）</p>
</blockquote>
<hr>
<h4 id="✅-第3层：文件保护子系统">✅ 第3层：文件保护子系统</h4>
<ol>
<li><strong>身份识别</strong>
<ul>
<li>获取调用进程的UID/GID（假设UID=1000）</li>
</ul>
</li>
<li><strong>权限验证</strong>
<ul>
<li>检查inode权限位：<code>-rw-r--r--</code></li>
<li>比对：
<ul>
<li>所有者权限：1000可读写 → <strong>允许读操作</strong></li>
<li>其他用户：只读权限 → 符合要求</li>
</ul>
</li>
</ul>
</li>
<li><strong>访问控制</strong>
<ul>
<li>若配置了SELinux：检查进程上下文标签是否允许读取该文件</li>
</ul>
</li>
</ol>
<blockquote>
<p>🔐 验证通过，允许操作</p>
</blockquote>
<hr>
<h4 id="✅-第4层：物理文件控制子系统">✅ 第4层：物理文件控制子系统</h4>
<ol>
<li><strong>缓存管理</strong>
<ul>
<li>查询页缓存（Page Cache）：
<ul>
<li>逻辑块0是否已缓存 → 假设未命中</li>
</ul>
</li>
</ul>
</li>
<li><strong>物理地址转换</strong>
<ul>
<li>通过inode的Extent树查找逻辑块0 → 物理块号（如磁盘块号1024）</li>
</ul>
</li>
<li><strong>空间管理</strong>
<ul>
<li>读操作无需分配新空间</li>
</ul>
</li>
<li><strong>I/O请求封装</strong>
<ul>
<li>构造bio请求：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">   .bi_sector = <span class="number">1024</span> * <span class="number">8</span>,   <span class="comment">// 1024块 * 每块8扇区</span></span><br><span class="line">   .bi_size   = <span class="number">4096</span>,       <span class="comment">// 请求大小</span></span><br><span class="line">   .bi_io_vec → 指向内核缓存页</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>💾 输出：物理I/O请求（从磁盘块1024读取4KB数据）</p>
</blockquote>
<hr>
<h4 id="✅-第5层：I-O控制子系统">✅ 第5层：I/O控制子系统</h4>
<ol>
<li><strong>I/O调度</strong>
<ul>
<li>请求加入块设备队列（如deadline调度器）</li>
<li>可能合并相邻I/O请求（本例无相邻请求）</li>
</ul>
</li>
<li><strong>驱动执行</strong>
<ul>
<li>SATA磁盘流程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">   CPU-&gt;&gt;磁盘控制器： 发送DMA命令 (LBA=8192, size=4096)</span><br><span class="line">   磁盘控制器-&gt;&gt;磁盘缓存： 读取数据到控制器缓存</span><br><span class="line">   磁盘控制器-&gt;&gt;内存： DMA传输到内核缓存页</span><br><span class="line">   磁盘控制器-&gt;&gt;CPU： 触发中断 IRQ 45</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><strong>中断处理</strong>
<ul>
<li>中断服务例程(ISR)确认I/O完成</li>
<li>唤醒等待进程</li>
</ul>
</li>
</ol>
<hr>
<h3 id="🔄-最终结果交付">🔄 最终结果交付</h3>
<ol>
<li><strong>数据拷贝</strong>
<ul>
<li>从内核缓存页复制4096字节到用户空间<code>buf</code></li>
</ul>
</li>
<li><strong>更新元数据</strong>
<ul>
<li>文件偏移量更新：<code>offset += 4096</code></li>
</ul>
</li>
<li><strong>用户态返回</strong>
<ul>
<li>系统调用返回成功读取字节数：<strong>4096</strong></li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">操作系统：并发编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-06-23 12:25:29 / 修改时间：12:26:22" itemprop="dateCreated datePublished" datetime="2025-06-23T12:25:29+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="读者写者问题的伪代码实现">读者写者问题的伪代码实现</h2>
<hr>
<h3 id="1-读者优先（可能导致写者饥饿）">1. <strong>读者优先（可能导致写者饥饿）</strong></h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw_mutex = <span class="number">1</span>;  // 读写互斥锁</span><br><span class="line">semaphore mutex = <span class="number">1</span>;     // 保护读者计数器的互斥锁</span><br><span class="line"><span class="built_in">int</span> reader_count = <span class="number">0</span>;    // 当前读者数量</span><br><span class="line"></span><br><span class="line">// 读者进程</span><br><span class="line">Reader() &#123;</span><br><span class="line">    <span class="keyword">while</span> (true) &#123;</span><br><span class="line">        P(mutex);                // 保护reader_count</span><br><span class="line">        <span class="keyword">if</span> (reader_count == <span class="number">0</span>) &#123;  // 第一个读者需要获取读写锁</span><br><span class="line">            P(rw_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        reader_count++;</span><br><span class="line">        V(mutex);</span><br><span class="line"></span><br><span class="line">        // 执行读操作</span><br><span class="line">        read_data();</span><br><span class="line"></span><br><span class="line">        P(mutex);</span><br><span class="line">        reader_count--;</span><br><span class="line">        <span class="keyword">if</span> (reader_count == <span class="number">0</span>) &#123;  // 最后一个读者释放读写锁</span><br><span class="line">            V(rw_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写者进程</span><br><span class="line">Writer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (true) &#123;</span><br><span class="line">        P(rw_mutex);      // 获取读写锁</span><br><span class="line">        // 执行写操作</span><br><span class="line">        write_data();</span><br><span class="line">        V(rw_mutex);      // 释放读写锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：读者可以并发读，但可能导致写者长期等待（饥饿）。</p>
<hr>
<h3 id="2-写者优先（避免写者饥饿）">2. <strong>写者优先（避免写者饥饿）</strong></h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw_mutex = <span class="number">1</span>;    // 读写互斥锁</span><br><span class="line">semaphore mutex = <span class="number">1</span>;       // 保护reader_count</span><br><span class="line">semaphore w = <span class="number">1</span>;           // 写者优先锁</span><br><span class="line"><span class="built_in">int</span> reader_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">// 读者进程</span><br><span class="line">Reader() &#123;</span><br><span class="line">    <span class="keyword">while</span> (true) &#123;</span><br><span class="line">        P(w);              // 写者优先：新读者需等待写者完成</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="keyword">if</span> (reader_count == <span class="number">0</span>) &#123;</span><br><span class="line">            P(rw_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        reader_count++;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line"></span><br><span class="line">        read_data();</span><br><span class="line"></span><br><span class="line">        P(mutex);</span><br><span class="line">        reader_count--;</span><br><span class="line">        <span class="keyword">if</span> (reader_count == <span class="number">0</span>) &#123;</span><br><span class="line">            V(rw_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写者进程</span><br><span class="line">Writer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (true) &#123;</span><br><span class="line">        P(w);              // 获取写者优先锁</span><br><span class="line">        P(rw_mutex);       // 获取读写锁</span><br><span class="line">        write_data();</span><br><span class="line">        V(rw_mutex);</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：写者优先获取锁，避免饥饿，但读者可能延迟。</p>
<hr>
<h3 id="3-公平竞争（先来先服务）">3. <strong>公平竞争（先来先服务）</strong></h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw_mutex = <span class="number">1</span>;    // 读写互斥锁</span><br><span class="line">semaphore mutex = <span class="number">1</span>;       // 保护reader_count</span><br><span class="line">semaphore queue = <span class="number">1</span>;       // 公平队列锁</span><br><span class="line"><span class="built_in">int</span> reader_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">// 读者进程</span><br><span class="line">Reader() &#123;</span><br><span class="line">    <span class="keyword">while</span> (true) &#123;</span><br><span class="line">        P(queue);          // 进入公平队列</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="keyword">if</span> (reader_count == <span class="number">0</span>) &#123;</span><br><span class="line">            P(rw_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        reader_count++;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(queue);</span><br><span class="line"></span><br><span class="line">        read_data();</span><br><span class="line"></span><br><span class="line">        P(mutex);</span><br><span class="line">        reader_count--;</span><br><span class="line">        <span class="keyword">if</span> (reader_count == <span class="number">0</span>) &#123;</span><br><span class="line">            V(rw_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写者进程</span><br><span class="line">Writer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (true) &#123;</span><br><span class="line">        P(queue);          // 进入公平队列</span><br><span class="line">        P(rw_mutex);</span><br><span class="line">        V(queue);          // 释放队列锁（允许其他进程排队）</span><br><span class="line"></span><br><span class="line">        write_data();</span><br><span class="line">        V(rw_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：通过队列锁实现先来先服务，平衡读者和写者的优先级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平锁同步器实现类，继承自Sync（Sync应继承AbstractQueuedSynchronizer）</span></span><br><span class="line"><span class="comment"> * 非公平锁特性：新请求锁的线程无需进入等待队列，可直接与队列中线程竞争锁资源</span></span><br><span class="line"><span class="comment"> * 优点：减少线程切换开销，提高吞吐量</span></span><br><span class="line"><span class="comment"> * 缺点：可能导致线程饥饿（长时间无法获取锁）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁操作入口方法</span></span><br><span class="line"><span class="comment">     * 实现非公平锁核心逻辑：直接尝试插队获取锁，失败后再走正常获取流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一步直接尝试CAS修改同步状态（体现非公平性）</span></span><br><span class="line">        <span class="comment">// compareAndSetState(0, 1)：</span></span><br><span class="line">        <span class="comment">// 原子操作尝试将state从0改为1，成功表示立即获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 设置当前线程为独占资源持有者</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 快速获取失败，执行常规锁获取流程（可能进入等待队列）</span></span><br><span class="line">            <span class="comment">// 调用AQS的acquire方法，内部会调用tryAcquire尝试获取锁</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试非公平方式获取锁（重写AQS的tryAcquire方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires 请求获取锁的次数（固定为1，在重入时会累加）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();  <span class="comment">// 获取当前线程引用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();  <span class="comment">// 获取当前同步状态值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Case 1：锁处于未锁定状态（state=0）</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 再次尝试CAS设置state（非公平性体现：不检查等待队列直接竞争）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);  <span class="comment">// 成功获取，设置独占线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CAS失败说明有其它线程竞争成功，继续返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case 2：锁已被持有，检查是否是当前线程（锁重入逻辑）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;  <span class="comment">// 计算新的重入次数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 溢出检查（理论上int最大值足够大，此检查为防御性编程）</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  <span class="comment">// 当超过int最大值时会溢出为负数</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            setState(nextc);  <span class="comment">// 更新重入次数（此处无需CAS，因为只有持有线程会修改）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两种情况都不满足，获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁实现类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁操作</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试公平方式加锁，重写父类 tryAcquire 方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1）判断等待队列是否有线程处于等待状态，如果没有，尝试获取锁；如果有，就进入等待队列</span></span><br><span class="line">            <span class="comment">// 2）采用CAS方式修改线程同步状态，如果成功返回true</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// 支持当前线程，重复获得锁，将state值加1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前线程是否需要排队（公平锁核心方法）</span></span><br><span class="line"><span class="comment"> * 返回true表示存在有效的前驱节点（当前线程需要排队）</span></span><br><span class="line"><span class="comment"> * 返回false表示可以直接尝试获取锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注：此方法的正确性依赖于以下条件：</span></span><br><span class="line"><span class="comment"> * 1. head节点必须在tail节点之前初始化</span></span><br><span class="line"><span class="comment"> * 2. head.next的准确性（当当前线程是队列第一个时）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;  <span class="comment">// 获取尾节点（反向初始化顺序读取）</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;  <span class="comment">// 获取头节点</span></span><br><span class="line">    Node s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Case 1：队列非空（h != t）</span></span><br><span class="line">    <span class="comment">// 注意：头尾不相等时，队列至少包含一个实际等待节点（非虚节点）</span></span><br><span class="line">    <span class="keyword">if</span> (h != t) &#123;</span><br><span class="line">        s = h.next;  <span class="comment">// 获取头节点的后继（第一个等待节点）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Case 1.1：s == null 说明存在并发修改（两种情况）：</span></span><br><span class="line">        <span class="comment">// 1. 其他线程刚完成锁释放，正在初始化新head（此时实际有等待节点）</span></span><br><span class="line">        <span class="comment">// 2. 其他线程正在插入新节点（但尚未连接next指针）</span></span><br><span class="line">        <span class="comment">// 这两种情况都需要保守返回true（让当前线程排队）</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Case 1.2：s.thread != 当前线程</span></span><br><span class="line">        <span class="comment">// 说明队列第一个等待节点不是当前线程，需要排队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.thread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case 1.3：s.thread == 当前线程</span></span><br><span class="line">        <span class="comment">// 说明当前线程已是队列第一个等待者，无需排队</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Case 2：队列为空（h == t）或当前线程是队列第一个等待者</span></span><br><span class="line">    <span class="comment">// 可以直接尝试获取锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AQS-内部维护一个共享资源变量和线程等待队列，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是-CLH-队列的变体实现的，将暂时获取不到锁的线程加入到等待队列中，待条件允许的时候将线程从队列中取出并进行唤醒。">AQS 内部维护一个共享资源变量和线程等待队列，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是 CLH 队列的变体实现的，将暂时获取不到锁的线程加入到等待队列中，待条件允许的时候将线程从队列中取出并进行唤醒。</h2>
<blockquote>
<p>总结下来，用大白话说就是，AQS是基于 CLH 队列，使用volatile修饰共享变量state，线程通过CAS方式去改变state状态值，如果成功则获取锁成功，失败则进入等待队列，等待被唤醒的线程同步器框架。</p>
</blockquote>
<h2 id="共享模式">共享模式</h2>
<p>AQS使用了模板方法设计模式</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>protected boolean isHeldExclusively()</code></td>
<td>判断当前线程是否独占资源。<strong>仅需在用到Condition时实现</strong>。</td>
</tr>
<tr>
<td><code>protected boolean tryAcquire(int arg)</code></td>
<td><strong>独占模式</strong>尝试获取资源。成功返回<code>true</code>，失败返回<code>false</code>。</td>
</tr>
<tr>
<td><code>protected boolean tryRelease(int arg)</code></td>
<td><strong>独占模式</strong>尝试释放资源。成功返回<code>true</code>，失败返回<code>false</code>。</td>
</tr>
<tr>
<td><code>protected int tryAcquireShared(int arg)</code></td>
<td><strong>共享模式</strong>尝试获取资源。返回负数表示失败；0表示成功但无剩余；正数表示成功且有剩余。</td>
</tr>
<tr>
<td><code>protected boolean tryReleaseShared(int arg)</code></td>
<td><strong>共享模式</strong>尝试释放资源。成功且需唤醒后续等待线程时返回<code>true</code>。</td>
</tr>
</tbody>
</table>
<h3 id="1-信号量（Semaphore）源码解析">1. 信号量（Semaphore）源码解析</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync; <span class="comment">// 基于AQS的同步器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法（默认非公平模式）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>); <span class="comment">// 初始化许可数量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取许可（阻塞直到成功）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>); <span class="comment">// 共享式获取1个许可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放许可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>); <span class="comment">// 共享式释放1个许可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        Sync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">            setState(<span class="keyword">permits</span>); <span class="comment">// 用AQS的state存储许可数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平模式尝试获取</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || </span><br><span class="line">                    compareAndSetState(available, remaining)) <span class="comment">// CAS更新</span></span><br><span class="line">                    <span class="keyword">return</span> remaining; <span class="comment">// 返回剩余许可数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享模式释放</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// 溢出检查</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心机制</strong>：</p>
<ul>
<li>使用AQS的state记录可用许可数</li>
<li>获取许可时通过CAS减少state值</li>
<li>释放许可时通过CAS增加state值</li>
<li>当许可不足时线程进入CLH队列等待</li>
</ul>
<h3 id="2-读写锁（ReadWriteLock）源码解析">2. 读写锁（ReadWriteLock）源码解析</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">false</span>); <span class="comment">// 默认非公平模式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写锁分离实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>); <span class="comment">// 共享模式获取读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>); <span class="comment">// 独占模式获取写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">// state高16位表示读锁，低16位表示写锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取读锁数量</span></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取写锁数量</span></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心机制</strong>：</p>
<ul>
<li>使用AQS state的高16位记录读锁数量，低16位记录写锁数量</li>
<li>读锁使用共享模式，允许多线程并发获取</li>
<li>写锁使用独占模式，获取时会阻塞所有读写线程</li>
<li>支持锁降级（写锁→读锁）但禁止锁升级</li>
</ul>
<h3 id="3-CountDownLatch源码解析">3. CountDownLatch源码解析</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count); <span class="comment">// 初始化计数器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待机制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>); <span class="comment">// 共享式等待</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器减1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>); <span class="comment">// 共享式释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">            setState(count); <span class="comment">// 用state存储计数器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>; <span class="comment">// 0表示完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 返回是否触发唤醒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心机制</strong>：</p>
<ul>
<li>初始化时设置state为线程数</li>
<li>每完成一个线程调用countDown()递减state</li>
<li>当state=0时唤醒所有等待线程</li>
</ul>
<h3 id="4-CyclicBarrier源码解析">4. CyclicBarrier源码解析</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrier</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;  <span class="comment">// 屏障阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;          <span class="comment">// 当前等待数</span></span><br><span class="line">    <span class="keyword">private</span> Runnable barrierCommand; <span class="comment">// 屏障触发动作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parties = parties;</span><br><span class="line">        <span class="built_in">this</span>.count = parties;</span><br><span class="line">        <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 最后一个到达线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrierCommand.run(); <span class="comment">// 执行屏障任务</span></span><br><span class="line">                    nextGeneration();     <span class="comment">// 重置屏障</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction) breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非最后线程进入等待</span></span><br><span class="line">            trip.await();</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">        trip.signalAll();  <span class="comment">// 唤醒所有线程</span></span><br><span class="line">        count = parties;   <span class="comment">// 重置计数器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心机制</strong>：</p>
<ul>
<li>使用ReentrantLock+Condition实现同步</li>
<li>每代（Generation）维护独立的计数器</li>
<li>最后一个到达线程执行回调并唤醒其他线程</li>
<li>支持重复使用（区别于CountDownLatch）</li>
</ul>
<h3 id="对比总结">对比总结</h3>
<table>
<thead>
<tr>
<th>工具类</th>
<th>核心特性</th>
<th>是否可重用</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Semaphore</td>
<td>控制资源访问并发数</td>
<td>是</td>
<td>连接池/限流</td>
</tr>
<tr>
<td>ReadWriteLock</td>
<td>读写分离的锁策略</td>
<td>是</td>
<td>读多写少的数据结构</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>一次性线程协调</td>
<td>否</td>
<td>主线程等待子线程完成</td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td>可循环使用的线程屏障</td>
<td>是</td>
<td>多阶段任务同步</td>
</tr>
</tbody>
</table>
<h2 id="java管程和霍尔管程">java管程和霍尔管程</h2>
<h3 id="基础概念回顾">基础概念回顾</h3>
<ul>
<li><strong>管程（Monitors）</strong>：是一种同步机制，用于保护共享数据。它像一个“房间”，只有一个线程（或进程）可以进入（称为“互斥访问”）。管程通常包括共享变量、操作方法和条件变量（用于线程等待和唤醒）。</li>
<li><strong>Java管程</strong>：基于MESA模型，由Java语言内置支持（如<code>synchronized</code>关键字或<code>Lock</code>接口）。它处理线程同步的方式更注重效率和实用性。</li>
<li><strong>霍尔管程</strong>：基于Hoare模型，通常在学术或理论环境中讨论，需要手动实现（如使用信号量）。它强调严格的顺序和精确性。</li>
<li><strong>关键术语</strong>：
<ul>
<li><strong>信号（signal）</strong>：一个线程通知另一个线程“条件已满足”，让它从等待状态醒来。</li>
<li><strong>等待（wait）</strong>：线程暂停执行，直到条件满足。</li>
<li><strong>虚假唤醒（spurious wakeup）</strong>：线程被唤醒，但条件实际上没有满足（常见于Java管程）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="一、核心差异">一、核心差异</h3>
<p>这一部分讨论了Java管程和霍尔管程在核心机制上的主要区别。核心差异主要体现在线程如何唤醒和处理条件变量。</p>
<ol>
<li>
<p><strong>线程唤醒策略</strong><br>
这点解释了当一个线程（例如线程A）使用信号唤醒另一个线程（例如线程B）时，两者处理的差异。</p>
<ul>
<li>
<p><strong>Java管程（MESA模型）</strong>：<br>
在Java管程中，当线程A调用<code>signal()</code>（或<code>notify()</code>）来唤醒线程B时，线程B不会立即开始执行。它会被添加到一个“入口等待队列”（一种线程队列），然后必须重新竞争锁（例如<code>synchronized</code>锁）才能进入管程。线程A不会立即停止；它会继续执行自己的代码，直到它自己退出管程。这避免了频繁的上下文切换（线程从暂停到运行的切换），提高了效率。<br>
<em>为什么这样设计？</em> MESA模型是为了适应多核CPU和高并发环境。它不强制线程立即切换，而是让线程通过竞争锁来决定执行顺序，这更灵活但也可能导致一些不确定性。<br>
<em>代码示例解释</em>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件不满足) &#123;  <span class="comment">// MESA模型必须用while循环检查条件</span></span><br><span class="line">    condition.await();  <span class="comment">// 线程等待，直到被signal()唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>while (条件不满足)</code>是一个循环检查。假设线程B在等待某个条件（如“队列不为空”）。当线程A调用<code>signal()</code>唤醒它时，线程B会醒来，但必须重新检查条件（因为可能有其他线程抢先执行，导致条件又变了）。如果不使用while循环，而只用if语句，可能会导致“虚假唤醒”问题（详见下一点）。总之，这个策略让Java管程更适合实际应用，但需要程序员小心处理。</p>
</li>
<li>
<p><strong>霍尔管程（Hoare模型）</strong>：<br>
在霍尔管程中，当线程A调用<code>signal()</code>唤醒线程B时，线程A会立即阻塞（暂停执行），而线程B会直接获得锁并开始执行。直到线程B完成执行并退出管程后，线程A才会恢复。这是一种严格的顺序执行，确保唤醒的线程B能立即接管控制权。<br>
<em>为什么这样设计？</em> Hoare模型更注重理论上的精确性，它假设信号操作是“原子”的（即不可中断的），这样可以避免竞争条件（race condition）。但这会导致更高的开销，因为系统必须强制线程切换。</p>
</li>
</ul>
</li>
<li>
<p><strong>条件变量处理</strong><br>
这点讨论了如何处理线程等待的条件，以及潜在的问题。</p>
<ul>
<li>
<p><strong>Java管程</strong>：Java管程的<code>notify()</code>或<code>signal()</code>方法可能导致<strong>虚假唤醒</strong>。虚假唤醒是指线程B被唤醒后，发现等待的条件实际上没有满足（例如，其他线程改变了条件）。这是因为MESA模型中，唤醒不是完全可靠的（操作系统或其他因素可能导致意外唤醒）。为了应对这个，Java推荐使用while循环来反复检查条件，就像上面的代码示例那样。这样，即使线程被虚假唤醒，它也会重新等待，直到条件真正满足。<br>
<em>详细原因</em>：在多线程环境中，信号可能被延迟或与其他操作交织，导致线程醒来时条件已变。这让Java管程更“现实”，但增加了编程复杂度。</p>
</li>
<li>
<p><strong>霍尔管程</strong>：霍尔管程的<code>signal()</code>是原子操作，不会发生虚假唤醒。一旦线程A发送信号，线程B就会立即执行，并且条件被保证已满足。这是因为Hoare模型强制线程A阻塞，确保线程B在安全的环境中运行。<br>
<em>详细原因</em>：这种设计更“理想化”，适合教学或需要精确控制的场景，但实际实现起来更复杂，因为它需要操作系统级别的支持。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、实现机制对比">二、实现机制对比</h3>
<p>这一部分通过表格对比了两者的实现细节。我会逐行解释表格中的每个特性。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Java管程</strong></th>
<th><strong>霍尔管程</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>模型基础</td>
<td>MESA模型（Java内置实现）</td>
<td>Hoare模型（需手动模拟）</td>
</tr>
<tr>
<td>锁获取方式</td>
<td>通过<code>synchronized</code>或<code>ReentrantLock</code></td>
<td>需自行实现信号量PV操作</td>
</tr>
<tr>
<td>线程切换开销</td>
<td>较低（减少上下文切换）</td>
<td>较高（强制线程切换）</td>
</tr>
<tr>
<td>适用场景</td>
<td>高并发系统（如Java并发包）</td>
<td>学术研究或特定同步需求</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>模型基础</strong>：<br>
Java管程基于MESA模型，这是一种现代的线程同步模型，由Java虚拟机（JVM）直接支持。你可以用简单的代码（如<code>synchronized</code>块）实现管程，而不需要额外工具。霍尔管程基于Hoare模型，这是一个更早的理论模型，通常需要程序员手动模拟（如使用信号量），所以它不适合日常编程。</p>
</li>
<li>
<p><strong>锁获取方式</strong>：<br>
在Java管程中，线程通过<code>synchronized</code>关键字（自动获取对象锁）或<code>ReentrantLock</code>（手动锁）来进入管程。这很方便，因为Java内置了这些机制。<br>
在霍尔管程中，你需要自己实现锁逻辑，通常使用信号量（一种更底层的同步工具）。信号量的PV操作（P:等待资源，V:释放资源）需要手动编写，这增加了复杂性。</p>
</li>
<li>
<p><strong>线程切换开销</strong>：<br>
Java管程的开销较低，因为它避免不必要的上下文切换（例如，在MESA模型中，线程A不会立即阻塞）。这意味着CPU资源利用更高效，适合高负载系统。<br>
霍尔管程的开销较高，因为它强制线程立即切换（线程A阻塞，线程B立即运行），这会涉及更多CPU时间和内存开销。</p>
</li>
<li>
<p><strong>适用场景</strong>：<br>
Java管程适合高并发系统，比如Web服务器或Java并发包（如<code>java.util.concurrent</code>），因为它高效且易用。霍尔管程更适合学术研究、教学演示或需要严格顺序的特定需求（如嵌入式系统），但在实际开发中很少使用。</p>
</li>
</ul>
<hr>
<h3 id="三、相同点">三、相同点</h3>
<p>这一部分列出了两者的共同之处。尽管它们在细节上不同，但这些相同点是管程机制的核心。</p>
<ol>
<li>
<p><strong>互斥访问</strong><br>
两者都确保同一时刻只有一个线程可以进入管程，从而保护共享资源免受并发访问的干扰。这就像一个门卫，只允许一个访客进入房间，避免冲突。<br>
<em>详细解释</em>：在多线程程序中，如果多个线程同时访问共享变量（如一个银行账户余额），可能会导致数据错误。管程通过互斥（mutex）机制解决这个问题，无论Java管程还是霍尔管程，都能实现这一功能。</p>
</li>
<li>
<p><strong>条件变量支持</strong><br>
两者都使用类似<code>wait()</code>和<code>signal()</code>的机制，让线程等待特定条件并在条件满足时唤醒。这是一种协作方式，让线程之间相互通信。<br>
<em>详细解释</em>：例如，在生产者-消费者问题中，生产者线程可能调用<code>signal()</code>来通知消费者线程“商品已生产”。Java管程用<code>Condition.await()</code>和<code>Condition.signal()</code>实现，霍尔管程用类似的自定义操作。这让管程不仅仅是互斥，还能处理复杂的同步场景。</p>
</li>
<li>
<p><strong>封装性</strong><br>
两者都将共享变量和相关的操作方法封装到一个“单元”中，确保线程安全。<br>
<em>详细解释</em>：这类似于面向对象的封装原则。共享数据（如变量）和操作（如加锁、等待）被放在一起，外部线程无法直接访问内部细节，从而减少错误。例如，在Java中，你可以用一个类来实现管程，里面包含synchronized方法。</p>
</li>
</ol>
<hr>
<h3 id="四、本质区别图示">四、本质区别图示</h3>
<p>这一部分用流程图展示了线程唤醒的差异。我会用文字详细解释这些流程。</p>
<ul>
<li>
<p><strong>Java管程唤醒流程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程A.signal() → 线程B进入入口队列 → 线程A继续执行 → 线程B竞争锁</span><br></pre></td></tr></table></figure>
<p><em>详细解释</em>：假设线程A和线程B都在管程中。线程A调用<code>signal()</code>后，它只是把线程B从等待队列移到入口队列，但线程A不会停下来。它继续执行自己的任务。线程B醒来后，必须加入锁竞争（可能有其他线程也在竞争），只有获胜后才能执行。这可能导致线程B需要等待一段时间，但整体效率较高。</p>
</li>
<li>
<p><strong>霍尔管程唤醒流程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程A.signal() → 线程A立即阻塞 → 线程B直接执行 → 线程B退出后线程A恢复</span><br></pre></td></tr></table></figure>
<p><em>详细解释</em>：线程A调用<code>signal()</code>后，它立即暂停（阻塞），系统直接让线程B运行。线程B执行完后，系统才允许线程A继续。这确保了严格的顺序，但可能导致性能问题，因为每次信号都涉及强制切换。</p>
</li>
</ul>
<hr>
<h3 id="五、选择建议">五、选择建议</h3>
<p>这一部分给出了在实际场景中选择哪种管程的建议。</p>
<ul>
<li>
<p><strong>优先Java管程</strong>：在需要高性能和低延迟的场景（如互联网服务）时，选择Java管程。<br>
<em>详细解释</em>：Java管程基于MESA模型，更适合现代多核CPU和大规模并发。它内置于Java中，易于使用，且开销小。例如，在开发一个处理数千用户请求的Web应用时，Java管程能高效管理线程，而不会因频繁切换导致系统变慢。</p>
</li>
<li>
<p><strong>考虑霍尔管程</strong>：在需要严格顺序执行或教学演示时（需自行实现），选择霍尔管程。<br>
<em>详细解释</em>：霍尔管程基于Hoare模型，更适合理论研究或需要精确控制的场景（如操作系统课程）。但是，由于它需要手动实现（如使用信号量），在实际项目中不常见。注：Java选择MESA模型是因为它更简单、实用，而Hoare模型更注重理论纯度。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">操作系统：第三章复习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-06-23 12:25:29 / 修改时间：12:26:30" itemprop="dateCreated datePublished" datetime="2025-06-23T12:25:29+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="可变分区方式的内存分配">可变分区方式的内存分配</h2>
<h3 id="内存分配算法整理"><strong>内存分配算法整理</strong></h3>
<table>
<thead>
<tr>
<th>算法</th>
<th>分配策略</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>最先适应 (First-Fit)</strong></td>
<td>从头找第一个足够大的</td>
<td>简单高效，适合大作业</td>
<td>低/高地址利用不均，回收麻烦</td>
<td>通用</td>
</tr>
<tr>
<td><strong>邻近适应 (Next-Fit)</strong></td>
<td>从上次位置开始找</td>
<td>查找更快，空间均衡</td>
<td>可能分割大空闲区</td>
<td>中等负载</td>
</tr>
<tr>
<td><strong>最优适应 (Best-Fit)</strong></td>
<td>找最小的足够大的</td>
<td>减少大分区浪费</td>
<td>产生小碎片，查找慢</td>
<td>中小作业</td>
</tr>
<tr>
<td><strong>最坏适应 (Worst-Fit)</strong></td>
<td>找最大的分区</td>
<td>减少小碎片</td>
<td>可能耗尽大分区</td>
<td>中小作业</td>
</tr>
<tr>
<td><strong>快速适应 (Quick-Fit)</strong></td>
<td>维护常用大小链表</td>
<td>查找极快</td>
<td>合并复杂，额外开销</td>
<td>特定场景</td>
</tr>
</tbody>
</table>
<p><strong>最常用</strong>：最先适应（简单高效） &gt; 邻近适应 &gt; 最优适应。</p>
<h2 id="外部碎片-内部碎片">外部碎片 内部碎片</h2>
<p>内部零头（Internal Fragmentation）​<br>
​定义：分配给进程的内存块比实际需求大，导致块内部有未使用的空间。<br>
外部零头（External Fragmentation）​<br>
​定义：内存中存在多个分散的小空闲区，但每个单独的空闲区都太小，无法满足进程需求。<br>
​最先适应（First-Fit）​：倾向于使用低地址的大空闲区，可能保留高地址的大块空闲区，外零头较少。<br>
​最坏适应（Worst-Fit）​：总是分配最大的空闲区，减少小碎片产生，但可能耗尽大分区。<br>
​最优适应（Best-Fit）​：​最激进地切割空闲区，故外零头问题最严重。</p>
<h1>页式存储管理</h1>
<table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>定义</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>页号</strong></td>
<td>进程虚拟地址空间的逻辑划分单元编号（如4KB一页的序号）</td>
<td>标识虚拟内存中的逻辑页位置</td>
</tr>
<tr>
<td><strong>页框号</strong></td>
<td>物理内存中实际存储块的编号（与页大小相同的物理块，也称页帧号/Physical Frame）</td>
<td>定位数据在物理内存中的实际存储位置</td>
</tr>
</tbody>
</table>
<p><strong>关键区别</strong>：</p>
<ul>
<li>页号属于<strong>虚拟地址空间</strong>（进程视角），页框号属于<strong>物理地址空间</strong>（硬件视角）。</li>
<li>页表的核心功能就是完成<strong>页号→页框号</strong>的映射（如下图所示）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址 = [页号][页内偏移] </span><br><span class="line">          ↓ 页表转换</span><br><span class="line">物理地址 = [页框号][页内偏移]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="image-13.png" alt="alt text"></p>
<h2 id="反置页表">反置页表</h2>
<p>正向页表（每个进程一个）：​<br>
​索引：​ 虚拟页号 (VPN)<br>
​表项内容：​ 物理页框号 (PFN) + 标志位<br>
​大小：​ 与进程的虚拟地址空间大小成正比（每个可能的虚拟页都有一个表项，即使该页未使用）。<br>
​反置页表（整个系统一个）：​<br>
​索引：​ 物理页框号 (PFN) (隐含在表项位置中)<br>
​表项内容：​ 进程ID (PID) + 虚拟页号 (VPN) + 标志位<br>
​大小：​ 与物理内存大小成正比（每个物理页框对应一个表项）。<br>
适用场景：​ 主要用在物理内存相对较小而虚拟地址空间非常大的系统中（如64位系统），或者嵌入式系统等资源受限环境。<br>
反置页表的页表项<br>
页号：虚拟地址页号<br>
进程标志符：使用该页的进程号(页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页)<br>
标志位：有效、引用、修改、保护和锁定等标志信息<br>
链指针：哈希链，如果某个项没有链项，则该域为空(允许用一个单独的位来表示)<br>
<img src="image-14.png" alt="alt text"></p>
<h2 id="段式">段式</h2>
<p>页式存储管理中页的划分对程序员不可见。<br>
段式存储管理中段的划分对程序员可见。<br>
分段是信息的逻辑单位，由源程序的逻辑结构所决定，用户可见<br>
段长可根据用户需要来规定，段起始地址可从任何主存地址开始。<br>
分段方式中，源程序(段号，段内位移)经连结装配后地址仍保持二维结构。<br>
分页是信息的物理单位，与源程序的逻辑结构无关，用户不可见，<br>
页长由系统确定，页面只能以页大小的整倍数地址开始<br>
分页方式中，源程序(页号，页内位移)经连结装配后地址变成了一维结构<br>
<img src="image-15.png" alt="alt text"></p>
<p>传统教科书中的段页式 = ​分段（逻辑划分）+ 分页（物理划分）​：<br>
程序地址空间被划分为逻辑段​（代码、数据、堆、栈等）。<br>
每个逻辑段被独立分页​（即段内地址再被拆分为页号和页内偏移）。<br>
​硬件流程：CPU生成地址（段号, 段内偏移）→ 段表 → 得到段基址和线性地址 → 线性地址通过页表 → 物理地址。</p>
<h2 id="页式">页式</h2>
<p>需要扩充页表项，至少包含如上信息，指出：<br>
主存驻留标志：指出页面是否已经装入内存。1表示在内存中可以被正常访问，0表示不能立即访问，产生缺页异常。<br>
修改位：被设置后，该页被调出内存前必须先写回磁盘，保障数据一致性<br>
保护位：限制页面访问权限<br>
引用位：在页面被引用无论是读写时设置，用来帮助系统进行页面淘汰。<br>
内存块号：页面对应的页框号，用来地址转换</p>
<p><img src="image-16.png" alt="alt text"><br>
维度	全局替换	局部替换<br>
置换范围	全系统物理帧	当前进程分配的帧<br>
帧分配方式	动态（按需调整）	静态（预先固定）<br>
公平性	低（强者通吃）	高（隔离保护）<br>
适用场景	通用计算（如Linux/Windows）	实时系统、嵌入式系统</p>
<h1>全局页面替换策略</h1>
<h2 id="OPT页面调度算法-Belady算法">OPT页面调度算法(Belady算法)</h2>
<p>算法描述：当要调入新页面时，首先淘汰以后不再访问的页，然后选择距现在最长时间后再访问的页。<br>
该方法由Belady提出，称为BeLady算法，又称最佳算法(OPT)<br>
OPT只可以模拟，不可以实现，因为永远无法预知之后的事情。<br>
这种算法可以用作衡量其他各种算法的标准</p>
<h2 id="先进先出页面调度算法-FIFO">先进先出页面调度算法(FIFO)</h2>
<p>算法描述：首先淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页(常驻的除外)<br>
模拟的是程序执行的顺序性，有一定合理性，并不能很好模拟程序的循环性。<br>
根据估计，缺页中断率也是最佳算法的2-3倍。<br>
<img src="image-17.png" alt="alt text"></p>
<h2 id="最近最少用LRU页面调度算法">最近最少用LRU页面调度算法</h2>
<p>淘汰最近一段时间较久未被访问的那一页，即那些刚被使用过的页面，可以马上还要被使用到。<br>
模拟了程序执行的局部属性，既考虑了循环性，又兼顾了顺序性<br>
LRU算法得到模拟实现：模拟是相当的不严谨，非常粗粒度的一个模拟。<br>
引用位法：每页建立一个引用标志，供硬件使用，设置一个时间间隔中断，发生时将页引用标志置0，访问页面时将引用标志置为1，页面置换的时候选择标志为0的页面，在选中淘汰页时，将所有的页的引用为全部置为0<br>
计数法：每页添加页面引用计数器，根据计数器选择最小的，定时清空页面引用计数器<br>
计时法：每页添加计时单元，引用时，将绝对时间记录进入计时单元，定时清空计时单元。<br>
老化算法：设置一个多位寄存器，被访问将最左侧设置为1，定时将寄存器右移，缺页中断时找到最小值的寄存器界面淘汰，被采用较多。</p>
<h2 id="第二次机会页面替换算法-SCR，Second-Chance-Replacement">第二次机会页面替换算法(SCR，Second Chance Replacement)</h2>
<p>将FIFO算法和页表中引用位结合。<br>
算法描述：<br>
首先检查FIFO页面队列队首<br>
引用位为0，则淘汰该页面<br>
引用位为1，将引用位清0，并将该页面移到队列尾部<br>
如果第一遍全为1，则循环</p>
<h2 id="最不常用LFU的页面调度算法">最不常用LFU的页面调度算法</h2>
<p>淘汰最近一段时间内访问次数较少的页面，对OPT的模拟性比LRU更好<br>
算法过程：基于时间间隔中断，并给每一页设置一个计数器，时间间隔中断发生后，所有计数器清0，每访问页1次就给计数器加1，选择计数最小的页面淘汰</p>
<h2 id="伙伴算法与slab">伙伴算法与slab</h2>
<p>伙伴系统的分配和回收过程<br>
分配过程：当系统需要内存时，从对应大小的链表中查找空闲块。如果没有找到，就向更大的内存块查找，并将其分裂为合适的大小进行分配。</p>
<p>伙伴系统分配内存的过程较为复杂。首先，当系统需要内存时，会根据所需内存的大小确定对应的页阶（order）。然后从对应页阶的链表中查找空闲块。如果在该链表中没有找到空闲块，就会向更大页阶的链表查找。例如，当需要一个 128 个页的页块时，先检查 128 个页的页块链表是否有空闲块。如果没有，则查 256 个页的页块链表；如果有空闲块的话，则将 256 个页的页块分成两份，一份使用，一份插入 128 个页的页块链表中。如果还是没有，就查 512 个页的页块链表；如果有的话，就分裂为 128、128、256 三个页块，一个 128 的使用，剩余两个插入对应页块链表。<br>
其实伙伴系统算法有如下3个基本条件需要满足：</p>
<p>两个内存块的大小相同</p>
<p>两个内存块的地址连续</p>
<p>两个内存块必须是从同一个大的内存块中分离出来的<br>
小于 4KB 的内存分配：Slab 分配器<br>
伙伴系统的最小分配单位是 4KB 页框，分配更小内存会产生内部碎片。​Slab 分配器​（及其演进版本 SLUB/SLOB）专门解决此问题，为内核对象提供精细化分配。</p>
<ol>
<li>​Slab 的核心机制<br>
​对象缓存池：<br>
为高频小对象（如 task_struct、inode）创建专用缓存（kmem_cache），预分配并初始化对象。<br>
​内存来源：<br>
从伙伴系统申请整页（4KB），再划分为多个小对象（如 64B、128B）。<br>
​分配流程：<br>
优先从 ​Per-CPU 本地缓存 获取空闲对象（无锁操作）。<br>
若本地缓存空，从 ​部分空闲的 Slab 补充对象。<br>
若无可用 Slab，向伙伴系统申请新页并初始化新 Slab。<br>
4MB+： vmalloc<br>
伙伴系统（Buddy System）分配的内存空间是虚拟地址连续且物理地址连续的，而 vmalloc 分配的内存是虚拟地址连续但物理地址不连续的<br>
vmalloc 是 Linux 内核提供的内存分配函数之一，它用于在虚拟地址空间中分配连续的内存块。与 kmalloc 主要用于物理内存的分配不同，vmalloc 分配的内存并不要求物理内存是连续的，但它确保分配的虚拟地址空间是连续的。<br>
在Linux内核中对于物理上连续的分配方式，采用伙伴系统和slub分配器分配内存，但是知道物理上连续的映射是最好的分配方式，但并不总能成功地使用。在分配一大块内存时，可能竭尽全力也无法找到连续的内存块。针对这种情况内核提供了一种申请一片连续的虚拟地址空间，但不保证物理空间连续，也就是vmalloc接口。</li>
</ol>
<p>vmalloc的工作方式类似于kmalloc，只不过前者分配的内存虚拟地址连续，而物理地址则无需连续，因此不能用于dma缓冲区<br>
通过vmalloc获得的页必须一个一个地进行映射，效率不高，因此不得已时才使用，同时vmalloc分配的一般是大块内存<br>
vmalloc分配的一般是高端内存，只有当内存不够的时候，才会分配低端内存</p>
<p>slab：<br>
三级结构<br>
层级	作用<br>
Slab缓存	每个缓存管理同一类型对象（如task_struct），包含多个Slab。<br>
Slab	一组连续的物理页（来自伙伴系统），划分为多个对象槽（Object Chunk）。<br>
对象	实际分配的内存单元，大小固定（如task_struct占1KB）。<br>
状态分类<br>
Full Slab：所有对象已被分配。<br>
Partial Slab：部分对象空闲（优先从此分配）。<br>
Empty Slab：所有对象空闲（可返还给伙伴系统）。<br>
Slab分配器不直接处理任意大小的内存请求，而是通过以下方式分层管理：</p>
<p>专用缓存（kmem_cache）</p>
<p>为高频使用的内核对象（如task_struct）预定义固定大小的缓存（通过kmem_cache_create创建）。<br>
对象大小由类型本身决定（如sizeof(struct task_struct)）。<br>
通用缓存（kmalloc）</p>
<p>提供一组预定义尺寸的Slab缓存（如32B、64B、128B、…、8KB等2的幂次方大小）。<br>
当调用kmalloc(size)时，内核选择最小适配的Slab缓存（如申请100B→分配128B的Slab）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhan20050128.github.io/notes.github.io/2025/06/23/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes.github.io/images/woshicaigou.jpg">
      <meta itemprop="name" content="Chen Zhan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes.github.io/2025/06/23/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">设备管理笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-23 12:25:29" itemprop="dateCreated datePublished" datetime="2025-06-23T12:25:29+08:00">2025-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、层次结构框架">一、层次结构框架</h3>
<p>典型I/O子系统分为五层（如图5-3）：</p>
<ol>
<li><strong>用户层I/O软件</strong>（库函数、SPOOLing）</li>
<li><strong>设备独立性软件</strong>（命名映射、缓冲管理）</li>
<li><strong>设备驱动程序</strong>（硬件命令转换）</li>
<li><strong>中断处理程序</strong>（硬件信号处理）</li>
<li><strong>硬件层</strong>（控制器、设备）</li>
</ol>
<h3 id="二、层级间交互机制">二、层级间交互机制</h3>
<h4 id="1-用户层与设备无关层的接口">1. 用户层与设备无关层的接口</h4>
<ul>
<li><strong>系统调用传递</strong>：用户程序通过<code>read/write</code>等系统调用进入内核态，例如<code>printf</code>调用会触发<code>write</code>系统调用</li>
<li><strong>参数标准化</strong>：用户层传递逻辑设备名（如<code>/dev/sda</code>），设备无关层通过逻辑设备表（LUT）将其映射为物理设备地址</li>
<li><strong>错误屏蔽</strong>：设备无关层过滤底层硬件错误（如磁盘重试机制），仅向上报告无法处理的异常</li>
</ul>
<h4 id="2-设备无关层与驱动层的协作">2. 设备无关层与驱动层的协作</h4>
<ul>
<li><strong>请求封装</strong>：将逻辑I/O请求（如文件偏移量）转换为物理块地址，并通过设备控制表（DCT）选择对应驱动程序</li>
<li><strong>资源调度</strong>：执行I/O调度算法（如磁盘电梯算法），合并相邻请求优化性能</li>
<li><strong>缓冲区管理</strong>：在内核空间建立数据缓冲区，协调用户空间与设备速度差异（如PageCache机制）</li>
</ul>
<h4 id="3-驱动层与硬件控制器的交互">3. 驱动层与硬件控制器的交互</h4>
<ul>
<li><strong>寄存器操作</strong>：驱动程序向设备控制器的命令寄存器写入操作码（如SCSI命令），设置DMA传输参数</li>
<li><strong>状态轮询</strong>：通过控制器状态寄存器检测设备就绪状态，或等待中断信号</li>
<li><strong>协议适配</strong>：将标准I/O命令转换为设备专属指令序列（如不同品牌打印机的控制码）</li>
</ul>
<h4 id="4-硬件层与中断处理的联动">4. 硬件层与中断处理的联动</h4>
<ul>
<li><strong>中断触发</strong>：设备完成操作后通过中断控制器（如APIC）向CPU发送信号</li>
<li><strong>上下文保存</strong>：中断处理程序保存被中断进程的寄存器状态到内核栈</li>
<li><strong>状态反馈</strong>：读取控制器状态寄存器，将结果写入内核缓冲区并唤醒阻塞进程</li>
</ul>
<h3 id="三、关键数据流示例（以磁盘读取为例）">三、关键数据流示例（以磁盘读取为例）</h3>
<ol>
<li><strong>用户层</strong>：<code>fread()</code>调用触发系统调用<code>read(fd, buf, size)</code></li>
<li><strong>设备无关层</strong>：
<ul>
<li>检查文件权限</li>
<li>将文件偏移转换为物理扇区号</li>
<li>分配内核缓冲区并加入I/O调度队列</li>
</ul>
</li>
<li><strong>驱动层</strong>：
<ul>
<li>向磁盘控制器发送<code>READ SECTOR</code>命令</li>
<li>设置DMA传输目标地址为内核缓冲区</li>
</ul>
</li>
<li><strong>硬件层</strong>：
<ul>
<li>磁盘控制器执行寻道操作</li>
<li>DMA引擎直接将数据写入内核缓冲区</li>
</ul>
</li>
<li><strong>中断处理</strong>：
<ul>
<li>DMA完成中断触发后，将数据从内核缓冲区复制到用户缓冲区</li>
<li>唤醒等待该I/O完成的进程</li>
</ul>
</li>
</ol>
<h3 id="四、分层设计的优势">四、分层设计的优势</h3>
<ol>
<li><strong>接口标准化</strong>：每层仅暴露抽象接口（如驱动层的<code>read/write</code>方法），隐藏实现细节</li>
<li><strong>错误隔离</strong>：设备驱动故障不会导致上层崩溃（如USB设备异常仅影响对应驱动）</li>
<li><strong>扩展性</strong>：新增设备只需实现驱动层，无需修改上层逻辑（如NVMe SSD兼容SATA接口）</li>
<li><strong>性能优化</strong>：各层独立实现缓存策略（用户层缓冲区 vs 内核PageCache）</li>
</ol>
<h3 id="五、跨层优化技术">五、跨层优化技术</h3>
<ol>
<li><strong>零拷贝（Zero-Copy）</strong>：绕过内核缓冲区，直接让用户空间与DMA引擎交互</li>
<li><strong>异步I/O</strong>：通过<code>io_uring</code>等机制实现请求批量提交和完成事件通知</li>
<li><strong>直接内存访问（DMA）</strong>：硬件控制器直接访问内存，减少CPU介入</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/notes.github.io/page/2/">2</a><a class="page-number" href="/notes.github.io/page/3/">3</a><a class="extend next" rel="next" href="/notes.github.io/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Zhan"
      src="/notes.github.io/images/woshicaigou.jpg">
  <p class="site-author-name" itemprop="name">Chen Zhan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/notes.github.io/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Zhan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/notes.github.io/lib/anime.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/notes.github.io/js/utils.js"></script>

<script src="/notes.github.io/js/motion.js"></script>


<script src="/notes.github.io/js/schemes/pisces.js"></script>


<script src="/notes.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

</body>
</html>
