<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/notes.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/notes.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/notes.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/notes.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/notes.github.io/css/main.css">


<link rel="stylesheet" href="/notes.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhan20050128.github.io","root":"/notes.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="20  为后代设计接口 在 Java 8 之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果向接口添加了一个新方法，现有的实现通常会缺少该方法，从而导致编译时错误。 在 Java 8 中，添加了默认方法（default method）构造[JLS 9.4]，目的是允许将方法添加到现有的接口。 但是增加新的方法到现有的接口是充满风险的。 默认方法的声明包含一个默认实现，该方法允许实现接口的">
<meta property="og:type" content="website">
<meta property="og:title" content="total">
<meta property="og:url" content="https://chenzhan20050128.github.io/notes.github.io/postBackup/total.html">
<meta property="og:site_name" content="cz Blog">
<meta property="og:description" content="20  为后代设计接口 在 Java 8 之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果向接口添加了一个新方法，现有的实现通常会缺少该方法，从而导致编译时错误。 在 Java 8 中，添加了默认方法（default method）构造[JLS 9.4]，目的是允许将方法添加到现有的接口。 但是增加新的方法到现有的接口是充满风险的。 默认方法的声明包含一个默认实现，该方法允许实现接口的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/JVM.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/1.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/2.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/put%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/3.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/concurrentHashMap7.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="c:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CDesktop%5Cgithub%E7%AC%94%E8%AE%B0%5CMySQL%5C1.png">
<meta property="og:image" content="c:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200220202650971.png">
<meta property="og:image" content="c:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200220202531623.png">
<meta property="og:image" content="c:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200229172633604.png">
<meta property="og:image" content="c:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CDesktop%5Cgithub%E7%AC%94%E8%AE%B0%5Cspring%5Cbean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.gif">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/MySQL%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/InnoDB%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/InnoDB%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/MVCC%E5%AE%9E%E7%8E%B0.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/MVCC%E5%AE%9E%E7%8E%B02.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/MVCC3.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/InnoDB%20%E9%94%81%E5%85%B3%E7%B3%BB%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/3%E6%AC%A1%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/4%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="c:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CDesktop%5Cgithub%E7%AC%94%E8%AE%B0%5Cgit%E5%91%BD%E4%BB%A4.png">
<meta property="og:image" content="c:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CDesktop%5Cgithub%E7%AC%94%E8%AE%B0%5Cgit%E5%B7%A5%E4%BD%9C%E6%B5%81.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/%E5%90%84%E5%AD%97%E8%8A%82%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/B+%E6%A0%91.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.png">
<meta property="og:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BE%8B%E5%AD%90.png">
<meta property="article:published_time" content="2025-06-23T04:27:03.000Z">
<meta property="article:modified_time" content="2025-06-23T04:27:03.428Z">
<meta property="article:author" content="Chen Zhan">
<meta property="article:tag" content="Java-Notes&#x2F;docs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/JVM.png">

<link rel="canonical" href="https://chenzhan20050128.github.io/notes.github.io/postBackup/total">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>total | cz Blog
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/notes.github.io/atom.xml" title="cz Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/notes.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cz Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/notes.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/notes.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/chenzhan20050128" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">total
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <!-- 文件: Effective Java.md -->
<p>20  为后代设计接口</p>
<p>在 Java 8 之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果向接口添加了一个新方法，现有的实现通常会缺少该方法，从而导致编译时错误。 在 Java 8 中，添加了默认方法（default method）构造[JLS 9.4]，目的是允许将方法添加到现有的接口。 但是增加新的方法到现有的接口是充满风险的。</p>
<p>默认方法的声明包含一个默认实现，该方法允许实现接口的类直接使用，而不必实现默认方法。 虽然在 Java 中添加默认方法可以将方法添加到现有接口，但不能保证这些方法可以在所有已有的实现中使用。 默认的方法被「注入（injected）」到现有的实现中，没有经过实现类的知道或同意。 在 Java 8 之前，这些实现是用默认的接口编写的，它们的接口永远不会获得任何新的方法。</p>
<p>许多新的默认方法被添加到 Java 8 的核心集合接口中，主要是为了方便使用 lambda 表达式（第 6 章）。 Java 类库的默认方法是高质量的通用实现，在大多数情况下，它们工作正常。 但是，编写一个默认方法并不总是可能的，它保留了每个可能的实现的所有不变量。</p>
<p>例如，考虑在 Java 8 中添加到 Collection 接口的 removeIf 方法。此方法删除给定布尔方法（或 Predicate 函数式接口）返回 true 的所有元素。默认实现被指定为使用迭代器遍历集合，调用每个元素的谓词，并使用迭代器的 remove 方法删除谓词返回 true 的元素。 据推测，这个声明看起来像这样：默认实现被指定为使用迭代器遍历集合，调用每个元素的 Predicate 函数式接口，并使用迭代器的 remove 方法删除 Predicate 函数式接口返回 true 的元素。 根据推测，这个声明看起来像这样：</p>
<p>// Default method added to the Collection interface in Java 8<br>
default boolean removeIf(Predicate&lt;? super E&gt; filter) {<br>
Objects.requireNonNull(filter);<br>
boolean result = false;<br>
for (Iterator<E> it = iterator(); it.hasNext(); ) {<br>
if (filter.test(it.next())) {<br>
it.remove();<br>
result = true;<br>
}<br>
}<br>
return result;<br>
}<br>
　　这是可能为 removeIf 方法编写的最好的通用实现，但遗憾的是，它在一些实际的 Collection 实现中失败了。 例如，考虑 org.apache.commons.collections4.collection.SynchronizedCollection 方法。 这个类出自 Apache Commons 类库中，与 java.util 包中的静态工厂 Collections.synchronizedCollection 方法返回的类相似。 Apache 版本还提供了使用客户端提供的对象进行锁定的能力，以代替集合。 换句话说，它是一个包装类（条目 18），它们的所有方法在委托给包装集合类之前在一个锁定对象上进行同步。</p>
<p>Apache 的 SynchronizedCollection 类仍然在积极维护，但在撰写本文时，并未重写 removeIf 方法。 如果这个类与 Java 8 一起使用，它将继承 removeIf 的默认实现，但实际上不能保持类的基本承诺：自动同步每个方法调用。 默认实现对同步一无所知，并且不能访问包含锁定对象的属性。 如果客户端在另一个线程同时修改集合的情况下调用 SynchronizedCollection 实例上的 removeIf 方法，则可能会导致 ConcurrentModificationException 异常或其他未指定的行为。</p>
<p>为了防止在类似的 Java 平台类库实现中发生这种情况，比如 Collections.synchronizedCollection 返回的包级私有的类，JDK 维护者必须重写默认的 removeIf 实现和其他类似的方法来在调用默认实现之前执行必要的同步。 原来不属于 Java 平台的集合实现没有机会与接口更改进行类似的改变，有些还没有这样做。</p>
<p>在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败。 虽然不是非常普遍，但这个问题也不是一个孤立的事件。 在 Java 8 中添加到集合接口的一些方法已知是易受影响的，并且已知一些现有的实现会受到影响。</p>
<p>应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的，在这种情况下，你应该仔细考虑，以确定现有的接口实现是否会被默认的方法实现所破坏。然而，默认方法对于在创建接口时提供标准的方法实现非常有用，以减轻实现接口的任务（详见第 20 条）。</p>
<p>还值得注意的是，默认方法不是被用来设计，来支持从接口中移除方法或者改变现有方法的签名的目的。在不破坏现有客户端的情况下，这些接口都不可能发生更改。</p>
<p>准则是清楚的。 尽管默认方法现在是 Java 平台的一部分，但是非常悉心地设计接口仍然是非常重要的。 虽然默认方法可以将方法添加到现有的接口，但这样做有很大的风险。 如果一个接口包含一个小缺陷，可能会永远惹怒用户。 如果一个接口严重缺陷，可能会破坏包含它的 API。</p>
<p>因此，在发布之前测试每个新接口是非常重要的。 多个程序员应该以不同的方式实现每个接口。 至少，你应该准备三种不同的实现。 编写多个使用每个新接口的实例来执行各种任务的客户端程序同样重要。 这将大大确保每个接口都能满足其所有的预期用途。 这些步骤将允许你在发布之前发现接口中的缺陷，但仍然可以轻松地修正它们。 虽然在接口被发布后可能会修正一些存在的缺陷，但不要太指望这一点。</p>
<ol start="22">
<li>接口仅用来定义类型<br>
　　当类实现接口时，该接口作为一种类型（type），可以用来引用类的实例。因此，一个类实现了一个接口，因此表明客户端可以如何处理类的实例。为其他目的定义接口是不合适的。</li>
</ol>
<p>一种失败的接口就是所谓的常量接口（constant interface）。 这样的接口不包含任何方法; 它只包含静态 final 属性，每个输出一个常量。 使用这些常量的类实现接口，以避免需要用类名限定常量名。 这里是一个例子：</p>
<p>// Constant interface antipattern - do not use!<br>
public interface PhysicalConstants {<br>
// Avogadro’s number (1/mol)<br>
static final double AVOGADROS_NUMBER   = 6.022_140_857e23;</p>
<pre><code>// Boltzmann constant (J/K)
static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;

// Mass of the electron (kg)
static final double ELECTRON_MASS      = 9.109_383_56e-31;
</code></pre>
<p>}<br>
　　常量接口模式是对接口的糟糕使用。 类在内部使用一些常量，完全属于实现细节。实现一个常量接口会导致这个实现细节泄漏到类的导出 API 中。对类的用户来说，类实现一个常量接口是没有意义的。事实上，它甚至可能使他们感到困惑。更糟糕的是，它代表了一个承诺：如果在将来的版本中修改了类，不再需要使用常量，那么它仍然必须实现接口，以确保二进制兼容性。如果一个非 final 类实现了常量接口，那么它的所有子类的命名空间都会被接口中的常量所污染。</p>
<p>Java 平台类库中有多个常量接口，如 java.io.ObjectStreamConstants。 这些接口应该被视为不规范的，不应该被效仿。</p>
<p>如果你想导出常量，有几个合理的选择方案。 如果常量与现有的类或接口紧密相关，则应将其添加到该类或接口中。 例如，所有数字基本类型的包装类，如 Integer 和 Double，都会导出 MIN_VALUE 和 MAX_VALUE 常量。 如果常量最好被看作枚举类型的成员，则应该使用枚举类型（详见第 34 条）导出它们。 否则，你应该用一个不可实例化的工具类来导出常量（详见第 4 条）。 下是前面所示的 PhysicalConstants 示例的工具类的版本：</p>
<p>// Constant utility class<br>
package com.effectivejava.science;</p>
<p>public class PhysicalConstants {<br>
private PhysicalConstants() { }  // Prevents instantiation</p>
<p>public static final double AVOGADROS_NUMBER = 6.022_140_857e23;<br>
public static final double BOLTZMANN_CONST  = 1.380_648_52e-23;<br>
public static final double ELECTRON_MASS    = 9.109_383_56e-31;<br>
}<br>
　　顺便提一下，请注意在数字文字中使用下划线字符（_）。 从 Java 7 开始，合法的下划线对数字字面量的值没有影响，但是如果使用得当的话可以使它们更容易阅读。 无论是固定的浮点数，如果他们包含五个或更多的连续数字，考虑将下划线添加到数字字面量中。 对于底数为 10 的数字，无论是整型还是浮点型的，都应该用下划线将数字分成三个数字组，表示一千的正负幂。</p>
<p>通常，实用工具类要求客户端使用类名来限定常量名，例如 PhysicalConstants.AVOGADROS_NUMBER。 如果大量使用实用工具类导出的常量，则通过使用静态导入来限定具有类名的常量：</p>
<p>// Use of static import to avoid qualifying constants<br>
import static com.effectivejava.science.PhysicalConstants.*;</p>
<p>public class Test {<br>
double  atoms(double mols) {<br>
return AVOGADROS_NUMBER * mols;<br>
}<br>
…<br>
// Many more uses of PhysicalConstants justify static import<br>
}<br>
　　总之，接口只能用于定义类型。 它们不应该仅用于导出常量。</p>
<ol start="23">
<li>类层次结构优于标签类<br>
　　有时你可能会碰到一个类，它的实例有两个或更多的风格，并且包含一个标签字段（tag field），表示实例的风格。 例如，考虑这个类，它可以表示一个圆形或矩形：</li>
</ol>
<p>// Tagged class - vastly inferior to a class hierarchy!<br>
class Figure {<br>
enum Shape { RECTANGLE, CIRCLE };</p>
<pre><code>// Tag field - the shape of this figure
final Shape shape;

// These fields are used only if shape is RECTANGLE
double length;
double width;

// This field is used only if shape is CIRCLE
double radius;

// Constructor for circle
Figure(double radius) &#123;
    shape = Shape.CIRCLE;
    this.radius = radius;
&#125;

// Constructor for rectangle
Figure(double length, double width) &#123;
    shape = Shape.RECTANGLE;
    this.length = length;
    this.width = width;
&#125;

double area() &#123;
    switch(shape) &#123;
      case RECTANGLE:
        return length * width;
      case CIRCLE:
        return Math.PI * (radius * radius);
      default:
        throw new AssertionError(shape);
    &#125;
&#125;
</code></pre>
<p>}<br>
　　这样的标签类具有许多缺点。 它们充斥着杂乱无章的样板代码，包括枚举声明，标签字段和 switch 语句。 可读性更差，因为多个实现在一个类中混杂在一起。 内存使用增加，因为实例负担属于其他风格不相关的领域。 字段不能成为 final，除非构造方法初始化不相关的字段，导致更多的样板代码。 构造方法在编译器的帮助下，必须设置标签字段并初始化正确的数据字段：如果初始化错误的字段，程序将在运行时失败。 除非可以修改其源文件，否则不能将其添加到标记的类中。 如果你添加一个风格，你必须记得给每个 switch 语句添加一个 case，否则这个类将在运行时失败。 最后，一个实例的数据类型没有提供任何关于风格的线索。 总之，标签类是冗长的，容易出错的，而且效率低下。</p>
<p>幸运的是，像 Java 这样的面向对象的语言为定义一个能够表示多种风格对象的单一数据类型提供了更好的选择：子类型化（subtyping）。标签类仅仅是一个类层次的简单的模仿。</p>
<p>要将标签类转换为类层次，首先定义一个包含抽象方法的抽象类，该标签类的行为取决于标签值。 在 Figure 类中，只有一个这样的方法，就是 area 方法。 这个抽象类是类层次的根。 如果有任何方法的行为不依赖于标签的值，把它们放在这个类中。 同样，如果有所有的方法使用的数据字段，把它们放在这个类。Figure 类中不存在这种与类型无关的方法或字段。</p>
<p>接下来，为原始标签类的每种类型定义一个根类的具体子类。 在我们的例子中，有两个类型：圆形和矩形。 在每个子类中包含特定于改类型的数据字段。 在我们的例子中，半径字段是属于圆的，长度和宽度字段都是矩形的。 还要在每个子类中包含根类中每个抽象方法的适当实现。 这里是对应于 Figure 类的类层次：</p>
<p>// Class hierarchy replacement for a tagged class<br>
abstract class Figure {<br>
abstract double area();<br>
}</p>
<p>class Circle extends Figure {<br>
final double radius;</p>
<pre><code>Circle(double radius) &#123; this.radius = radius; &#125;

@Override double area() &#123; return Math.PI * (radius * radius); &#125;
</code></pre>
<p>}<br>
class Rectangle extends Figure {<br>
final double length;<br>
final double width;</p>
<pre><code>Rectangle(double length, double width) &#123;
    this.length = length;
    this.width  = width;
&#125;
@Override double area() &#123; return length * width; &#125;
</code></pre>
<p>}<br>
　　这个类层次纠正了之前提到的标签类的每个缺点。 代码简单明了，不包含原文中的样板文件。 每种类型的实现都是由自己的类来分配的，而这些类都没有被无关的数据字段所占用。 所有的字段是 final 的。 编译器确保每个类的构造方法初始化其数据字段，并且每个类都有一个针对在根类中声明的每个抽象方法的实现。 这消除了由于缺少 switch-case 语句而导致的运行时失败的可能性。 多个程序员可以独立地继承类层次，并且可以相互操作，而无需访问根类的源代码。 每种类型都有一个独立的数据类型与之相关联，允许程序员指出变量的类型，并将变量和输入参数限制为特定的类型。</p>
<p>类层次的另一个优点是可以使它们反映类型之间的自然层次关系，从而提高了灵活性，并提高了编译时类型检查的效率。 假设原始示例中的标签类也允许使用正方形。 类层次可以用来反映一个正方形是一种特殊的矩形（假设它们是不可变的）：</p>
<p>class Square extends Rectangle {<br>
Square(double side) {<br>
super(side, side);<br>
}<br>
}<br>
　　请注意，上述层次结构中的字段是直接访问的，而不是通过访问器方法访问的。 这里是为了简洁起见，如果类层次是公开的（详见第 16 条），这将是一个糟糕的设计。</p>
<p>总之，标签类很少有适用的情况。 如果你想写一个带有显式标签字段的类，请考虑标签字段是否可以被删除，并是否能被类层次结构替换。 当遇到一个带有标签字段的现有类时，可以考虑将其重构为一个类层次结构。</p>
<ol start="24">
<li>支持使用静态成员类而不是非静态类<br>
　　嵌套类（nested class）是在另一个类中定义的类。 嵌套类应该只存在于其宿主类（enclosing class）中。 如果一个嵌套类在其他一些情况下是有用的，那么它应该是一个顶级类。 有四种嵌套类：静态成员类，非静态成员类，匿名类和局部类。 除了第一种以外，剩下的三种都被称为内部类（inner class）。 这个条目告诉你什么时候使用哪种类型的嵌套类以及为什么使用。</li>
</ol>
<p>静态成员类是最简单的嵌套类。 最好把它看作是一个普通的类，恰好在另一个类中声明，并且可以访问所有宿主类的成员，甚至是那些被声明为私有类的成员。 静态成员类是其宿主类的静态成员，并遵循与其他静态成员相同的可访问性规则。 如果它被声明为 private，则只能在宿主类中访问，等等。</p>
<p>静态成员类的一个常见用途是作为公共帮助类，仅在与其外部类一起使用时才有用。 例如，考虑一个描述计算器支持的操作的枚举类型（详见第 34 条）。 Operation 枚举应该是 Calculator 类的公共静态成员类。 Calculator 客户端可以使用 Calculator.Operation.PLUS 和 Calculator.Operation.MINUS 等名称来引用操作。</p>
<p>在语法上，静态成员类和非静态成员类之间的唯一区别是静态成员类在其声明中具有 static 修饰符。 尽管句法相似，但这两种嵌套类是非常不同的。 非静态成员类的每个实例都隐含地与其包含的类的宿主实例相关联。 在非静态成员类的实例方法中，可以调用宿主实例上的方法，或者使用限定的构造[JLS，15.8.4] 获得对宿主实例的引用。 如果嵌套类的实例可以与其宿主类的实例隔离存在，那么嵌套类必须是静态成员类：不可能在没有宿主实例的情况下创建非静态成员类的实例。</p>
<p>非静态成员类实例和其宿主实例之间的关联是在创建成员类实例时建立的，并且之后不能被修改。 通常情况下，通过在宿主类的实例方法中调用非静态成员类构造方法来自动建立关联。 尽管很少有可能使用表达式 enclosingInstance.new MemberClass(args) 手动建立关联。 正如你所预料的那样，该关联在非静态成员类实例中占用了空间，并为其构建添加了时间开销。</p>
<p>非静态成员类的一个常见用法是定义一个 Adapter [Gamma95]，它允许将外部类的实例视为某个不相关类的实例。 例如，Map 接口的实现通常使用非静态成员类来实现它们的集合视图，这些视图由 Map 的 keySet，entrySet 和 values 方法返回。 同样，集合接口（如 Set 和 List）的实现通常使用非静态成员类来实现它们的迭代器：</p>
<p>// Typical use of a nonstatic member class<br>
public class MySet<E> extends AbstractSet<E> {<br>
… // Bulk of the class omitted</p>
<pre><code>@Override 
public Iterator&lt;E&gt; iterator() &#123;
    return new MyIterator();
&#125;

private class MyIterator implements Iterator&lt;E&gt; &#123;
    ...
&#125;
</code></pre>
<p>}<br>
　　如果你声明了一个不需要访问宿主实例的成员类，总是把 static 修饰符放在它的声明中，使它成为一个静态成员类，而不是非静态的成员类。 如果你忽略了这个修饰符，每个实例都会有一个隐藏的外部引用给它的宿主实例。 如前所述，存储这个引用需要占用时间和空间。 更严重的是，并且会导致即使宿主类在满足垃圾回收的条件时却仍然驻留在内存中（详见第 7 条）。 由此产生的内存泄漏可能是灾难性的。 由于引用是不可见的，所以通常难以检测到。</p>
<p>私有静态成员类的常见用法是表示由它们的宿主类表示的对象的组件。 例如，考虑将键与值相关联的 Map 实例。 许多 Map 实现对于映射中的每个键值对都有一个内部的 Entry 对象。 当每个 entry 都与 Map 关联时，entry 上的方法 (getKey，getValue 和 setValue) 不需要访问 Map。 因此，使用非静态成员类来表示 entry 将是浪费的：私有静态成员类是最好的。 如果意外地忽略了 entry 声明中的 static 修饰符，Map 仍然可以工作，但是每个 entry 都会包含对 Map 的引用，浪费空间和时间。</p>
<p>如果所讨论的类是导出类的公共或受保护成员，则在静态和非静态成员类之间正确选择是非常重要的。 在这种情况下，成员类是导出的 API 元素，如果不违反向后兼容性，就不能在后续版本中从非静态变为静态成员类。</p>
<p>正如你所期望的，一个匿名类没有名字。 它不是其宿主类的成员。 它不是与其他成员一起声明，而是在使用时同时声明和实例化。 在表达式合法的代码中，匿名类是允许的。 当且仅当它们出现在非静态上下文中时，匿名类才会封装实例。 但是，即使它们出现在静态上下文中，它们也不能有除常量型变量之外的任何静态成员，这些常量型变量包括 final 的基本类型，或者初始化常量表达式的字符串属性[JLS，4.12.4]。</p>
<p>匿名类的适用性有很多限制。 除了在声明的时候之外，不能实例化它们。 你不能执行 instanceof 方法测试或者做任何其他需要你命名的类。 不能声明一个匿名类来实现多个接口，或者继承一个类并同时实现一个接口。 匿名类的客户端不能调用除父类型继承的成员以外的任何成员。 因为匿名类在表达式中出现，所以它们必须保持简短 —— 约十行或更少 —— 否则可读性将受到影响。</p>
<p>在将 lambda 表达式添加到 Java（第 6 章）之前，匿名类是创建小函数对象和处理对象的首选方法，但 lambda 表达式现在是首选（详见第 42 条）。 匿名类的另一个常见用途是实现静态工厂方法（请参阅条目 20 中的 intArrayAsList）。</p>
<p>局部类是四种嵌套类中使用最少的。 一个局部类可以在任何可以声明局部变量的地方声明，并遵守相同的作用域规则。 局部类与其他类型的嵌套类具有共同的属性。 像成员类一样，他们有名字，可以重复使用。 就像匿名类一样，只有在非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。 像匿名类一样，应该保持简短，以免损害可读性。</p>
<p>回顾一下，有四种不同的嵌套类，每个都有它的用途。 如果一个嵌套的类需要在一个方法之外可见，或者太长而不能很好地适应一个方法，使用一个成员类。 如果一个成员类的每个实例都需要一个对其宿主实例的引用，使其成为非静态的; 否则，使其静态。 假设这个类属于一个方法内部，如果你只需要从一个地方创建实例，并且存在一个预置类型来说明这个类的特征，那么把它作为一个匿名类；否则，把它变成局部类。</p>
<ol start="25">
<li>将源文件限制为单个顶级类<br>
　　虽然 Java 编译器允许在单个源文件中定义多个顶级类，但这样做没有任何好处，并且存在重大风险。 风险源于在源文件中定义多个顶级类使得为类提供多个定义成为可能。 使用哪个定义会受到源文件传递给编译器的顺序的影响。</li>
</ol>
<p>为了具体说明，请考虑下面源文件，其中只包含一个引用其他两个顶级类（Utensil 和 Dessert 类）的成员的 Main 类：</p>
<p>public class Main {<br>
public static void main(String[] args) {<br>
System.out.println(<a target="_blank" rel="noopener" href="http://Utensil.NAME">Utensil.NAME</a> + <a target="_blank" rel="noopener" href="http://Dessert.NAME">Dessert.NAME</a>);<br>
}<br>
}<br>
复制ErrorOK!<br>
　　现在假设在 Utensil.java 的源文件中同时定义了 Utensil 和 Dessert：</p>
<p>// Two classes defined in one file. Don’t ever do this!<br>
class Utensil {<br>
static final String NAME = “pan”;<br>
}</p>
<p>class Dessert {<br>
static final String NAME = “cake”;<br>
}<br>
复制ErrorOK!<br>
　　当然，main 方法会打印 pancake。</p>
<p>现在假设你不小心创建了另一个名为 Dessert.java 的源文件，它定义了相同的两个类：</p>
<p>// Two classes defined in one file. Don’t ever do this!<br>
class Utensil {<br>
static final String NAME = “pot”;<br>
}</p>
<p>class Dessert {<br>
static final String NAME = “pie”;<br>
}<br>
复制ErrorOK!<br>
　　如果你足够幸运，使用命令 javac Main.java Dessert.java 编译程序，编译将失败，编译器会告诉你，你已经多次定义了类 Utensil 和 Dessert。 这是因为编译器首先编译 Main.java，当它看到对 Utensil 的引用（它在 Dessert 的引用之前）时，它将在 Utensil.java 中查找这个类并找到 Utensil 和 Dessert。 当编译器在命令行上遇到 Dessert.java 时，它也将拉入该文件，导致它遇到 Utensil 和 Dessert 的定义。</p>
<p>如果使用命令 javac Main.java 或 javac Main.java Utensil.java 编译程序，它的行为与在编写 Dessert.java 文件（即打印 pancake）之前的行为相同。 但是，如果使用命令 javac Dessert.java Main.java 编译程序，它将打印 potpie。 程序的行为因此受到源文件传递给编译器的顺序的影响，这显然是不可接受的。</p>
<p>解决这个问题很简单，将顶层类（如我们的例子中的 Utensil 和 Dessert）分割成单独的源文件。 如果试图将多个顶级类放入单个源文件中，请考虑使用静态成员类（详见第 24 条）作为将类拆分为单独的源文件的替代方法。 如果这些类从属于另一个类，那么将它们变成静态成员类通常是更好的选择，因为它提高了可读性，并且可以通过声明它们为私有（详见第 15 条）来减少类的可访问性。下面是我们的例子看起来如何使用静态成员类：</p>
<p>// Static member classes instead of multiple top-level classes<br>
public class Test {<br>
public static void main(String[] args) {<br>
System.out.println(<a target="_blank" rel="noopener" href="http://Utensil.NAME">Utensil.NAME</a> + <a target="_blank" rel="noopener" href="http://Dessert.NAME">Dessert.NAME</a>);<br>
}</p>
<pre><code>private static class Utensil &#123;
    static final String NAME = &quot;pan&quot;;
&#125;

private static class Dessert &#123;
    static final String NAME = &quot;cake&quot;;
&#125;
</code></pre>
<p>}<br>
复制ErrorOK!<br>
　　这个教训很清楚：永远不要将多个顶级类或接口放在一个源文件中。 遵循这个规则保证在编译时不能有多个定义。 这又保证了编译生成的类文件以及生成的程序的行为与源文件传递给编译器的顺序无关。</p>
<p>自 Java 5 以来，泛型已经成为该语言的一部分。 在泛型之前，你必须转换从集合中读取的每个对象。 如果有人不小心插入了错误类型的对象，则在运行时可能会失败。 使用泛型，你告诉编译器在每个集合中允许哪些类型的对象。 编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。 这样做的结果是既安全又清晰的程序，但这些益处，不限于集合，是有代价的。 本章告诉你如何最大限度地提高益处，并将并发症降至最低。</p>
<ol start="26">
<li>不要使用原始类型<br>
　　首先，有几个术语。一个类或接口，它的声明有一个或多个类型参数（type parameters ），被称之为泛型类或泛型接口[JLS，8.1.2,9.1.2]。 例如，List 接口具有单个类型参数 E，表示其元素类型。 接口的全名是 List<E>（读作「E」的列表），但是人们经常称它为 List。 泛型类和接口统称为泛型类型（generic types）。</li>
</ol>
<p>每个泛型定义了一组参数化类型（parameterized types），它们由类或接口名称组成，后跟一个与泛型类型的形式类型参数[JLS，4.4,4.5] 相对应的实际类型参数的尖括号「&lt;&gt;」列表。 例如，List<String>（读作「字符串列表」）是一个参数化类型，表示其元素类型为 String 的列表。 （String 是与形式类型参数 E 相对应的实际类型参数）。</p>
<p>最后，每个泛型定义了一个原始类型（raw type），它是没有任何类型参数的泛型类型的名称[JLS，4.8]。 例如，对应于 List<E> 的原始类型是 List。 原始类型的行为就像所有的泛型类型信息都从类型声明中被清除一样。 它们的存在主要是为了与没有泛型之前的代码相兼容。</p>
<p>在泛型被添加到 Java 之前，这是一个典型的集合声明。 从 Java 9 开始，它仍然是合法的，但并不是典型的声明方式了：</p>
<p>// Raw collection type - don’t do this!</p>
<p>// My stamp collection. Contains only Stamp instances.<br>
private final Collection stamps = … ;<br>
复制ErrorOK!<br>
　　如果你今天使用这个声明，然后不小心把 coin 实例放入你的 stamp 集合中，错误的插入编译和运行没有错误（尽管编译器发出一个模糊的警告）：</p>
<p>// Erroneous insertion of coin into stamp collection<br>
stamps.add(new Coin( … )); // Emits “unchecked call” warning<br>
复制ErrorOK!<br>
　　直到您尝试从 stamp 集合中检索 coin 实例时才会发生错误：</p>
<p>// Raw iterator type - don’t do this!<br>
for (Iterator i = stamps.iterator(); i.hasNext(); )<br>
Stamp stamp = (Stamp) i.next(); // Throws ClassCastException<br>
stamp.cancel();<br>
复制ErrorOK!<br>
　　正如本书所提到的，在编译完成之后尽快发现错误是值得的，理想情况是在编译时。 在这种情况下，直到运行时才发现错误，在错误发生后的很长一段时间，以及可能远离包含错误的代码的代码中。 一旦看到 ClassCastException，就必须搜索代码类库，查找将 coin 实例放入 stamp 集合的方法调用。 编译器不能帮助你，因为它不能理解那个说「仅包含 stamp 实例」的注释。</p>
<p>对于泛型，类型声明包含的信息，而不是注释：</p>
<p>// Parameterized collection type - typesafe<br>
private final Collection<Stamp> stamps = … ;<br>
复制ErrorOK!<br>
　　从这个声明中，编译器知道 stamps 集合应该只包含 Stamp 实例，并保证它是 true，假设你的整个代码类库编译时不发出（或者抑制；参见条目 27）任何警告。 当使用参数化类型声明声明 stamps 时，错误的插入会生成一个编译时错误消息，告诉你到底发生了什么错误：</p>
<p>Test.java:9: error: incompatible types: Coin cannot be converted<br>
to Stamp<br>
c.add(new Coin());<br>
^<br>
复制ErrorOK!<br>
　　当从集合中检索元素时，编译器会为你插入不可见的强制转换，并保证它们不会失败（再假设你的所有代码都不会生成或禁止任何编译器警告）。 虽然意外地将 coin 实例插入 stamp 集合的预期可能看起来很牵强，但这个问题是真实的。 例如，很容易想象将 BigInteger 放入一个只包含 BigDecimal 实例的集合中。</p>
<p>如前所述，使用原始类型（没有类型参数的泛型）是合法的，但是你不应该这样做。 如果你使用原始类型，则会丧失泛型的所有安全性和表达上的优势。 鉴于你不应该使用它们，为什么语言设计者首先允许原始类型呢？ 答案是为了兼容性。 泛型被添加时，Java 即将进入第二个十年，并且有大量的代码没有使用泛型。 所有这些代码都是合法的，并且与使用泛型的新代码进行交互操作被认为是至关重要的。 将参数化类型的实例传递给为原始类型设计的方法必须是合法的，反之亦然。 这个需求，被称为迁移兼容性，驱使决策支持原始类型，并使用擦除来实现泛型（详见第 28 条）。</p>
<p>虽然不应使用诸如 List 之类的原始类型，但可以使用参数化类型来允许插入任意对象（如 List<Object>）。 原始类型 List 和参数化类型 List<Object> 之间有什么区别？ 松散地说，前者已经选择了泛型类型系统，而后者明确地告诉编译器，它能够保存任何类型的对象。 虽然可以将 List<String> 传递给 List 类型的参数，但不能将其传递给 List<Object> 类型的参数。 泛型有子类型的规则，List<String> 是原始类型 List 的子类型，但不是参数化类型 List<Object> 的子类型（条目 28）。 因此，如果使用诸如 List 之类的原始类型，则会丢失类型安全性，但是如果使用参数化类型（例如 List<Object>）则不会。</p>
<p>为了具体说明，请考虑以下程序：</p>
<p>// Fails at runtime - unsafeAdd method uses a raw type (List)!<br>
public static void main(String[] args) {<br>
List<String> strings = new ArrayList&lt;&gt;();<br>
unsafeAdd(strings, Integer.valueOf(42));<br>
String s = strings.get(0); // Has compiler-generated cast<br>
}</p>
<p>private static void unsafeAdd(List list, Object o) {<br>
list.add(o);<br>
}<br>
复制ErrorOK!<br>
　　此程序可以编译，它使用原始类型列表，但会收到警告：</p>
<p>Test.java:10: warning: [unchecked] unchecked call to add(E) as a<br>
member of the raw type List<br>
list.add(o);<br>
^<br>
复制ErrorOK!<br>
　　实际上，如果运行该程序，则当程序尝试调用 strings.get(0) 的结果（一个 Integer）转换为一个 String 时，会得到 ClassCastException 异常。 这是一个编译器生成的强制转换，因此通常会保证成功，但在这种情况下，我们忽略了编译器警告并付出了代价。</p>
<p>如果用 unsafeAdd 声明中的参数化类型 List<Object> 替换原始类型 List，并尝试重新编译该程序，则会发现它不再编译，而是发出错误消息：</p>
<p>Test.java:5: error: incompatible types: List<String> cannot be<br>
converted to List<Object><br>
unsafeAdd(strings, Integer.valueOf(42));<br>
复制ErrorOK!<br>
　　你可能会试图使用原始类型来处理元素类型未知且无关紧要的集合。 例如，假设你想编写一个方法，它需要两个集合并返回它们共同拥有的元素的数量。 如果是泛型新手，那么您可以这样写：</p>
<p>// Use of raw type for unknown element type - don’t do this!<br>
static int numElementsInCommon(Set s1, Set s2) {<br>
int result = 0;<br>
for (Object o1 : s1)<br>
if (s2.contains(o1))<br>
result++;<br>
return result;<br>
}<br>
复制ErrorOK!<br>
　　这种方法可以工作，但它使用原始类型，这是危险的。 安全替代方式是使用无限制通配符类型（unbounded wildcard types）。 如果要使用泛型类型，但不知道或关心实际类型参数是什么，则可以使用问号来代替。 例如，泛型类型 Set<E> 的无限制通配符类型是 Set&lt;?&gt;（读取「某种类型的集合」）。 它是最通用的参数化的 Set 类型，能够保持任何集合。 下面是 numElementsInCommon 方法使用无限制通配符类型声明的情况：</p>
<p>// Uses unbounded wildcard type - typesafe and flexible<br>
static int numElementsInCommon(Set<?> s1, Set<?> s2) { … }<br>
复制ErrorOK!<br>
　　无限制通配符 Set<?> 与原始类型 Set 之间有什么区别？ 问号真的给你放任何东西吗？ 这不是要点，但通配符类型是安全的，原始类型不是。 你可以将任何元素放入具有原始类型的集合中，轻易破坏集合的类型不变性（如第 119 页上的 unsafeAdd 方法所示）; 你不能把任何元素（除 null 之外）放入一个 Collection<?> 中。 试图这样做会产生一个像这样的编译时错误消息：</p>
<p>WildCard.java:13: error: incompatible types: String cannot be<br>
converted to CAP#1<br>
c.add(“verboten”);<br>
^<br>
where CAP#1 is a fresh type-variable:<br>
CAP#1 extends Object from capture of ?<br>
复制ErrorOK!<br>
　　不可否认的是，这个错误信息留下了一些需要的东西，但是编译器已经完成了它的工作，不管它的元素类型是什么，都不会破坏集合的类型不变性。 你不仅不能将任何元素（除 null 以外）放入一个 Collection&lt;?&gt; 中，并且根本无法猜测你会得到那种类型的对象。 如果这些限制是不可接受的，可以使用泛型方法（详见第 30 条）或有限制的通配符类型（详见第 31 条）。</p>
<p>对于不应该使用原始类型的规则，有一些小例外。 你必须在类字面值（class literals）中使用原始类型。 规范中不允许使用参数化类型（尽管它允许数组类型和基本类型）[JLS，15.8.2]。 换句话说，List.class，String[].class 和 int.class 都是合法的，但 List<String>.class 和 List&lt;?&gt;.class 都是不合法的。</p>
<p>规则的第二个例外与 instanceof 操作符有关。 因为泛型类型信息在运行时被擦除，所以在无限制通配符类型以外的参数化类型上使用 instanceof 运算符是非法的。 使用无限制通配符类型代替原始类型，不会对 instanceof 运算符的行为产生任何影响。 在这种情况下，尖括号（&lt;&gt;）和问号（?）就显得多余。 以下是使用泛型类型的 instanceof 运算符的首选方法：</p>
<p>// Legitimate use of raw type - instanceof operator<br>
if (o instanceof Set) {       // Raw type<br>
Set<?> s = (Set<?>) o;    // Wildcard type<br>
…<br>
}<br>
复制ErrorOK!<br>
　　请注意，一旦确定 o 对象是一个 Set，则必须将其转换为通配符 Set&lt;?&gt;，而不是原始类型 Set。 这是一个受检查的（checked）转换，所以不会导致编译器警告。</p>
<p>总之，使用原始类型可能导致运行时异常，所以不要使用它们。 原始类型只是为了与引入泛型机制之前的遗留代码进行兼容和互用而提供的。 作为一个快速回顾，Set<Object> 是一个参数化类型，表示一个可以包含任何类型对象的集合，Set&lt;?&gt; 是一个通配符类型，表示一个只能包含某些未知类型对象的集合，Set 是一个原始类型，它不在泛型类型系统之列。 前两个类型是安全的，最后一个不是。</p>
<p>为了快速参考，下表中总结了本条目（以及本章稍后介绍的一些）中介绍的术语：</p>
<p>术语	中文含义	举例	所在条目<br>
Parameterized type	参数化类型	List<String>	条目 26<br>
Actual type parameter	实际类型参数	String	条目 26<br>
Generic type	泛型类型	List<E>	条目 26 和 条目 29<br>
Formal type parameter	形式类型参数	E	条目 26<br>
Unbounded wildcard type	无限制通配符类型	List&lt;?&gt;	条目 26<br>
Raw type	原始类型	List	条目 26<br>
Bounded type parameter	限制类型参数	<E extends Number>	条目 29<br>
Recursive type bound	递归类型限制	&lt;T extends Comparable<T>&gt;	条目 30<br>
Bounded wildcard type	限制通配符类型	List&lt;? extends Number&gt;	条目 31<br>
Generic method	泛型方法	static <E> List<E> asList(E[] a)	条目 30<br>
Type token	类型令牌	String.class	条目 33</p>
<p>//<br>
27. 消除非检查警告<br>
　　使用泛型编程时，会看到许多编译器警告：未经检查的强制转换警告，未经检查的方法调用警告，未经检查的参数化可变长度类型警告以及未经检查的转换警告。 你使用泛型获得的经验越多，获得的警告越少，但不要期望新编写的代码能够干净地编译。</p>
<p>许多未经检查的警告很容易消除。 例如，假设你不小心写了以下声明：</p>
<p>Set<Lark> exaltation = new HashSet();<br>
复制ErrorOK!<br>
　　编译器会提醒你你做错了什么：</p>
<p>Venery.java:4: warning: [unchecked] unchecked conversion<br>
Set<Lark> exaltation = new HashSet();<br>
^<br>
required: Set<Lark><br>
found:    HashSet。<br>
复制ErrorOK!<br>
　　然后可以进行指示修正，让警告消失。 请注意，实际上并不需要指定类型参数，只是为了表明它与 Java 7 中引入的钻石运算符（「&lt;&gt;」）一同出现。然后编译器会推断出正确的实际类型参数（在本例中为 Lark）：</p>
<p>Set<Lark> exaltation = new HashSet&lt;&gt;();<br>
复制ErrorOK!<br>
　　但一些警告更难以消除。 本章充满了这种警告的例子。 当你收到需要进一步思考的警告时，坚持不懈！ 尽可能地消除每一个未经检查的警告。 如果你消除所有的警告，你可以放心，你的代码是类型安全的，这是一件非常好的事情。 这意味着在运行时你将不会得到一个 ClassCastException 异常，并且增加了你的程序将按照你的意图行事的信心。</p>
<p>如果你不能消除警告，但你可以证明引发警告的代码是类型安全的，那么（并且只能这样）用 @SuppressWarnings(“unchecked”) 注解来抑制警告。 如果你在没有首先证明代码是类型安全的情况下压制警告，那么你给自己一个错误的安全感。 代码可能会在不发出任何警告的情况下进行编译，但是它仍然可以在运行时抛出 ClassCastException 异常。 但是，如果你忽略了你认为是安全的未经检查的警告（而不是抑制它们），那么当一个新的警告出现时，你将不会注意到这是一个真正的问题。 新出现的警告就会淹没在所有的错误警告当中。</p>
<p>SuppressWarnings 注解可用于任何声明，从单个局部变量声明到整个类。 始终在尽可能最小的范围内使用 SuppressWarnings 注解。 通常这是一个变量声明或一个非常短的方法或构造方法。 切勿在整个类上使用 SuppressWarnings 注解。 这样做可能会掩盖重要的警告。</p>
<p>如果你发现自己在长度超过一行的方法或构造方法上使用 SuppressWarnings 注解，则可以将其移到局部变量声明上。 你可能需要声明一个新的局部变量，但这是值得的。 例如，考虑这个来自 ArrayList 的 toArray 方法：</p>
<p>public <T> T[] toArray(T[] a) {<br>
if (a.length &lt; size)<br>
return (T[]) Arrays.copyOf(elements, size, a.getClass());<br>
System.arraycopy(elements, 0, a, 0, size);<br>
if (a.length &gt; size)<br>
a[size] = null;<br>
return a;<br>
}</p>
<p>如果编译 ArrayList 类，则该方法会生成此警告：<br>
ArrayList.java:305: warning: [unchecked] unchecked cast<br>
return (T[]) Arrays.copyOf(elements, size, a.getClass());<br>
^<br>
required: T[]<br>
found:    Object[]<br>
复制ErrorOK!<br>
　　在返回语句中设置 SuppressWarnings 注解是非法的，因为它不是一个声明[JLS，9.7]。 你可能会试图把注释放在整个方法上，但是不要这要做。 相反，声明一个局部变量来保存返回值并标注它的声明，如下所示：</p>
<p>// Adding local variable to reduce scope of @SuppressWarnings<br>
public <T> T[] toArray(T[] a) {<br>
if (a.length &lt; size) {<br>
// This cast is correct because the array we’re creating<br>
// is of the same type as the one passed in, which is T[].<br>
@SuppressWarnings(“unchecked”) T[] result =<br>
(T[]) Arrays.copyOf(elements, size, a.getClass());<br>
return result;<br>
}<br>
System.arraycopy(elements, 0, a, 0, size);<br>
if (a.length &gt; size)<br>
a[size] = null;<br>
return a;<br>
}<br>
复制ErrorOK!<br>
　　所产生的方法干净地编译，并最小化未经检查的警告被抑制的范围。</p>
<p>每当使用 @SuppressWarnings(“unchecked”) 注解时，请添加注释，说明为什么是安全的。 这将有助于他人理解代码，更重要的是，这将减少有人修改代码的可能性，从而使计算不安全。 如果你觉得很难写这样的注释，请继续思考。 毕竟，你最终可能会发现未经检查的操作是不安全的。</p>
<p>总之，未经检查的警告是重要的。 不要忽视他们。 每个未经检查的警告代表在运行时出现 ClassCastException 异常的可能性。 尽你所能消除这些警告。 如果无法消除未经检查的警告，并且可以证明引发该警告的代码是安全类型的，则可以在尽可能小的范围内使用 @SuppressWarnings(“unchecked”) 注解来禁止警告。 记录你决定在注释中抑制此警告的理由。</p>
<ol start="28">
<li>列表优于数组<br>
　　数组在两个重要方面与泛型不同。 首先，数组是协变的（covariant）。 这个吓人的单词意味着如果 Sub 是 Super 的子类型，则数组类型 Sub[] 是数组类型 Super[] 的子类型。 相比之下，泛型是不变的（invariant）：对于任何两种不同的类型 Type1 和 Type2，List<Type1> 既不是 List<Type2> 的子类型也不是父类型。[JLS，4.10; Naftalin07, 2.5]。 你可能认为这意味着泛型是不足的，但可以说是数组缺陷。 这段代码是合法的：</li>
</ol>
<p>// Fails at runtime!<br>
Object[] objectArray = new Long[1];<br>
objectArray[0] = “I don’t fit in”; // Throws ArrayStoreException<br>
　　但这个不是：</p>
<p>// Won’t compile!<br>
List<Object> ol = new ArrayList<Long>(); // Incompatible types<br>
ol.add(“I don’t fit in”);<br>
　　无论哪种方式，你不能把一个 String 类型放到一个 Long 类型容器中，但是用一个数组，你会发现在运行时产生了一个错误；对于列表，可以在编译时就能发现错误。 当然，你宁愿在编译时找出错误。</p>
<p>数组和泛型之间的第二个主要区别是数组被具体化了（reified）[JLS，4.7]。 这意味着数组在运行时知道并强制执行它们的元素类型。 如前所述，如果尝试将一个 String 放入 Long 数组中，得到一个 ArrayStoreException 异常。 相反，泛型通过擦除（erasure）来实现[JLS，4.6]。 这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。 擦除是允许泛型类型与不使用泛型的遗留代码自由互操作（详见第 26 条），从而确保在 Java 5 中平滑过渡到泛型。</p>
<p>由于这些基本差异，数组和泛型不能很好地在一起混合使用。 例如，创建泛型类型的数组，参数化类型的数组，以及类型参数的数组都是非法的。 因此，这些数组创建表达式都不合法：new List<E>[]，new List<String>[]，new E[]。 所有将在编译时导致泛型数组创建错误。</p>
<p>为什么创建一个泛型数组是非法的？ 因为它不是类型安全的。 如果这是合法的，编译器生成的强制转换程序在运行时可能会因为 ClassCastException 异常而失败。 这将违反泛型类型系统提供的基本保证。</p>
<p>为了具体说明，请考虑下面的代码片段：</p>
<p>// Why generic array creation is illegal - won’t compile!<br>
List<String>[] stringLists = new List<String>[1];  // (1)<br>
List<Integer> intList = List.of(42);               // (2)<br>
Object[] objects = stringLists;                    // (3)<br>
objects[0] = intList;                              // (4)<br>
String s = stringLists[0].get(0);                  // (5)<br>
　　让我们假设第 1 行创建一个泛型数组是合法的。第 2 行创建并初始化包含单个元素的 List<Integer>。第 3 行将 List<String> 数组存储到 Object 数组变量中，这是合法的，因为数组是协变的。第 4 行将 List<Integer> 存储在 Object 数组的唯一元素中，这是因为泛型是通过擦除来实现的：List<Integer> 实例的运行时类型仅仅是 List，而 List<String>[] 实例是 List[]，所以这个赋值不会产生 ArrayStoreException 异常。现在我们遇到了麻烦。将一个 List<Integer> 实例存储到一个声明为仅保存 List<String> 实例的数组中。在第 5 行中，我们从这个数组的唯一列表中检索唯一的元素。编译器自动将检索到的元素转换为 String，但它是一个 Integer，所以我们在运行时得到一个 ClassCastException 异常。为了防止发生这种情况，第 1 行（创建一个泛型数组）必须产生一个编译时错误。</p>
<p>类型 E，List<E> 和 List<String> 等在技术上被称为不可具体化的类型（nonreifiable types）[JLS，4.7]。 直观地说，不可具体化的类型是其运行时表示包含的信息少于其编译时表示的类型。 由于擦除，可唯一确定的参数化类型是无限定通配符类型，如 List<?> 和 Map<?, ?>（详见第 26 条）。 尽管很少有用，创建无限定通配符类型的数组是合法的。</p>
<p>禁止泛型数组的创建可能会很恼人的。 这意味着，例如，泛型集合通常不可能返回其元素类型的数组（但是参见条目 33 中的部分解决方案）。 这也意味着，当使用可变参数方法（详见第 53 条）和泛型时，会产生令人困惑的警告。 这是因为每次调用可变参数方法时，都会创建一个数组来保存可变参数。 如果此数组的元素类型不可确定，则会收到警告。 SafeVarargs 注解可以用来解决这个问题（详见第 32 条）。</p>
<p>当你在强制转换为数组类型时，得到泛型数组创建错误，或是未经检查的强制转换警告时，最佳解决方案通常是使用集合类型 List<E> 而不是数组类型 E[]。 这样可能会牺牲一些简洁性或性能，但作为交换，你会获得更好的类型安全性和互操作性。</p>
<p>例如，假设你想用带有集合的构造方法来编写一个 Chooser 类，并且有个方法返回随机选择的集合的一个元素。 根据传递给构造方法的集合，可以使用该类的实例对象作为游戏骰子，魔力 8 号球或蒙特卡罗模拟的数据源。 这是一个没有泛型的简单实现：</p>
<p>// Chooser - a class badly in need of generics!<br>
public class Chooser {<br>
private final Object[] choiceArray;</p>
<pre><code>public Chooser(Collection choices) &#123;
    choiceArray = choices.toArray();
&#125;


public Object choose() &#123;
    Random rnd = ThreadLocalRandom.current();
    return choiceArray[rnd.nextInt(choiceArray.length)];
&#125;
</code></pre>
<p>}<br>
　　要使用这个类，每次调用方法时，都必须将 choose 方法的返回值从 Object 转换为所需的类型，如果类型错误，则转换在运行时失败。 我们先根据条目 29 的建议，试图修改 Chooser 类，使其成为泛型的。</p>
<p>// A first cut at making Chooser generic - won’t compile<br>
public class Chooser<T> {<br>
private final T[] choiceArray;</p>
<pre><code>public Chooser(Collection&lt;T&gt; choices) &#123;
    choiceArray = choices.toArray();
&#125;

// choose method unchanged
</code></pre>
<p>}<br>
　　如果你尝试编译这个类，会得到这个错误信息：</p>
<p>Chooser.java:9: error: incompatible types: Object[] cannot be<br>
converted to T[]<br>
choiceArray = choices.toArray();<br>
^<br>
where T is a type-variable:<br>
T extends Object declared in class Chooser<br>
　　没什么大不了的，将 Object 数组转换为 T 数组：</p>
<p>choiceArray = (T[]) choices.toArray();<br>
　　这没有了错误，而是得到一个警告：</p>
<p>Chooser.java:9: warning: [unchecked] unchecked cast<br>
choiceArray = (T[]) choices.toArray();<br>
^<br>
required: T[], found: Object[]<br>
where T is a type-variable:<br>
T extends Object declared in class Chooser<br>
　　编译器告诉你在运行时不能保证强制转换的安全性，因为程序不会知道 T 代表什么类型——记住，元素类型信息在运行时会被泛型删除。 该程序可以正常工作吗？ 是的，但编译器不能证明这一点。 你可以证明这一点，在注释中提出证据，并用注解来抑制警告，但最好是消除警告的原因（详见第 27 条）。</p>
<p>要消除未经检查的强制转换警告，请使用列表而不是数组。 下面是另一个版本的 Chooser 类，编译时没有错误或警告：</p>
<p>// List-based Chooser - typesafe<br>
public class Chooser<T> {<br>
private final List<T> choiceList;</p>
<pre><code>public Chooser(Collection&lt;T&gt; choices) &#123;
    choiceList = new ArrayList&lt;&gt;(choices);
&#125;


public T choose() &#123;
    Random rnd = ThreadLocalRandom.current();
    return choiceList.get(rnd.nextInt(choiceList.size()));
&#125;
</code></pre>
<p>}<br>
　　这个版本有些冗长，也许运行比较慢，但是值得一提的是，在运行时不会得到 ClassCastException 异常。</p>
<p>总之，数组和泛型具有非常不同的类型规则。 数组是协变和具体化的; 泛型是不变的，类型擦除的。 因此，数组提供运行时类型的安全性，但不提供编译时类型的安全性，对于泛型则是相反。 一般来说，数组和泛型不能很好地混合工作。 如果你发现把它们混合在一起，得到编译时错误或者警告，你的第一个冲动应该是用列表来替换数组。</p>
<ol start="29">
<li>优先考虑泛型<br>
　　参数化声明并使用 JDK 提供的泛型类型和方法通常不会太困难。 但编写自己的泛型类型有点困难，但值得努力学习。</li>
</ol>
<p>考虑条目 7 中的简单堆栈实现：</p>
<p>// Object-based collection - a prime candidate for generics<br>
public class Stack {<br>
private Object[] elements;<br>
private int size = 0;<br>
private static final int DEFAULT_INITIAL_CAPACITY = 16;</p>
<pre><code>public Stack() &#123;
    elements = new Object[DEFAULT_INITIAL_CAPACITY];
&#125;

public void push(Object e) &#123;
    ensureCapacity();
    elements[size++] = e;
&#125;

public Object pop() &#123;
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // Eliminate obsolete reference
    return result;
&#125;

public boolean isEmpty() &#123;
    return size == 0;
&#125;

private void ensureCapacity() &#123;
    if (elements.length == size)
        elements = Arrays.copyOf(elements, 2 * size + 1);
&#125;
</code></pre>
<p>}<br>
　　这个类应该已经被参数化了，但是由于事实并非如此，我们可以对它进行泛型化。 换句话说，我们可以参数化它，而不会损害原始非参数化版本的客户端。 就目前而言，客户端必须强制转换从堆栈中弹出的对象，而这些强制转换可能会在运行时失败。 泛型化类的第一步是在其声明中添加一个或多个类型参数。 在这种情况下，有一个类型参数，表示堆栈的元素类型，这个类型参数的常规名称是 E（详见第 68 条）。</p>
<p>下一步是用相应的类型参数替换所有使用的 Object 类型，然后尝试编译生成的程序：</p>
<p>// Initial attempt to generify Stack - won’t compile!<br>
public class Stack<E> {<br>
private E[] elements;<br>
private int size = 0;<br>
private static final int DEFAULT_INITIAL_CAPACITY = 16;</p>
<pre><code>public Stack() &#123;
    elements = new E[DEFAULT_INITIAL_CAPACITY];
&#125;

public void push(E e) &#123;
    ensureCapacity();
    elements[size++] = e;
&#125;

public E pop() &#123;
    if (size == 0)
        throw new EmptyStackException();
    E result = elements[--size];
    elements[size] = null; // Eliminate obsolete reference
    return result;
&#125;
... // no changes in isEmpty or ensureCapacity
</code></pre>
<p>}<br>
　　你通常会得到至少一个错误或警告，这个类也不例外。 幸运的是，这个类只产生一个错误：</p>
<p>Stack.java:8: generic array creation<br>
elements = new E[DEFAULT_INITIAL_CAPACITY];<br>
^<br>
　　如条目 28 所述，你不能创建一个不可具体化类型的数组，例如类型 E。每当编写一个由数组支持的泛型时，就会出现此问题。 有两种合理的方法来解决它。 第一种解决方案直接规避了对泛型数组创建的禁用：创建一个 Object 数组并将其转换为泛型数组类型。 现在没有了错误，编译器会发出警告。 这种用法是合法的，但不是（一般）类型安全的：</p>
<p>Stack.java:8: warning: [unchecked] unchecked cast<br>
found: Object[], required: E[]<br>
elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];<br>
^<br>
　　编译器可能无法证明你的程序是类型安全的，但你可以。 你必须说服自己，不加限制的类型强制转换不会损害程序的类型安全。 有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给 push 方法的元素，它们是 E 类型的，所以未经检查的强制转换不会造成任何伤害。</p>
<p>一旦证明未经检查的强制转换是安全的，请尽可能缩小范围（条目 27）。 在这种情况下，构造方法只包含未经检查的数组创建，所以在整个构造方法中抑制警告是合适的。 通过添加一个注解来执行此操作，Stack 可以干净地编译，并且可以在没有显式强制转换或担心 ClassCastException 异常的情况下使用它：</p>
<p>// The elements array will contain only E instances from push(E).<br>
// This is sufficient to ensure type safety, but the runtime<br>
// type of the array won’t be E[]; it will always be Object[]!<br>
@SuppressWarnings(“unchecked”)<br>
public Stack() {<br>
elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];<br>
}<br>
　　消除 Stack 中的泛型数组创建错误的第二种方法是将属性元素的类型从 E[] 更改为 Object[]。 如果这样做，会得到一个不同的错误：</p>
<p>Stack.java:19: incompatible types<br>
found: Object, required: E<br>
E result = elements[–size];<br>
^<br>
　　可以通过将从数组中检索到的元素转换为 E 来将此错误更改为警告：</p>
<p>Stack.java:19: warning: [unchecked] unchecked cast<br>
found: Object, required: E<br>
E result = (E) elements[–size];<br>
^<br>
　　因为 E 是不可具体化的类型，编译器无法在运行时检查强制转换。 再一次，你可以很容易地向自己证明，不加限制的转换是安全的，所以可以适当地抑制警告。 根据条目 27 的建议，我们只在包含未经检查的强制转换的分配上抑制警告，而不是在整个 pop 方法上：</p>
<p>// Appropriate suppression of unchecked warning<br>
public E pop() {<br>
if (size == 0)<br>
throw new EmptyStackException();</p>
<pre><code>// push requires elements to be of type E, so cast is correct
@SuppressWarnings(&quot;unchecked&quot;) E result =
    (E) elements[--size];

elements[size] = null; // Eliminate obsolete reference
return result;
</code></pre>
<p>}<br>
　　两种消除泛型数组创建的技术都有其追随者。 第一个更可读：数组被声明为 E[] 类型，清楚地表明它只包含 E 实例。 它也更简洁：在一个典型的泛型类中，你从代码中的许多点读取数组；第一种技术只需要一次转换（创建数组的地方），而第二种技术每次读取数组元素都需要单独转换。 因此，第一种技术是优选的并且在实践中更常用。 但是，它确实会造成堆污染（heap pollution）（详见第 32 条）：数组的运行时类型与编译时类型不匹配（除非 E 碰巧是 Object）。 这使得一些程序员非常不安，他们选择了第二种技术，尽管在这种情况下堆的污染是无害的。</p>
<p>下面的程序演示了泛型 Stack 类的使用。 该程序以相反的顺序打印其命令行参数，并将其转换为大写。 对从堆栈弹出的元素调用 String 的 toUpperCase 方法不需要显式强制转换，而自动生成的强制转换将保证成功：</p>
<p>// Little program to exercise our generic Stack<br>
public static void main(String[] args) {<br>
Stack<String> stack = new Stack&lt;&gt;();<br>
for (String arg : args)<br>
stack.push(arg);<br>
while (!stack.isEmpty())<br>
System.out.println(stack.pop().toUpperCase());<br>
}<br>
　　上面的例子似乎与条目 28 相矛盾，条目 28 中鼓励使用列表优先于数组。 在泛型类型中使用列表并不总是可行或可取的。 Java 本身生来并不支持列表，所以一些泛型类型（如 ArrayList）必须在数组上实现。 其他的泛型类型，比如 HashMap，是为了提高性能而实现的。</p>
<p>绝大多数泛型类型就像我们的 Stack 示例一样，它们的类型参数没有限制：可以创建一个 Stack<Object>, Stack&lt;int[]&gt;，Stack&lt;List<String>&gt; 或者其他任何对象的 Stack 引用类型。 请注意，不能创建基本类型的堆栈：尝试创建 Stack<int> 或 Stack<double> 将导致编译时错误。 这是 Java 泛型类型系统的一个基本限制。 可以使用基本类型的包装类（详见第 61 条）来解决这个限制。</p>
<p>有一些泛型类型限制了它们类型参数的允许值。 例如，考虑 java.util.concurrent.DelayQueue，它的声明如下所示：</p>
<p>class DelayQueue<E extends Delayed> implements BlockingQueue<E><br>
　　类型参数列表（<E extends Delayed>）要求实际的类型参数 E 是 java.util.concurrent.Delayed 的子类型。 这使得 DelayQueue 实现及其客户端可以利用 DelayQueue 元素上的 Delayed 方法，而不需要显式的转换或 ClassCastException 异常的风险。 类型参数 E 被称为限定类型参数。 请注意，子类型关系被定义为每个类型都是自己的子类型[JLS，4.10]，因此创建 DelayQueue<Delayed> 是合法的。</p>
<p>总之，泛型类型比需要在客户端代码中强制转换的类型更安全，更易于使用。 当你设计新的类型时，确保它们可以在没有这种强制转换的情况下使用。 这通常意味着使类型泛型化。 如果你有任何现有的类型，应该是泛型的但实际上却不是，那么把它们泛型化。 这使这些类型的新用户的使用更容易，而不会破坏现有的客户端（条目 26）。</p>
<ol start="31">
<li>使用限定通配符来增加 API 的灵活性<br>
　　如条目 28 所述，参数化类型是不变的。换句话说，对于任何两个不同类型的 Type1 和 Type2，List<Type1> 既不是 List<Type2> 的子类型也不是其父类型。尽管 List<String> 不是 List<Object> 的子类型是违反直觉的，但它确实是有道理的。 可以将任何对象放入 List<Object> 中，但是只能将字符串放入 List<String> 中。 由于 List<String> 不能做 List<Object> 所能做的所有事情，所以它不是一个子类型（条目 10 中的里氏替代原则）。</li>
</ol>
<p>相对于提供的不可变的类型，有时你需要比此更多的灵活性。 考虑条目 29 中的 Stack 类。下面是它的公共 API：</p>
<p>public class Stack<E> {</p>
<pre><code>public Stack();

public void push(E e);

public E pop();

public boolean isEmpty();
</code></pre>
<p>}<br>
　　假设我们想要添加一个方法来获取一系列元素，并将它们全部推送到栈上。 以下是第一种尝试：</p>
<p>// pushAll method without wildcard type - deficient!<br>
public void pushAll(Iterable<E> src) {<br>
for (E e : src)<br>
push(e);<br>
}<br>
　　这种方法可以干净地编译，但不完全令人满意。 如果可遍历的 src 元素类型与栈的元素类型完全匹配，那么它工作正常。 但是，假设有一个 Stack<Number>，并调用 push(intVal)，其中 intVal 的类型是 Integer。 这是因为 Integer 是 Number 的子类型。 从逻辑上看，这似乎也应该起作用：</p>
<p>Stack<Number> numberStack = new Stack&lt;&gt;();<br>
Iterable<Integer> integers = … ;<br>
numberStack.pushAll(integers);<br>
　　但是，如果你尝试了，会得到这个错误消息，因为参数化类型是不变的：</p>
<p>StackTest.java:7: error: incompatible types: Iterable<Integer><br>
cannot be converted to Iterable<Number><br>
numberStack.pushAll(integers);<br>
^<br>
　　幸运的是，有对应的解决方法。 该语言提供了一种特殊的参数化类型来调用一个限定通配符类型来处理这种情况。 pushAll 的输入参数的类型不应该是「E 的 Iterable 接口」，而应该是「E 的某个子类型的 Iterable 接口」，并且有一个通配符类型，这意味着：Iterable&lt;? extends E&gt;。 （关键字 extends 的使用有点误导：回忆条目 29 中，子类型被定义为每个类型都是它自己的子类型，即使它本身没有继承。）让我们修改 pushAll 来使用这个类型：</p>
<p>// Wildcard type for a parameter that serves as an E producer<br>
public void pushAll(Iterable&lt;? extends E&gt; src) {<br>
for (E e : src)<br>
push(e);<br>
}<br>
　　有了这个改变，Stack 类不仅可以干净地编译，而且客户端代码也不会用原始的 pushAll 声明编译。 因为 Stack 和它的客户端干净地编译，你知道一切都是类型安全的。</p>
<p>现在假设你想写一个 popAll 方法，与 pushAll 方法相对应。 popAll 方法从栈中弹出每个元素并将元素添加到给定的集合中。 以下是第一次尝试编写 popAll 方法的过程：</p>
<p>// popAll method without wildcard type - deficient!<br>
public void popAll(Collection<E> dst) {<br>
while (!isEmpty())<br>
dst.add(pop());<br>
}<br>
　　同样，如果目标集合的元素类型与栈的元素类型完全匹配，则干净编译并且工作正常。 但是，这又不完全令人满意。 假设你有一个 Stac<Number> 和 Object 类型的变量。 如果从栈中弹出一个元素并将其存储在该变量中，它将编译并运行而不会出错。 你不应该也这样做吗？</p>
<p>Stack<Number> numberStack = new Stack<Number>();</p>
<p>Collection<Object> objects = … ;</p>
<p>numberStack.popAll(objects);<br>
　　如果尝试将此客户端代码与之前显示的 popAll 版本进行编译，则会得到与我们的第一版 pushAll 非常类似的错误：Collection<Object> 不是 Collection<Number> 的子类型。 通配符类型再一次提供了一条出路。 popAll 的输入参数的类型不应该是「E 的集合」，而应该是「E 的某个父类型的集合」（其中父类型被定义为 E 是它自己的父类型[JLS，4.10]）。 再次，有一个通配符类型，正是这个意思：Collection&lt;? super E&gt;。 让我们修改 popAll 来使用它：</p>
<p>// Wildcard type for parameter that serves as an E consumer<br>
public void popAll(Collection&lt;? super E&gt; dst) {<br>
while (!isEmpty())<br>
dst.add(pop());<br>
}<br>
　　通过这个改动，Stack 类和客户端代码都可以干净地编译。</p>
<p>这个结论很清楚。 为了获得最大的灵活性，对代表生产者或消费者的输入参数使用通配符类型。 如果一个输入参数既是一个生产者又是一个消费者，那么通配符类型对你没有好处：你需要一个精确的类型匹配，这就是没有任何通配符的情况。</p>
<p>这里有一个助记符来帮助你记住使用哪种通配符类型： PECS 代表： producer-extends，consumer-super。</p>
<p>换句话说，如果一个参数化类型代表一个 T 生产者，使用 &lt;? extends T&gt;；如果它代表 T 消费者，则使用 &lt;? super T&gt;。 在我们的 Stack 示例中，pushAll 方法的 src 参数生成栈使用的 E 实例，因此 src 的合适类型为 Iterable&lt;? extends E&gt;；popAll 方法的 dst 参数消费 Stack 中的 E 实例，因此 dst 的合适类型是 Collection &lt;? super E&gt;。 PECS 助记符抓住了使用通配符类型的基本原则。 Naftalin 和 Wadler 称之为获取和放置原则（Get and Put Principle）[Naftalin07,2.4]。</p>
<p>记住这个助记符之后，让我们来看看本章中以前项目的一些方法和构造方法声明。 条目 28 中的 Chooser 类构造方法有这样的声明：</p>
<p>public Chooser(Collection<T> choices)<br>
　　这个构造方法只使用集合选择来生产类型 T 的值（并将它们存储起来以备后用），所以它的声明应该使用一个 extends T 的通配符类型。下面是得到的构造方法声明：</p>
<p>// Wildcard type for parameter that serves as an T producer</p>
<p>public Chooser(Collection&lt;? extends T&gt; choices)<br>
　　这种改变在实践中会有什么不同吗？ 是的，会有不同。 假你有一个 List<Integer>，并且想把它传递给 Chooser<Number> 的构造方法。 这不会与原始声明一起编译，但是它只会将限定通配符类型添加到声明中。</p>
<p>现在看看条目 30 中的 union 方法。下是声明：</p>
<p>public static <E> Set<E> union(Set<E> s1, Set<E> s2)<br>
　　两个参数 s1 和 s2 都是 E 的生产者，所以 PECS 助记符告诉我们该声明应该如下：</p>
<p>public static <E> Set<E> union(Set&lt;? extends E&gt; s1,  Set&lt;? extends E&gt; s2)<br>
　　请注意，返回类型仍然是 Set<E>。 不要使用限定通配符类型作为返回类型。除了会为用户提供额外的灵活性，还强制他们在客户端代码中使用通配符类型。 通过修改后的声明，此代码将清晰地编译：</p>
<p>Set<Integer>  integers =  Set.of(1, 3, 5);</p>
<p>Set<Double>   doubles  =  Set.of(2.0, 4.0, 6.0);</p>
<p>Set<Number>   numbers  =  union(integers, doubles);<br>
　　如果使用得当，类的用户几乎不会看到通配符类型。 他们使方法接受他们应该接受的参数，拒绝他们应该拒绝的参数。 如果一个类的用户必须考虑通配符类型，那么它的 API 可能有问题。</p>
<p>在 Java 8 之前，类型推断规则不够聪明，无法处理先前的代码片段，这要求编译器使用上下文指定的返回类型（或目标类型）来推断 E 的类型。union 方法调用的目标类型如前所示是 Set<Number>。 如果尝试在早期版本的 Java 中编译片段（以及适合的 Set.of 工厂替代版本），将会看到如此长的错综复杂的错误消息：</p>
<p>Union.java:14: error: incompatible types<br>
Set<Number> numbers = union(integers, doubles);<br>
^<br>
required: Set<Number><br>
found:    Set&lt;INT#1&gt;<br>
where INT#1,INT#2 are intersection types:<br>
INT#1 extends Number,Comparable<? extends INT#2>
    INT#2 extends Number,Comparable<?><br>
　　幸运的是有办法来处理这种错误。 如果编译器不能推断出正确的类型，你可以随时告诉它使用什么类型的显式类型参数[JLS，15.12]。 甚至在 Java 8 中引入目标类型之前，这不是你必须经常做的事情，这很好，因为显式类型参数不是很漂亮。 通过添加显式类型参数，如下所示，代码片段在 Java 8 之前的版本中进行了干净编译：</p>
<p>// Explicit type parameter - required prior to Java 8<br>
Set<Number> numbers = Union.<Number>union(integers, doubles);<br>
　　接下来让我们把注意力转向条目 30 中的 max 方法。这里是原始声明：</p>
<p>public static &lt;T extends Comparable<T>&gt; T max(List<T> list)<br>
　　为了从原来到修改后的声明，我们两次应用了 PECS。首先直接的应用是参数列表。 它生成 T 实例，所以将类型从 List<T> 更改为 List&lt;? extends T&gt;。 棘手的应用是类型参数 T。这是我们第一次看到通配符应用于类型参数。 最初，T 被指定为继承 Comparable<T>，但 Comparable 的 T 消费 T 实例（并生成指示顺序关系的整数）。 因此，参数化类型 Comparable<T> 被替换为限定通配符类型 Comparable&lt;? super T&gt;。 Comparable 实例总是消费者，所以通常应该使用 Comparable&lt;? super T&gt; 优于 Comparable<T>。 Comparator 也是如此。因此，通常应该使用 Comparator&lt;? super T&gt; 优于 Comparator<T>。</p>
<p>修改后的 max 声明可能是本书中最复杂的方法声明。 增加的复杂性是否真的起作用了吗？ 同样，它的确如此。 这是一个列表的简单例子，它被原始声明排除，但在被修改后的版本里是允许的：</p>
<p>List&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = … ;<br>
　　无法将原始方法声明应用于此列表的原因是 ScheduledFuture 不实现 Comparable<ScheduledFuture>。 相反，它是 Delayed 的子接口，它继承了 Comparable<Delayed>。 换句话说，一个 ScheduledFuture 实例不仅仅和其他的 ScheduledFuture 实例相比较： 它可以与任何 Delayed 实例比较，并且足以导致原始的声明拒绝它。 更普遍地说，通配符要求来支持没有直接实现 Comparable（或 Comparator）的类型，但继承了一个类型。</p>
<p>还有一个关于通配符相关的话题。 类型参数和通配符之间具有双重性，许多方法可以用一个或另一个声明。 例如，下面是两个可能的声明，用于交换列表中两个索引项目的静态方法。 第一个使用无限制类型参数（条目 30），第二个使用无限制通配符：</p>
<p>// Two possible declarations for the swap method<br>
public static <E> void swap(List<E> list, int i, int j);<br>
public static void swap(List&lt;?&gt; list, int i, int j);<br>
　　这两个声明中的哪一个更可取，为什么？ 在公共 API 中，第二个更好，因为它更简单。 你传入一个列表（任何列表），该方法交换索引的元素。 没有类型参数需要担心。 通常， 如果类型参数在方法声明中只出现一次，请将其替换为通配符。 如果它是一个无限制的类型参数，请将其替换为无限制的通配符; 如果它是一个限定类型参数，则用限定通配符替换它。</p>
<p>第二个 swap 方法声明有一个问题。 这个简单的实现不会编译：</p>
<p>public static void swap(List&lt;?&gt; list, int i, int j) {<br>
list.set(i, list.set(j, list.get(i)));<br>
}<br>
　　试图编译它会产生这个不太有用的错误信息：</p>
<p>Swap.java:5: error: incompatible types: Object cannot be<br>
converted to CAP#1<br>
list.set(i, list.set(j, list.get(i)));<br>
^<br>
where CAP#1 is a fresh type-variable:<br>
CAP#1 extends Object from capture of ?<br>
　　看起来我们不能把一个元素放回到我们刚刚拿出来的列表中。 问题是列表的类型是 List<?>，并且不能将除 null 外的任何值放入 List<?> 中。 幸运的是，有一种方法可以在不使用不安全的转换或原始类型的情况下实现此方法。 这个想法是写一个私有辅助方法来捕捉通配符类型。 辅助方法必须是泛型方法才能捕获类型。 以下是它的定义：</p>
<p>public static void swap(List&lt;?&gt; list, int i, int j) {<br>
swapHelper(list, i, j);<br>
}</p>
<p>// Private helper method for wildcard capture<br>
private static <E> void swapHelper(List<E> list, int i, int j) {<br>
list.set(i, list.set(j, list.get(i)));<br>
}<br>
　　swapHelper 方法知道该列表是一个 List<E>。 因此，它知道从这个列表中获得的任何值都是 E 类型，并且可以安全地将任何类型的 E 值放入列表中。 这个稍微复杂的 swap 的实现可以干净地编译。 它允许我们导出基于通配符的漂亮声明，同时利用内部更复杂的泛型方法。 swap 方法的客户端不需要面对更复杂的 swapHelper 声明，但他们从中受益。 辅助方法具有我们认为对公共方法来说过于复杂的签名。</p>
<p>总之，在你的 API 中使用通配符类型，虽然棘手，但使得 API 更加灵活。 如果编写一个将被广泛使用的类库，正确使用通配符类型应该被认为是强制性的。 记住基本规则： producer-extends, consumer-super（PECS）。 还要记住，所有 Comparable 和 Comparator 都是消费者。</p>
<ol start="32">
<li>合理地结合泛型和可变参数<br>
　　在 Java 5 中，可变参数方法（详见第 53 条）和泛型都被添加到平台中，所以你可能希望它们能够正常交互; 可悲的是，他们并没有。 可变参数的目的是允许客户端将一个可变数量的参数传递给一个方法，但这是一个脆弱的抽象（leaky abstraction）：当你调用一个可变参数方法时，会创建一个数组来保存可变参数；那个应该是实现细节的数组是可见的。 因此，当可变参数具有泛型或参数化类型时，会导致编译器警告混淆。</li>
</ol>
<p>回顾条目 28，非具体化（non-reifiable）的类型是其运行时表示比其编译时表示具有更少信息的类型，并且几乎所有泛型和参数化类型都是不可具体化的。 如果某个方法声明其可变参数为非具体化的类型，则编译器将在该声明上生成警告。 如果在推断类型不可确定的可变参数参数上调用该方法，那么编译器也会在调用中生成警告。 警告看起来像这样：</p>
<p>warning: [unchecked] Possible heap pollution from<br>
parameterized vararg type List<String><br>
复制ErrorOK!复制ErrorOK!<br>
　　当参数化类型的变量引用不属于该类型的对象时会发生堆污染（Heap pollution）[JLS，4.12.2]。 它会导致编译器的自动生成的强制转换失败，违反了泛型类型系统的基本保证。</p>
<p>例如，请考虑以下方法，该方法是第 127 页上的代码片段的一个不太明显的变体：</p>
<p>// Mixing generics and varargs can violate type safety!<br>
static void dangerous(List<String>… stringLists) {<br>
List<Integer> intList = List.of(42);<br>
Object[] objects = stringLists;<br>
objects[0] = intList;             // Heap pollution<br>
String s = stringLists[0].get(0); // ClassCastException<br>
}<br>
复制ErrorOK!复制ErrorOK!<br>
　　此方法没有可见的强制转换，但在调用一个或多个参数时抛出 ClassCastException 异常。 它的最后一行有一个由编译器生成的隐形转换。 这种转换失败，表明类型安全性已经被破坏，并且将值保存在泛型可变参数数组参数中是不安全的。</p>
<p>这个例子引发了一个有趣的问题：为什么声明一个带有泛型可变参数的方法是合法的，当明确创建一个泛型数组是非法的时候呢？ 换句话说，为什么前面显示的方法只生成一个警告，而 127 页上的代码片段会生成一个错误？ 答案是，具有泛型或参数化类型的可变参数参数的方法在实践中可能非常有用，因此语言设计人员选择忍受这种不一致。 事实上，Java 类库导出了几个这样的方法，包括 Arrays.asList(T… a)，Collections.addAll(Collection&lt;? super T&gt; c, T… elements)，EnumSet.of(E first, E… rest)。 与前面显示的危险方法不同，这些类库方法是类型安全的。</p>
<p>在 Java 7 中，@SafeVarargs 注解已添加到平台，以允许具有泛型可变参数的方法的作者自动禁止客户端警告。 实质上，@SafeVarargs 注解构成了作者对类型安全的方法的承诺。 为了交换这个承诺，编译器同意不要警告用户调用可能不安全的方法。</p>
<p>除非它实际上是安全的，否则注意不要使用 @SafeVarargs 注解标注一个方法。 那么需要做些什么来确保这一点呢？ 回想一下，调用方法时会创建一个泛型数组，以容纳可变参数。 如果方法没有在数组中存储任何东西（它会覆盖参数）并且不允许对数组的引用进行转义（这会使不受信任的代码访问数组），那么它是安全的。 换句话说，如果可变参数数组仅用于从调用者向方法传递可变数量的参数——毕竟这是可变参数的目的——那么该方法是安全的。</p>
<p>值得注意的是，你可以违反类型安全性，即使不会在可变参数数组中存储任何内容。 考虑下面的泛型可变参数方法，它返回一个包含参数的数组。 乍一看，它可能看起来像一个方便的小工具：</p>
<p>// UNSAFE - Exposes a reference to its generic parameter array!<br>
static <T> T[] toArray(T… args) {<br>
return args;<br>
}<br>
复制ErrorOK!复制ErrorOK!<br>
　　这个方法只是返回它的可变参数数组。 该方法可能看起来并不危险，但它是！ 该数组的类型由传递给方法的参数的编译时类型决定，编译器可能没有足够的信息来做出正确的判断。 由于此方法返回其可变参数数组，它可以将堆污染传播到调用栈上。</p>
<p>为了具体说明，请考虑下面的泛型方法，它接受三个类型 T 的参数，并返回一个包含两个参数的数组，随机选择：</p>
<p>static <T> T[] pickTwo(T a, T b, T c) {<br>
switch(ThreadLocalRandom.current().nextInt(3)) {<br>
case 0: return toArray(a, b);<br>
case 1: return toArray(a, c);<br>
case 2: return toArray(b, c);<br>
}<br>
throw new AssertionError(); // Can’t get here<br>
}<br>
复制ErrorOK!复制ErrorOK!<br>
　　这个方法本身不是危险的，除了调用具有泛型可变参数的 toArray 方法之外，不会产生警告。</p>
<p>编译此方法时，编译器会生成代码以创建一个将两个 T 实例传递给 toArray 的可变参数数组。 这段代码分配了一个 Object[] 类型的数组，它是保证保存这些实例的最具体的类型，而不管在调用位置传递给 pickTwo 的对象是什么类型。 toArray 方法只是简单地将这个数组返回给 pickTwo，然后 pickTwo 将它返回给调用者，所以 pickTwo 总是返回一个 Object[] 类型的数组。</p>
<p>public static void main(String[] args) {<br>
String[] attributes = pickTwo(“Good”, “Fast”, “Cheap”);<br>
}<br>
复制ErrorOK!复制ErrorOK!<br>
　　这种方法没有任何问题，因此它编译时不会产生任何警告。 但是当运行它时，抛出一个 ClassCastException 异常，尽管不包含可见的转换。 你没有看到的是，编译器已经生成了一个隐藏的强制转换为由 pickTwo 返回的值的 String[] 类型，以便它可以存储在属性中。 转换失败，因为 Object[] 不是 String[] 的子类型。 这种故障相当令人不安，因为它从实际导致堆污染（toArray）的方法中移除了两个级别，并且在实际参数存储在其中之后，可变参数数组未被修改。</p>
<p>这个例子是为了让人们认识到给另一个方法访问一个泛型的可变参数数组是不安全的，除了两个例外：将数组传递给另一个可变参数方法是安全的，这个方法是用 @SafeVarargs 正确标注的， 将数组传递给一个非可变参数的方法是安全的，该方法仅计算数组内容的一些方法。</p>
<p>这里是安全使用泛型可变参数的典型示例。 此方法将任意数量的列表作为参数，并按顺序返回包含所有输入列表元素的单个列表。 由于该方法使用 @SafeVarargs 进行标注，因此在声明或其调用站位置上不会生成任何警告：</p>
<p>// Safe method with a generic varargs parameter<br>
@SafeVarargs<br>
static <T> List<T> flatten(List&lt;? extends T&gt;… lists) {<br>
List<T> result = new ArrayList&lt;&gt;();<br>
for (List&lt;? extends T&gt; list : lists)<br>
result.addAll(list);<br>
return result;<br>
}<br>
复制ErrorOK!复制ErrorOK!<br>
　　决定何时使用 @SafeVarargs 注解的规则很简单：在每种方法上使用 @SafeVarargs，并使用泛型或参数化类型的可变参数，这样用户就不会因不必要的和令人困惑的编译器警告而担忧。 这意味着你不应该写危险或者 toArray 等不安全的可变参数方法。 每次编译器警告你可能会受到来自你控制的方法中泛型可变参数的堆污染时，请检查该方法是否安全。 提醒一下，在下列情况下，泛型可变参数方法是安全的：</p>
<p>它不会在可变参数数组中存储任何东西<br>
它不会使数组（或克隆）对不可信代码可见。 如果违反这些禁令中的任何一项，请修复。<br>
　　请注意，SafeVarargs 注解只对不能被重写的方法是合法的，因为不可能保证每个可能的重写方法都是安全的。 在 Java 8 中，注解仅在静态方法和 final 实例方法上合法; 在 Java 9 中，它在私有实例方法中也变为合法。</p>
<p>使用 SafeVarargs 注解的替代方法是采用条目 28 的建议，并用 List 参数替换可变参数（这是一个变相的数组）。 下面是应用于我们的 flatten 方法时，这种方法的样子。 请注意，只有参数声明被更改了：</p>
<p>// List as a typesafe alternative to a generic varargs parameter<br>
static <T> List<T> flatten(List&lt;List&lt;? extends T&gt;&gt; lists) {<br>
List<T> result = new ArrayList&lt;&gt;();<br>
for (List&lt;? extends T&gt; list : lists)<br>
result.addAll(list);<br>
return result;<br>
}<br>
复制ErrorOK!复制ErrorOK!<br>
　　然后可以将此方法与静态工厂方法 List.of 结合使用，以允许可变数量的参数。 请注意，这种方法依赖于 List.of 声明使用 @SafeVarargs 注解：</p>
<p>audience = flatten(List.of(friends, romans, countrymen));<br>
复制ErrorOK!复制ErrorOK!<br>
　　这种方法的优点是编译器可以证明这种方法是类型安全的。 不必使用 @SafeVarargs 注解来证明其安全性，也不用担心在确定安全性时可能会犯错。 主要缺点是客户端代码有点冗长，运行可能会慢一些。</p>
<p>这个技巧也可以用在不可能写一个安全的可变参数方法的情况下，就像第 147 页的 toArray 方法那样。它的列表模拟是 List.of 方法，所以我们甚至不必编写它；Java 类库作者已经为我们完成了这项工作。 pickTwo 方法然后变成这样：</p>
<p>static <T> List<T> pickTwo(T a, T b, T c) {<br>
switch(rnd.nextInt(3)) {<br>
case 0: return List.of(a, b);<br>
case 1: return List.of(a, c);<br>
case 2: return List.of(b, c);<br>
}<br>
throw new AssertionError();<br>
}<br>
复制ErrorOK!复制ErrorOK!<br>
　　main 方变成这样：</p>
<p>public static void main(String[] args) {<br>
List<String> attributes = pickTwo(“Good”, “Fast”, “Cheap”);<br>
}<br>
复制ErrorOK!复制ErrorOK!<br>
　　生成的代码是类型安全的，因为它只使用泛型，不是数组。</p>
<p>总而言之，可变参数和泛型不能很好地交互，因为可变参数机制是在数组上面构建的脆弱的抽象，并且数组具有与泛型不同的类型规则。 虽然泛型可变参数不是类型安全的，但它们是合法的。 如果选择使用泛型（或参数化）可变参数编写方法，请首先确保该方法是类型安全的，然后使用 @SafeVarargs 注解对其进行标注，以免造成使用不愉快。</p>
<ol start="33">
<li>优先考虑类型安全的异构容器<br>
　　泛型的常见用法包括集合，如 Set<E> 和 Map&lt;K，V&gt; 和单个元素容器，如 ThreadLocal<T> 和 AtomicReference<T>。 在所有这些用途中，它都是参数化的容器。 这限制了每个容器只能有固定数量的类型参数。 通常这正是你想要的。 一个 Set 有单一的类型参数，表示它的元素类型; 一个 Map 有两个，代表它的键和值的类型；等等。</li>
</ol>
<p>然而有时候，你需要更多的灵活性。 例如，数据库一行记录可以具有任意多列，并且能够以类型安全的方式访问它们是很好的。 幸运的是，有一个简单的方法可以达到这个效果。 这个想法是参数化键（key）而不是容器。 然后将参数化的键提交给容器以插入或检索值。 泛型类型系统用于保证值的类型与其键一致。</p>
<p>作为这种方法的一个简单示例，请考虑一个 Favorites 类，它允许其客户端保存和检索任意多种类型的 favorite 实例。 该类型的 Class 对象将扮演参数化键的一部分。其原因是这 Class 类是泛型的。 类的类型从字面上来说不是简单的 Class，而是 Class<T>。 例如，String.class 的类型为 Class<String>，Integer.class 的类型为 Class<Integer>。 当在方法中传递字面类传递编译时和运行时类型信息时，它被称为类型令牌（type token）[Bracha04]。</p>
<p>Favorites 类的 API 很简单。 它看起来就像一个简单 Map 类，除了该键是参数化的以外。 客户端在设置和获取 favorites 实例时呈现一个 Class 对象。 如下是 API：</p>
<p>// Typesafe heterogeneous container pattern - API<br>
public class Favorites {<br>
public <T> void putFavorite(Class<T> type, T instance);<br>
public <T> T getFavorite(Class<T> type);<br>
}<br>
复制ErrorOK!<br>
　　下面是一个演示 Favorites 类，保存，检索和打印喜欢的 String，Integer 和 Class 实例：</p>
<p>// Typesafe heterogeneous container pattern - client<br>
public static void main(String[] args) {<br>
Favorites f = new Favorites();<br>
f.putFavorite(String.class, “Java”);<br>
f.putFavorite(Integer.class, 0xcafebabe);<br>
f.putFavorite(Class.class, Favorites.class);</p>
<pre><code>String favoriteString = f.getFavorite(String.class);
int favoriteInteger = f.getFavorite(Integer.class);
Class&lt;?&gt; favoriteClass = f.getFavorite(Class.class);
System.out.printf(&quot;%s %x %s%n&quot;, favoriteString,
    favoriteInteger, favoriteClass.getName());
</code></pre>
<p>}<br>
复制ErrorOK!<br>
　　正如你所期望的，这个程序打印 Java cafebabe Favorites。 请注意，顺便说一下，Java 的 printf 方法与 C 语言的不同之处在于，你应该在 C 中使用 \n 的地方改用 %n。%n 用于生成适用于特定平台的行分隔符，在大多数平台上面的值为 \n，但并不是所有平台的分隔符都为 \n。</p>
<p>Favorites 实例是类型安全的：当你请求一个字符串时它永远不会返回一个整数。 它也是异构的：与普通 Map 不同，所有的键都是不同的类型。 因此，我们将 Favorites 称为类型安全异构容器（typesafe heterogeneous container）。</p>
<p>Favorites 的实现非常小巧。 这是完整的代码：</p>
<p>// Typesafe heterogeneous container pattern - implementation<br>
public class Favorites {<br>
private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;&gt;();</p>
<pre><code>public&lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123;
    favorites.put(Objects.requireNonNull(type), instance);
&#125;

public&lt;T&gt; T getFavorite(Class&lt;T&gt; type) &#123;
    return type.cast(favorites.get(type));
&#125;
</code></pre>
<p>}<br>
复制ErrorOK!<br>
　　这里有一些微妙的事情发生。 每个 Favorites 实例都由一个名为 favorites 私有的 Map&lt;Class&lt;?&gt;, Object&gt; 来支持。 你可能认为无法将任何内容放入此 Map 中，因为这是无限定的通配符类型，但事实恰恰相反。 需要注意的是通配符类型是嵌套的：它不是通配符类型的 Map 类型，而是键的类型。 这意味着每个键都可以有不同的参数化类型：一个可以是 Class<String>，下一个 Class<Integer> 等等。 这就是异构的由来。</p>
<p>接下来要注意的是，favorites 的 Map 的值类型只是 Object。 换句话说，Map 不保证键和值之间的类型关系，即每个值都是由其键表示的类型。 事实上，Java 的类型系统并不足以表达这一点。 但是我们知道这是真的，并在检索一个 favorite 时利用了这点。</p>
<p>putFavorite 实现很简单：只需将给定的 Class 对象映射到给定的 favorites 的实例即可。 如上所述，这丢弃了键和值之间的“类型联系（type linkage）”；无法知道这个值是不是键的一个实例。 但没关系，因为 getFavorites 方法可以并且确实重新建立这种关联。</p>
<p>getFavorite 的实现比 putFavorite 更复杂。 首先，它从 favorites Map 中获取与给定 Class 对象相对应的值。 这是返回的正确对象引用，但它具有错误的编译时类型：它是 Object（favorites map 的值类型），我们需要返回类型 T。因此，getFavorite 实现动态地将对象引用转换为 Class 对象表示的类型，使用 Class 的 cast 方法。</p>
<p>cast 方法是 Java 的 cast 操作符的动态模拟。它只是检查它的参数是否由 Class 对象表示的类型的实例。如果是，它返回参数；否则会抛出 ClassCastException 异常。我们知道，假设客户端代码能够干净地编译，getFavorite 中的强制转换不会抛出 ClassCastException 异常。 也就是说，favorites map 中的值始终与其键的类型相匹配。</p>
<p>那么这个 cast 方法为我们做了什么，因为它只是返回它的参数？ cast 的签名充分利用了 Class 类是泛型的事实。 它的返回类型是 Class 对象的类型参数：</p>
<p>public class Class<T> {<br>
T cast(Object obj);<br>
}<br>
复制ErrorOK!<br>
　　这正是 getFavorite 方法所需要的。 这正是确保 Favorites 类型安全，而不用求助一个未经检查的强制转换的 T 类型。</p>
<p>Favorites 类有两个限制值得注意。 首先，恶意客户可以通过使用原始形式的 Class 对象，轻松破坏 Favorites 实例的类型安全。 但生成的客户端代码在编译时会生成未经检查的警告。 这与正常的集合实现（如 HashSet 和 HashMap）没有什么不同。 通过使用原始类型 HashSet（条目 26），可以轻松地将字符串放入 HashSet<Integer> 中。 也就是说，如果你愿意为此付出一点代价，就可以拥有运行时类型安全性。 确保 Favorites 永远不违反类型不变的方法是，使 putFavorite 方法检查该实例是否由 type 表示类型的实例，并且我们已经知道如何执行此操作。只需使用动态转换：</p>
<p>// Achieving runtime type safety with a dynamic cast<br>
public<T> void putFavorite(Class<T> type, T instance) {<br>
favorites.put(type, type.cast(instance));<br>
}<br>
复制ErrorOK!<br>
　　java.util.Collections 中有一些集合包装类，可以发挥相同的诀窍。 它们被称为 checkedSet，checkedList，checkedMap 等等。 他们的静态工厂除了一个集合（或 Map）之外还有一个 Class 对象（或两个）。 静态工厂是泛型方法，确保 Class 对象和集合的编译时类型匹配。 包装类为它们包装的集合添加了具体化。 例如，如果有人试图将 Coin 放入你的 Collection<Stamp> 中，则包装类在运行时会抛出 ClassCastException。 这些包装类对于追踪在混合了泛型和原始类型的应用程序中添加不正确类型的元素到集合的客户端代码很有用。</p>
<p>Favorites 类的第二个限制是它不能用于不可具体化的（non-reifiable）类型（详见第 28 条）。 换句话说，你可以保存你最喜欢的 String 或 String[]，但不能保存 List<String>。 如果你尝试保存你最喜欢的 List<String>，程序将不能编译。 原因是无法获取 List<String> 的 Class 对象。 List<String>.class 是语法错误，也是一件好事。 List<String> 和 List<Integer> 共享一个 Class 对象，即 List.class。 如果“字面类型（type literals）”List<String> .class 和 List<Integer>.class 合法并返回相同的对象引用，那么它会对 Favorites 对象的内部造成严重破坏。 对于这种限制，没有完全令人满意的解决方法。</p>
<p>Favorites 使用的类型令牌 type tokens) 是无限制的：getFavorite 和 putFavorite 接受任何 Class 对象。 有时你可能需要限制可传递给方法的类型。 这可以通过一个有限定的类型令牌来实现，该令牌只是一个类型令牌，它使用限定的类型参数（详见第 30 条）或限定的通配符（详见第 31 条）来放置可以表示的类型的边界。</p>
<p>注解 API（详见第 39 条）广泛使用限定类型的令牌。 例如，以下是在运行时读取注解的方法。 此方法来自 AnnotatedElement 接口，该接口由表示类，方法，属性和其他程序元素的反射类型实现：</p>
<p>public <T extends Annotation><br>
T getAnnotation(Class<T> annotationType);<br>
复制ErrorOK!<br>
　　参数 annotationType 是表示注解类型的限定类型令牌。 该方法返回该类型的元素的注解（如果它有一个）；如果没有，则返回 null。 本质上，注解元素是一个类型安全的异构容器，其键是注解类型。</p>
<p>假设有一个 Class&lt;?&gt; 类型的对象，并且想要将它传递给需要限定类型令牌（如 getAnnotation）的方法。 可以将对象转换为 Class&lt;? extends Annotation&gt;，但是这个转换没有被检查，所以它会产生一个编译时警告（详见第 52 条）。 幸运的是，Class 类提供了一种安全（动态）执行这种类型转换的实例方法。 该方法被称为 asSubclass，并且它转换所调用的 Class 对象来表示由其参数表示的类的子类。 如果转换成功，该方法返回它的参数；如果失败，则抛出 ClassCastException 异常。</p>
<p>以下是如何使用 asSubclass 方法在编译时读取类型未知的注解。 此方法编译时没有错误或警告：</p>
<p>// Use of asSubclass to safely cast to a bounded type token<br>
static Annotation getAnnotation(AnnotatedElement element,<br>
String annotationTypeName) {<br>
Class&lt;?&gt; annotationType = null; // Unbounded type token<br>
try {<br>
annotationType = Class.forName(annotationTypeName);<br>
} catch (Exception ex) {<br>
throw new IllegalArgumentException(ex);<br>
}<br>
return element.getAnnotation(<br>
annotationType.asSubclass(Annotation.class));<br>
}<br>
复制ErrorOK!<br>
　　总之，泛型 API 的通常用法（以集合 API 为例）限制了每个容器的固定数量的类型参数。 你可以通过将类型参数放在键上而不是容器上来解决此限制。 可以使用 Class 对象作为此类型安全异构容器的键。 以这种方式使用的 Class 对象称为类型令牌。 也可以使用自定义键类型。 例如，可以有一个表示数据库行（容器）的 DatabaseRow 类型和一个泛型类型 Column<T> 作为其键。</p>
<!-- 文件: JVM 面试题.md -->
<h2 id="JVM-的主要组成部分及其作用">JVM 的主要组成部分及其作用</h2>
<ul>
<li>类加载器（ClassLoader）</li>
<li>运行时数据区（Runtime Data Area）</li>
<li>执行引擎（Execution Engine）</li>
<li>本地库接口（Native Interface）</li>
</ul>
<p>组件的作用： 首先通过类加载器（ClassLoader）会加载类文件到内存，Class loader只管加载，只要符合文件结构就加载。运行时数据区（Runtime Data Area)是jvm的重点，我们所有所写的程序都被加载到这里，之后才开始运行。而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来融合不同的语言为java所用,从而实现整个程序的功能。</p>
<h2 id="JVM-运行时数据区⭐">JVM 运行时数据区⭐</h2>
<ul>
<li>
<p>程序计数器</p>
<p>指向当前线程执行的字节码指令的地址（ 行号 ）。 这样做的<strong>用处是多线程操作时， 挂起的线程在重新激活后能够知道上次执行的位置。</strong></p>
</li>
<li>
<p>虚拟机栈</p>
<p>存储当前线程执行方法时所需要的数据，指令，返回地址。因此一个线程独享一块虚拟机栈 ，栈中内存的单位是栈帧。 每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</p>
</li>
<li>
<p>本地方法栈</p>
<p>本地方法栈为虚拟机使用到的 Native 方法服务。</p>
</li>
<li>
<p>堆</p>
<p>唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 详见堆内存模型。</p>
</li>
<li>
<p>方法区</p>
<p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。</p>
</li>
</ul>
<h3 id="堆">堆</h3>
<p>堆内存模型：</p>
<p><img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/JVM.png" alt="image-20200227234850635"></p>
<p><strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<h2 id="堆和栈的区别">堆和栈的区别</h2>
<ol>
<li>栈内存存储的是局部变量而堆内存存储的是实体；</li>
<li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</li>
<li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。、</li>
</ol>
<h3 id="分代回收">分代回收</h3>
<p>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p>
<p>因为年轻代中的对象基本都是朝生夕死的，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p>
<p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<h2 id="什么是双亲委派模型？⭐">什么是双亲委派模型？⭐</h2>
<p>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。</p>
<h2 id="双亲委派机制的作用">双亲委派机制的作用</h2>
<p>1、防止重复加载同一个<code>.class</code>。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。<br>
2、保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.class</code>，不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</p>
<h2 id="对象的创建过程？">对象的创建过程？</h2>
<h4 id="Step1-类加载检查">Step1:类加载检查</h4>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</p>
<h4 id="Step2-分配内存">Step2:分配内存</h4>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种。</p>
<h4 id="Step3-初始化零值">Step3:初始化零值</h4>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="Step4-设置对象头">Step4:设置对象头</h4>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong></p>
<h4 id="Step5-执行-init-方法">Step5:执行 init 方法</h4>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="类加载的执行过程？">类加载的执行过程？</h2>
<ol>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>检查：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ol>
<h2 id="怎么判断对象是否可以被回收？">怎么判断对象是否可以被回收？</h2>
<ul>
<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h2 id="Java-中都有哪些引用类型？">Java 中都有哪些引用类型？</h2>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<h2 id="常见的垃圾回收机制⭐">常见的垃圾回收机制⭐</h2>
<ol>
<li>引用计数法：引用计数法是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用计数器,当有引用连接至对象时,引用计数加1。当引用离开作用域或被置为null时,引用计数减1。虽然管理引用计数的开销不大,但这项开销在整个程序生命周期中将持续发生。垃圾回收器会在含有全部对象的列表上遍历,当发现某个对象引用计数为0时,就释放其占用的空间。</li>
<li>可达性分析算法：这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</li>
</ol>
<h2 id="jvm-有哪些垃圾回收算法⭐">jvm 有哪些垃圾回收算法⭐</h2>
<ul>
<li>停止-复制：先暂停程序的运行,然后将所有存活的对象从当前堆复制到另一个堆,没有被复制的对象全部都是垃圾。当对象被复制到新堆时,它们是一个挨着一个的,所以新堆保持紧凑排列,然后就可以按前述方法简单,直接的分配了。缺点是一浪费空间,两个堆之间要来回倒腾,二是当程序进入稳定态时,可能只会产生极少的垃圾,甚至不产生垃圾,尽管如此,复制式回收器仍会将所有内存自一处复制到另一处。</li>
<li>标记-清除：同样是从堆栈和静态存储区出发,遍历所有的引用,进而找出所有存活的对象。每当它找到一个存活的对象,就会给对象一个标记,这个过程中不会回收任何对象。只有全部标记工作完成的时候,清理动作才会开始。在清理过程中,没有标记的对象会被释放,不会发生任何复制动作。所以剩下的堆空间是不连续的,垃圾回收器如果要希望得到连续空间的话,就得重新整理剩下的对象。</li>
<li>标记-整理：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</li>
<li>分代收集算法：把Java堆分为新生代和老年代，然后根据各个年代的特点采用最合适的收集算法。新生代中，对象的存活率比较低，所以选用复制算法，老年代中对象存活率高且没有额外空间对它进行分配担保，所以使用“标记-清除”或“标记-整理”算法进行回收。</li>
</ul>
<h3 id="Minor-GC和Full-GC触发条件⭐">Minor GC和Full GC触发条件⭐</h3>
<ul>
<li>Minor GC触发条件：当Eden区满时，触发Minor GC。</li>
<li>Full GC触发条件：
<ol>
<li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
</li>
</ul>
<h3 id="GC中Stop-the-world（STW）⭐">GC中Stop the world（STW）⭐</h3>
<p>在执行垃圾收集算法时，Java应用程序的其他所有除了垃圾收集收集器线程之外的线程都被挂起。此时，系统只能允许GC线程进行运行，其他线程则会全部暂停，等待GC线程执行完毕后才能再次运行。这些工作都是由虚拟机在后台自动发起和自动完成的，是在用户不可见的情况下把用户正常工作的线程全部停下来，这对于很多的应用程序，尤其是那些对于实时性要求很高的程序来说是难以接受的。</p>
<p>但不是说GC必须STW,你也可以选择降低运行速度但是可以并发执行的收集算法，这取决于你的业务。</p>
<h3 id="哪些对象可以作为GC-Roots">哪些对象可以作为GC Roots</h3>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ol>
<h3 id="JVM锁优化和膨胀过程⭐">JVM锁优化和膨胀过程⭐</h3>
<ol>
<li>自旋锁：自旋锁其实就是在拿锁时发现已经有线程拿了锁，自己如果去拿会阻塞自己，这个时候会选择进行一次忙循环尝试。也就是不停循环看是否能等到上个线程自己释放锁。自适应自旋锁指的是例如第一次设置最多自旋10次，结果在自旋的过程中成功获得了锁，那么下一次就可以设置成最多自旋20次。</li>
<li>锁粗化：虚拟机通过适当扩大加锁的范围以避免频繁的拿锁释放锁的过程。</li>
<li>锁消除：通过逃逸分析发现其实根本就没有别的线程产生竞争的可能（别的线程没有临界量的引用），或者同步块内进行的是原子操作，而“自作多情”地给自己加上了锁。有可能虚拟机会直接去掉这个锁。</li>
<li>偏向锁：在大多数的情况下，锁不仅不存在多线程的竞争，而且总是由同一个线程获得。因此为了让线程获得锁的代价更低引入了偏向锁的概念。偏向锁的意思是如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作。</li>
<li>轻量级锁：当存在超过一个线程在竞争同一个同步代码块时，会发生偏向锁的撤销。当前线程会尝试使用CAS来获取锁，当自旋超过指定次数(可以自定义)时仍然无法获得锁，此时锁会膨胀升级为重量级锁。</li>
<li>重量级锁：重量级锁依赖对象内部的monitor锁来实现，而monitor又依赖操作系统的MutexLock（互斥锁）。当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现。</li>
</ol>
<h2 id="jvm-有哪些垃圾回收器？">jvm 有哪些垃圾回收器？</h2>
<ul>
<li>
<p>Serial：最早的单线程串行垃圾回收器。</p>
</li>
<li>
<p>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</p>
</li>
<li>
<p>ParNew：是 Serial 的多线程版本。</p>
</li>
<li>
<p>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</p>
</li>
<li>
<p>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</p>
</li>
<li>
<p>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</p>
</li>
<li>
<p>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p>
<p><strong>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</strong></p>
</li>
<li>
<p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
</li>
<li>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
</li>
<li>
<p>整堆回收器：G1</p>
</li>
</ul>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h2 id="详细介绍一下-CMS-垃圾回收器⭐">详细介绍一下 CMS 垃圾回收器⭐</h2>
<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="G1和CMS的比较">G1和CMS的比较</h3>
<ol>
<li>CMS收集器是获取最短回收停顿时间为目标的收集器，因为CMS工作时，GC工作线程与用户线程可以并发执行，以此来达到降低手机停顿时间的目的（只有初始标记和重新标记会STW）。但是CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。</li>
<li>CMS仅作用于老年代，是基于标记清除算法，所以清理的过程中会有大量的空间碎片。</li>
<li>CMS收集器无法处理浮动垃圾，由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。</li>
<li>G1是一款面向服务端应用的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短STW的停顿时间，它满足短时间停顿的同时达到一个高的吞吐量。</li>
<li>从JDK 9开始，G1成为默认的垃圾回收器。当应用有以下任何一种特性时非常适合用G1：Full GC持续时间太长或者太频繁；对象的创建速率和存活率变动很大；应用不希望停顿时间长(长于0.5s甚至1s)。</li>
<li>G1将空间划分成很多块（Region），然后他们各自进行回收。堆比较大的时候可以采用，采用复制算法，碎片化问题不严重。整体上看属于标记整理算法,局部(region之间)属于复制算法。</li>
<li>G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。所以 CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势，大小内存的界限是6GB到8GB。</li>
</ol>
<h3 id="i-操作的字节码指令⭐">i++操作的字节码指令⭐</h3>
<ol>
<li>将int类型常量加载到操作数栈顶</li>
<li>将int类型数值从操作数栈顶取出，并存储到到局部变量表的第1个Slot中</li>
<li>将int类型变量从局部变量表的第1个Slot中取出，并放到操作数栈顶</li>
<li>将局部变量表的第1个Slot中的int类型变量加1</li>
<li>表示将int类型数值从操作数栈顶取出，并存储到到局部变量表的第1个Slot中，即i中</li>
</ol>
<h2 id="说一下-jvm-调优的工具">说一下 jvm 调优的工具</h2>
<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
<p><strong>常用的 jvm 调优的参数都有哪些？</strong></p>
<ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
<h2 id="TODO：">TODO：</h2>
<ul>
<li>CMS GC回收分为哪几个阶段？分别做了什么事情？</li>
<li>CMS有哪些重要参数？</li>
<li>Concurrent Model Failure和ParNew promotion failed什么情况下会发生？</li>
<li>CMS的优缺点？</li>
<li>有做过哪些GC调优？</li>
<li>为什么要划分成年轻代和老年代？</li>
<li>年轻代为什么被划分成eden、survivor区域？</li>
<li>年轻代为什么采用的是复制算法？</li>
<li>老年代为什么采用的是标记清除、标记整理算法</li>
<li>什么情况下使用堆外内存？要注意些什么？</li>
<li>堆外内存如何被回收？</li>
</ul>
<!-- 文件: Java 容器.md -->
<h1>一 概览</h1>
<p>容器的思维导图：</p>
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/1.png"/> </div><br>
<h2 id="Collection">Collection</h2>
<h3 id="List">List</h3>
<p>Java 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类：<br>
分别是 ArrayList、Vector 和 LinkedList。</p>
<ul>
<li>ArrayList：ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数<br>
组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数<br>
组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进<br>
行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li>
<li>Vector：Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一<br>
个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，<br>
访问它比访问 ArrayList 慢。</li>
<li>LinkList：LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作<strong>堆</strong><br>
<strong>栈、队列和双向队列</strong>使用。</li>
</ul>
<h3 id="Set">Set</h3>
<p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，<strong>值不能重</strong><br>
<strong>复</strong>。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断<br>
的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方<br>
法。</p>
<ul>
<li>HashSet：基于哈希表实现，存入数据是按照哈希值，所以并不是按照存入的顺序排序，为保证存入的唯一性，存入元素哈希值相同时，会使用 equals 方法比较，如果比较出不同就放入同一个哈希桶里。</li>
<li>TreeSet：基于红黑树实现，支持有序性操作，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>LinkHashSet（ HashSet+LinkedHashMap ）：继承于 HashSet、又是基于 LinkedHashMap 来实现的， 具有 HashSet 的查找效率 。</li>
</ul>
<h3 id="Queue">Queue</h3>
<h2 id="Map">Map</h2>
<ol>
<li>HashMap： 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快<br>
的访问速度，但遍历顺序却是不确定的。 HashMap 非线程安全，底层实现为数组+链表+红黑树。</li>
<li>ConcurrentHashMap：<strong>支持并发操作的HashMap</strong>，在JDK1.7和1.8实现线程安全的方式不同。</li>
<li>HashTable：Hashtable 是遗留类，不建议使用，很多映射的常用功能与 HashMap 类似，通过 synchronized 把整个（table）表锁住来实现线程安全的，效率十分低下。</li>
<li>TreeMap： 红黑树实现，可排序，需要对一个有序的key集合进行遍历时建议使用。</li>
<li>LinkHashMap： 是 HashMap 的一个子类， 增加了一条双向链表， <strong>从而可以保存记录的插入顺序</strong>，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li>
</ol>
<h1>二 源码分析</h1>
<h2 id="ArrayList">ArrayList</h2>
<h3 id="1-定义">1.定义</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<p>ArrayList 是基于数组实现的，所以支持快速随机访问。 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>
<p><strong>RandomAccess</strong> 接口标识着该类支持快速随机访问（只是一个定义了类型的接口，无作用）。  <strong>Cloneable 接口</strong>，即覆盖了函数 clone()，<strong>能被克隆</strong>。  <strong>java.io.Serializable 接口</strong>，这意味着ArrayList<strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p>
<p>数组的默认大小为 10。</p>
<h3 id="2-扩容机制">2.扩容机制</h3>
<p><strong>核心方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程就是对旧数组位移运算得到新数组，然后把旧数组整个复制到新数组上，操作代价很高，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>补充：</p>
<p><strong>移位运算符简介</strong>：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移)和&gt;&gt;&gt;(无符号右移)。<strong>作用</strong>：<strong>对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</strong>  。</p>
<h3 id="3-添加和删除">3.添加和删除</h3>
<p><strong>在末尾添加元素：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里看到ArrayList在末尾添加元素的实质就相当于为数组赋值。</p>
<p><strong>在指定位置添加元素：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;    </span><br><span class="line">    rangeCheckForAdd(index);   	</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!! </span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);    </span><br><span class="line">    elementData[index] = element;    size++;&#125;</span><br></pre></td></tr></table></figure>
<p>让数组自己复制自己实现让index开始之后的所有成员后移一个位置。</p>
<p><strong>删除指定元素：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程是把需要删除的元素右边的元素向左移动一位，覆盖了需要删除的元素。调用了arraycopy，所以操作代价也很高。</p>
<h2 id="CopyOnWriteArrayList">CopyOnWriteArrayList</h2>
<p>concurrent 并发包下的类，是ArrayList的线程安全解决方案， 通过ReentrantLock获取对象锁的方式来实现线程安全。</p>
<p><strong>读写分离的特点</strong></p>
<p>读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写的操作需要加锁，防止并发写入导致数据丢失，不直接操作原数组，先copy一个数组进行操作，写完后setArray方法把新的复制数组赋值给旧数组。</p>
<p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>缺点：</p>
<ul>
<li>
<p>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</p>
</li>
<li>
<p>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</p>
</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="LinkedList">LinkedList</h2>
<h4 id="1-概览">1. 概览</h4>
<p>内部私有类Node：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<p>补充：<strong>transient</strong>关键字标记的成员变量不参与序列化过程。</p>
<p>综上可看出，LinkedList是由双向列表实现，使用Node存储节点信息，每个节点都有前节点（next），本节点（item），后节点（prev）。</p>
<h4 id="2-与-ArrayList-的比较">2.与 ArrayList 的比较</h4>
<ul>
<li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。</li>
<li>ArrayList插入删除元素时分两种情况：①把元素添加到末尾所需的时间复杂度是O(1)，②在指定位置添加删除元素时就需要移动整个数组，操作代价就比较大了。LinkedList 对于添加删除方法只需要断链然后更改指向，所需的消耗就很小了。</li>
<li>ArrayList 支持高效的随机元素访问 而LinkedList 不支持。</li>
<li>ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h2 id="HashMap">HashMap</h2>
<h4 id="1-整体原理分析">1.整体原理分析</h4>
<p>HashMap类中有一个非常重要的字段，就是  Node[] table，即哈希桶数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p>
<p>hash:hashcode经过扰动函数得到的值， 然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置，如果当前</p>
<p>位置存在hash和key值不相同的元素就使用拉链法解决冲突。</p>
<p><strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p>Node&lt;K,V&gt; next：next就是用于链表的指向。</p>
<p>所谓<strong>扰动函数</strong>指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p>底层存储结构：</p>
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/2.png"/> </div><br>
<h4 id="2-put方法分析">2.put方法分析</h4>
<p>map.put(“a”,“b”)的整个流程：</p>
<pre><code>1. 先判断散列表是否没有初始化或者为空，如果是就扩容
2. 根据键值 key 计算 hash 值，得到要插入的数组索引 
3. 判断要插入的那个数组是否为空：
  	1. 如果为空直接插入。
  	2. 如果不为空，判断 key 的值是否是重复（用 equals 方法）：
       	1. 如果是就直接覆盖
       	2. 如果不重复就再判断此节点是否已经是红黑树节点：
            	1. 如果是红黑树节点就把新增节点放入树中
            	2. 如果不是，就开始遍历链表：
                 	1. 循环判断直到链表最底部，到达底部就插入节点，然后判断是否大于链表长度是否大于8：
                      1. 如果大于8就转换为红黑树
                      2. 如果不大于8就继续下一步
                	2. 到底部之前发现有重复的值，就覆盖。
4. 判断是否需要扩容，如果需要就扩容。
</code></pre>
<p>下面上源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//tab: 引用当前hashMap的散列表</span></span><br><span class="line">	<span class="comment">//p: 表示当前散列表的元素</span></span><br><span class="line">	<span class="comment">//n: 表示散列表数组的长度</span></span><br><span class="line">	<span class="comment">//i: 表示路由寻址结果</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容（采用了延时初始化，第一次put才会初始化散列表。）</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 寻址找到的桶位为null</span></span><br><span class="line">    <span class="comment">//(n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 寻址找到的桶位已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等，也就是判断是否是重复的值。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 完全一致</span></span><br><span class="line">            	<span class="comment">//e:找到的一个与当前要插入的元素一直的元素</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；且为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//替换</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>综上put的方法流程图为：</p>
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/put方法流程图.png"/> </div><br>
<p>tip： JDK1.7之前的put方法和现在流程不同的地方就是采用头插法插入元素。</p>
<h4 id="3-扩容（resize方法）">3.扩容（resize方法）</h4>
<p>扩容会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 源码在下面，仔细阅读即可理解此方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//散列表已经被初始化了，是一次正常扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold：翻倍</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//散列表没有被初始化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始化的容量是已经指定了的</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 默认初始化容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//当前桶位有数据，但不清楚是什么数据。</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//方便 GC</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//如果是单个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//桶位已经形成链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;<span class="comment">//低位链表</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;<span class="comment">//高位链表</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引，给低位链表赋值</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap，给高位链表赋值</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到桶里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到桶里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在扩容时看原hash值新增的那个bit位是1还是0就好了，是0的话索引没有变，是1的话索引变成“原索引+oldCap（旧数组大小）”，下图位resize（）方法示意图：</p>
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/3.png"/> </div><br>
<h2 id="ConcurrentHashMap">ConcurrentHashMap</h2>
<p><strong>JDK1.7：</strong></p>
<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。  <strong>Segment 继承自 ReentrantLock ，默认的并发级别为 16 。</strong></p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承<br>
ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每<br>
个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p>结构如图：</p>
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/concurrentHashMap7.png"/> </div><br>
<p><strong>JDK1.8：</strong></p>
<p>使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。  synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<h2 id="HashSet">HashSet</h2>
<p>实现原理： HashSet底层由HashMap实现 ，值存放于HashMap的key上 ，HashMap的value统一为PRESENT 。</p>
<p>检查重复： 先对插入的元素的hashcode值和现有的元素的hashcode作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现，直接插入。但是如果发现有相同hashcode值的对象，这时会调用<code>equals（）</code>方法来检查hashcode相等的对象是否真的相同。  如果两者相同，HashSet就不会让加入操作成功 。</p>
<h2 id="LinkedHashMap">LinkedHashMap</h2>
<h3 id="LinkedHashMap-实现LRU（least-recently-used）">LinkedHashMap 实现LRU（least recently used）</h3>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="built_in">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TreeMap">TreeMap</h2>
<h3 id="TreeMap-其-key-对象为什么必须要实现-Compare-接口">TreeMap 其 key 对象为什么必须要实现 Compare 接口</h3>
<p>通过阅读 TreeMap 的 put 方法的源码发现：TreeMap 实现元素不重复就是通过调用 compareTo 方法，而要使用 compareTo 方法就必须实现Compare接口。</p>
<h2 id="BlockingQueue-的实现类">BlockingQueue 的实现类</h2>
<p>ArrayBlockingQueue 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</p>
<p>LinkedBlockingQueue 底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</p>
<p>DelayQueue是一个无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的Delayed 元素。</p>
<p>SynchronousQueue 本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</p>
<p>PriorityBlockingQueue 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</p>
<!-- 文件: Java基础.md -->
<h1>Java基础面试题</h1>
<h2 id="Java-语言有哪些特点-什么是Java？">Java 语言有哪些特点/什么是Java？</h2>
<ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>GC实现垃圾回收；</li>
<li>异常处理机制；</li>
<li>支持多线程；</li>
<li>支持网络编程并且很方便；</li>
<li>编译与解释并存；</li>
</ol>
<h2 id="面向对象和面向过程的区别">面向对象和面向过程的区别</h2>
<ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<h2 id="Java和C-的区别">Java和C++的区别?</h2>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong></li>
</ul>
<h2 id="Java有几种基本数据类型">Java有几种基本数据类型</h2>
<p>八种：<strong>byte</strong>,short,<strong>long</strong>,<strong>int</strong>,char,<strong>float,double,boolean</strong></p>
<h2 id="基本类型和引用类型？他们的区别">基本类型和引用类型？他们的区别</h2>
<p>除了8中基本数据类型都是引用类型， 为了面向对象操作的一致性，每种数据类型都有对应的包装类。</p>
<p><strong>不同点</strong>：</p>
<ul>
<li>
<p>赋值方法不同，基本类型直接赋值，引用类型通过 new 创建对象，然后再把对象赋予相应的变量。</p>
</li>
<li>
<p>比较方面的不同，== 号的比较：引用类型比较的是引用地址，基本类型比较的是值</p>
</li>
<li>
<p>在数据做为参数传递的时候，基本数据类型是值传递，而引用数据类型是引用传递（地址传递）。</p>
</li>
<li>
<p><strong>分别放在 JVM 的哪里？</strong></p>
</li>
</ul>
<p>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上（也不完全一定）。</p>
<p>而引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。</p>
<p><strong>引用类型的创建过程：</strong></p>
<p>现在为其创建一个对象MyDate d1 = new MyDate(8,8,2008);</p>
<p>在内存中的具体创建过程是：</p>
<p>1）首先在栈内存中位其d1分配一块空间；</p>
<p>2）然后在堆内存中为MyDate对象分配一块空间，并为其三个属性设初值0，0，0；</p>
<p>3）根据类MyDate中对属性的定义，为该对象的三个属性进行赋值操作；</p>
<p>4）调用构造方法，为三个属性赋值为8，8，2008；（注意这个时候d1与MyDate对象之间还没有建立联系）</p>
<p>5）将MyDate对象在堆内存中的地址，赋值给栈中的d1;通过句柄d1可以找到堆中对象的具体信息。</p>
<h2 id="重载和重写的区别">重载和重写的区别</h2>
<h4 id="重载">重载</h4>
<p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<h4 id="重写">重写</h4>
<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。<strong>也就是说方法提供的行为改变，而方法的外貌并没有改变。</strong></p>
<h2 id="Java-面向对象编程三大特性-封装-继承-多态">Java 面向对象编程三大特性: 封装 继承 多态</h2>
<h3 id="封装">封装</h3>
<p>把描述一个对象的属性和行为的代码封装在一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。</p>
<h3 id="继承">继承</h3>
<p>子类继承父类的特征和行为。子类可以有父类非私有的方法，属性。子类也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高代码之间的耦合性。</p>
<h3 id="多态">多态</h3>
<p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定(比如：向上转型，只有运行才能确定其对象属性)。方法覆盖和重载体现了多态性。</p>
<h2 id="final-在-java-中有什么作用？">final 在 java 中有什么作用？</h2>
<ul>
<li>final 修饰的类叫最终类，该类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量不可更改，<strong>其不可更改指的是其引用不可修改，对于引用类型值还是可能改变的，举个列子：String 内部对于 value 的定义；而对于基本类型来说就叫做常量了。</strong></li>
</ul>
<p><strong>final、finally、finalize 有什么区别？</strong></p>
<ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。</li>
</ul>
<h2 id="String-StringBuffer-和-StringBuilder-的区别是什么">String StringBuffer 和 StringBuilder 的区别是什么?</h2>
<p><strong>线程安全</strong></p>
<p><code>StringBuilder</code>是线程不安全的，效率较高；而<code>StringBuffer</code>是线程安全的，效率较低。</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>数据可变和不可变</strong></p>
<ol>
<li><code>String</code>的值不可变的。</li>
<li><code>StringBuffer</code>和<code>StringBuilder</code>的值是可变的，底层使用的是可变字符数组：<code>char[] value;</code></li>
</ol>
<p><strong>使用场景</strong></p>
<ul>
<li>如果需要操作少量的数据用 String</li>
<li>单线程操作字符串缓冲区的情况下操作大量数据使用 StringBuilder</li>
<li>多线程操作字符串缓冲区 下操作大量数据使用 StringBuffer</li>
</ul>
<h2 id="String-是如何实现不可变的？">String 是如何实现不可变的？</h2>
<p>首先要明确：<strong>String 不可变的是字符串的值不变。</strong></p>
<p>让我们看 String 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>
<p>从源码来看, String 类内部是用 char 数组来保存字符串的值, 并且 char[] 是 final 的, 这里的 final 意味着什么呢?</p>
<ul>
<li>value 必须在构造时为其赋值</li>
<li>赋值后 value 的引用不能再变</li>
</ul>
<p>当我们实例化一个 String 对象并得到其引用后, 构造已经结束了, 即 value 的引用已经不能再变了 。 那么 value 的值呢, 理论上是可以改变的, 只要我们拿到 value 的引用, 可以直接通过下标改变他的值 。</p>
<p>然而，因为 String 并没有提供接口来改变 value 的值，所以value 的值我们从 String 外部获取不到，也改变不了。这才是String 才是不可变的真正原因，并不仅仅是使用 final 修饰了 value 数据。</p>
<p>补充：然而，并不是真正的完全不能获取，利用反射可以直接获取类内部属性。</p>
<h2 id="String-为什么设置为不可变？">String 为什么设置为不可变？</h2>
<ul>
<li>为了实现字符串常量池(只有当字符是不可变的，字符串池才有可能实现)</li>
<li>为了线程安全(字符串自己便是线程安全的)</li>
<li>为了保证同一个对象调用 hashCode() 都产生相同的值，String 设置为不可变可以对这个条件有很好的支持，这也是 Map 类的 key 使用 String 的原因。</li>
</ul>
<h3 id="Exception、Error、运行时异常与一般异常有何异同-java-异常体系">Exception、Error、运行时异常与一般异常有何异同 /java 异常体系</h3>
<p><strong>所有的异常都是从Throwable继承而来的</strong></p>
<p><strong>Error</strong>是错误，对于所有的编译时期的错误以及系统错误都是通过Error抛出的。</p>
<p><strong>Exception</strong> 它规定的异常是程序本身可以处理的异常。</p>
<p><strong>checked exception</strong>可检查的异常，这是编码时非常常用的，所有checked exception都是需要在代码中处理的。它们的发生是可以预测的，正常的一种情况，可以合理的处理。比如IOException，或者一些自定义的异常。除了RuntimeException及其子类以外，都是checked exception。</p>
<p><strong>Unchecked Exception</strong></p>
<p>RuntimeException及其子类都是unchecked exception。比如NPE空指针异常，除数为0的算数异常ArithmeticException等等，这种异常是运行时发生，无法预先捕捉处理的。比如 NullPointerException ， SQLException， NumberFormatException ， FileNotFoundException， NoSuchMethodException。</p>
<h2 id="接口和抽象类的区别">接口和抽象类的区别</h2>
<ol>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。</li>
<li>接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ol>
<h2 id="Object类有哪些常用的方法？">Object类有哪些常用的方法？</h2>
<p>equals 方法，hashCode 方法，toString 方法，wait 和 notify 系列的几个， getclass</p>
<h3 id="和-equals-的区别">== 和 equals 的区别</h3>
<p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是 <code>==</code>比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h2 id="hashCode-与-equals-重要">hashCode 与 equals (重要)</h2>
<h3 id="hashCode（）介绍">hashCode（）介绍</h3>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h3 id="为什么要有-hashCode">为什么要有 hashCode</h3>
<p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是快速确定该对象在哈希表中的索引位置。</p>
<p><strong><code>hashCode() </code>在哈希表中才有用，在其它情况下没用</strong>。</p>
<h3 id="hashCode（）与equals（）的相关规定">hashCode（）与equals（）的相关规定</h3>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<p><strong>哪些场景下，子类需要重写 equals 方法和 hashCode 方法？</strong></p>
<p>需要判断两个对象状态的相等性的时候。</p>
<h3 id="为什么要重写-hashcode-还要重写-equals-？反之亦可问。">为什么要重写 hashcode( ) 还要重写 equals( ) ？反之亦可问。</h3>
<p>重写equals方法是为了按我们自己的想法来比较两个对象是否相等。如果不重写hashCode方法，可能出现<strong>具有相同含义的不同对象</strong>（他们的hashCode不同）的情况。而如果只重写 hashCode 不重写 equals 方法，因为 equals其实就是 == ，只是判断两个对象是否是同一个对象，所以不能得到我们想要的结果。所以需要同时重写equals和hashCode方法，目的是为了准确定位到我们期望的key。</p>
<p><strong>在 hashmap 中考虑：</strong></p>
<p>**通过阅读源码得知，在 hashMap 的 put 方法中，寻址找到的桶位如果上面已经有元素了，就判断 hash 值是否相同的同时也要通过 equals 判断（equals 是判断 map 的key 值），都为 true 才覆盖原来的值。如果只重写其中任意一个就会造成值的重复。 **</p>
<p>通俗点的解释</p>
<p>hashcode就类似 门牌号，小区非常大但定位你住哪里告诉门牌号就可以，非常快速定位到（非常像组数下标）</p>
<p>equals就是找到门牌号后需要比较里面具体的房间，少一个都不可以。</p>
<h2 id="Java序列化中如果有些字段不想进行序列化，怎么办？">Java序列化中如果有些字段不想进行序列化，怎么办？</h2>
<p>对于不想进行序列化的变量，使用transient关键字修饰。</p>
<p>transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<h3 id="幂等性">幂等性</h3>
<p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中，即f(f(x)) = f(x).简单的来说就是一个操作多次执行产生的结果与一次执行产生的结果一致。有些系统操作天生就具有幂等性例如数据库的select语句，但更多时候是需要程序员来做保证的，尤其是在分布式系统环境中，接口能不能做到保证幂等性对系统的影响可能是非常大的，例如很常见的支付下单等场景，由于分布式环境中网络的复杂性，用户误操作，网络抖动，消息重复，服务超时导致业务自动重试等等各种情况都可能会使线上数据产生了不一致，造成生产事故。</p>
<h2 id="怎么防止前端重复提交？">怎么防止前端重复提交？</h2>
<ol>
<li>提交按钮后屏蔽提交按钮(前端js控制)</li>
<li>前端生产唯一id， 后端在数据库设计时业务字段加唯一约束，防止数据库插入重复数据。</li>
<li>利用Session防止表单重复提交</li>
</ol>
<p><strong>ToDoList：</strong></p>
<p>描述下 HashMap get 方法的主要执行逻辑和流程；</p>
<p>Java 异常，什么是 checked Exception 和 unchecked Exception，举几个具体的例子；是否研究过 Spring Boot 中的异常；</p>
<p>ConcurrentHashMap 的特性和实现原理；</p>
<p>什么是分库分表，以及分库分表的具体方法和使用场景；</p>
<p>数据库事务的 ACID ；</p>
<p>什么是分布式锁以及其实现原理和使用场景；</p>
<h1>== 和 equals 的区别</h1>
<h2 id="解读">== 解读</h2>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：<br>
基本类型：比较的是值是否相同；<br>
引用类型：比较的是引用是否相同；</p>
<h2 id="equals">equals</h2>
<p>Object类的equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出其实就是==<br>
而String类中重写了父类Object的equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="type">char</span> v1[] = value;</span><br><span class="line">                <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出此方法就是先使用==比较，如果不同再把对象转换为字符串逐一字符比较。<br>
<strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是 <code>==</code>比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h1>缓存池和字符串常量池</h1>
<h2 id="缓存池">缓存池</h2>
<p>基本类型的valueOf() 方法会调用缓存池比较值的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断值是否在缓存池中，如果在的话就直接返回缓存池的内容，不在就新建一个。<br>
Integer 缓存池的大小默认为 -128~127。<br>
编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>基本类型对应的缓冲池如下：<br>
boolean values true and false<br>
all byte values<br>
short values between -128 and 127<br>
int values between -128 and 127<br>
char in the range \u0000 to \u007F<br>
在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<h2 id="字符串常量池">字符串常量池</h2>
<p><strong>字符串常量池 String Pool</strong><br>
保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。<br>
当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。<br>
如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<h3 id="String-s-new-String-“abc”-会创建几个对象">String s = new String(“abc”) 会创建几个对象</h3>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。<br>
“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；<br>
而使用 new 的方式会在堆中创建一个字符串对象。</p>
<!-- 文件: Linux面试题.md -->
<h1>Linux面试题</h1>
<p>如今程序员生产的代码99%都部署在linux环境下，代码发现缺陷，程序员的第一反应是到 Linux 上拉日志下来看。程序员不是运维，不需要掌握非常多复杂命令。</p>
<h1>推荐终端工具</h1>
<ul>
<li>SecureCRT</li>
<li>xshell</li>
</ul>
<h2 id="常用命令（重要）">常用命令（重要）</h2>
<p>ls/ll、cd、mkdir、rm-rf、cp、mv、ps -ef | grep xxx、kill、free-m、tar -xvf file.tar</p>
<p><strong>查看进程：</strong>（例：如何查看所有xx进程）</p>
<p>ps -ef | grep xxx</p>
<p>​	ps -aux | grep xxx（-aux显示所有状态）</p>
<p>**编辑 vi/vim ： **</p>
<p><strong>vi x.log</strong>  编辑你的日志文件</p>
<p>i  写入</p>
<p>:wq 保存退出</p>
<p>:q! 或者 ctrl+c 退出不保存</p>
<p>Shift+g 跳至当前文本最后一行，看最新的日志，都在最下面</p>
<h2 id="top⭐">top⭐</h2>
<p>显示系统中各个进程的资源占用状况，可以看是否有 CPU 占用过大的进程。</p>
<h2 id="less-和-more">less 和 more</h2>
<p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>
<h2 id="tail⭐">tail⭐</h2>
<p><strong>查看日志：</strong></p>
<p>tail -f  *.log ： 适用于实时查看日志,开发环境还行，生产就算了，日志会很多。</p>
<p><strong>tail -f error.log</strong>  ：生产中一般用这个实时看异常日志</p>
<p><strong>-f ：循环读取 ，用于查阅正在改变的日志文件。</strong></p>
<h2 id="netstat⭐">netstat⭐</h2>
<p>用于显示网络状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a (all)显示所有选项，netstat默认不显示LISTEN相关</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化成数字。(重要)</span><br><span class="line">-r 显示路由信息，路由表</span><br><span class="line">-e 显示扩展信息，例如uid等</span><br><span class="line">-s 按各个协议进行统计 (重要)</span><br></pre></td></tr></table></figure>
<h2 id="grep-查找⭐">grep 查找⭐</h2>
<p><strong>grep 是必备日志分析命令</strong></p>
<p><strong>grep -r ‘关键字如商品ID’ *.log （使用频率最高）</strong></p>
<p>**grep ‘关键字如商品ID’ *.log | grep 免费商品（在管道符前条件结果中，在加条件筛选下) **</p>
<p><strong>grep ‘关键字如商品ID’ *.log &gt;&gt; anan.txt 【相关日志输入到一个txt中，下载到本地慢慢看，我最喜欢】</strong></p>
<p>grep “被查找的字符串” 文件名<br>
<code>grep -n 2019-10-24 00:01:11' *.log</code><br>
可以查找 *.log文件中，查到时间内的所有信息</p>
<h2 id="查找特定文件-find">查找特定文件 find</h2>
<p><strong>find ~ -name “需要查找的文件名”</strong></p>
<p>比如：<code>find ~ -name &quot;本机ip.txt&quot;</code> 就可以得到文件名所在的目录</p>
<h3 id="管道操作符">管道操作符    |</h3>
<p>可将指令连接起来,前一个指令的输出作为后一个指令的输入</p>
<h3 id="杀僵尸进程">杀僵尸进程</h3>
<p>部分程序员，肯定喜欢下面命令</p>
<p>ps -ef | grep java 【先查java进程ID】</p>
<p>kill -9 java进程ID 【生产环境谨慎使用】</p>
<h2 id="对文件内容做统计-awk-⭐">对文件内容做统计 awk ⭐</h2>
<p>依次处理文件的每一行，并读取里面的每一个字段，可用作统计。</p>
<p>$ awk 动作 文件名</p>
<h2 id="批量替换-sed">批量替换 sed</h2>
<p>sed 配合正则表达式批量替换文本内容</p>
<h2 id="你经常使用哪些-Linux-命令，主要用来解决什么问题？">你经常使用哪些 Linux 命令，主要用来解决什么问题？</h2>
<!-- 文件: MySQL常见知识点总结.md -->
<h2 id="MySQL架构">MySQL架构</h2>
<h3 id="逻辑架构图和执行流程：">逻辑架构图和执行流程：</h3>
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/mysql逻辑架构.png"/> </div><br>
<h3 id="并发控制">并发控制</h3>
<ul>
<li><strong>表级锁：</strong> MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h3 id="事务">事务</h3>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h4 id="隔离级别">隔离级别</h4>
<p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p>
<p>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p>
<p>REPEATABLE-READ：可重复读，mysql 默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</p>
<p>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p><strong>补充：</strong></p>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据数据发生了变化。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h4 id="多版本并发控制-MVVC">多版本并发控制(MVVC)</h4>
<p>可以认为MVVC是行级锁的一个变种，innoDB采用了乐观锁的策略，在每行记录后保存两个隐藏列来实现，这两个列保存了行的版本号信息，每开启一个新事务，版本号自动更新，事务开始时刻的版本号作为事务的版本号。用来和查询到的记录所带的版本号进行比较来判断。</p>
<h3 id="存储引擎">存储引擎</h3>
<h4 id="InnoDB">InnoDB</h4>
<p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h4 id="MyISAM">MyISAM</h4>
<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h4 id="Myisam-和-InnoDB-的区别">Myisam 和 InnoDB 的区别</h4>
<ul>
<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁 (table-level locking)，而 InnoDB 支持行级锁(row-level locking) 和表级锁, 默认为行级锁，适合高并发操作。</li>
<li><strong>是否支持外键</strong>： MyISAM 不支持，而 InnoDB 支持</li>
<li><strong>是否支持事务</strong>：MyISAM 不支持，而 InnoDB 支持</li>
<li><strong>缓存</strong>：MyISAM 只缓存索引，InnoDB 缓存索引和真实数据，所以对内存要求高</li>
<li><strong>崩溃恢复</strong>：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
</ul>
<h1>数据库设计优化</h1>
<h2 id="字符串">字符串</h2>
<p>**char 和 varchar **</p>
<p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入 “abc” 三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>
<p>char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>
<p>使用场景：UTF-8这种复杂的字符集。</p>
<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h2 id="浮点数">浮点数</h2>
<p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 金额数据在程序中选用 BigDecimal 类，数据库中 DECIMAL</p>
<h2 id="时间和日期">时间和日期</h2>
<p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<h3 id="1-DATETIME">1. DATETIME</h3>
<p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h3 id="2-TIMESTAMP">2. TIMESTAMP</h3>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h2 id="数据库的三范式">数据库的三范式</h2>
<ul>
<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>
<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>
<li>第三范式：任何非主属性不依赖于其它非主属性。</li>
</ul>
<h3 id="如何设计一个关系型数据库？">如何设计一个关系型数据库？</h3>
<p>首先划分为两大部分，一个存储部分，类似文件系统将数据持久化到硬盘上， 另一个是程序实例部分，创建模块： 存储管理，缓存机制，SQL 解析，日志管理，权限划分，容灾机制 **，索引管理，锁模块 **。</p>
<h1>索引</h1>
<h2 id="B-树和-B-树的概念和区别">B 树和 B + 树的概念和区别</h2>
<p>1）B - 树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B + 树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。 2）在 B - 树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B + 树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 B - 树的性能好像要比 B + 树好，而<strong>在实际应用中却是 B + 树的性能要好些</strong>。</p>
<p>原因：</p>
<ul>
<li>因为 B + 树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比 B - 树多，树高比 B - 树小，这样带来的好处是减少磁盘访问次数。尽管 B + 树找到一个记录所需的比较次数要比 B - 树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B + 树的性能可能还会好些。</li>
<li>B + 树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等）。</li>
<li>B + 树的查询效率更加稳定，每次查询的效率一样。</li>
</ul>
<p><strong>哈希索引</strong></p>
<p>对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<h3 id="最佳左前缀法则">最佳左前缀法则</h3>
<p>如果索引了多列，要遵守最左前缀法则。指的是查询一定要<strong>从索引的最左前列开</strong>始并且<strong>不跳过索引中的列</strong>。如果<strong>查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</strong><br>
在创建索引的字段中第一个就是最左，每个左边的字段都是后面一个字段的一整个树，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。即要按照顺序命中索引。</p>
<h2 id="为什么使用索引能提高效率"><strong>为什么使用索引能提高效率</strong></h2>
<ol>
<li>数据索引的存储是有序的</li>
<li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li>
<li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li>
<li>避免全表扫描</li>
</ol>
<h3 id="为什么要使用索引？">为什么要使用索引？</h3>
<ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快 数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。</li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机IO变为顺序IO</li>
</ul>
<h2 id="索引的优点">索引的优点</h2>
<ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
</ul>
<h2 id="什么情况下应不建或少建索引">什么情况下应不建或少建索引</h2>
<ul>
<li>非常小的表</li>
<li>非常大的表，建议使用分区技术</li>
<li>经常插入、删除、修改的表</li>
<li>数据重复且分布平均的表字段</li>
</ul>
<h2 id="索引优化">索引优化</h2>
<h3 id="独立的列">独立的列</h3>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3 id="多列索引">多列索引</h3>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ id <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="前缀索引">前缀索引</h3>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h3 id="多列索引-2">多列索引</h3>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ id <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="索引列的顺序">索引列的顺序</h3>
<p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<h3 id="聚簇索引">聚簇索引</h3>
<p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p>
<p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行</p>
<p><strong>聚簇索引具有唯一性</strong>， 聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引 。</p>
<p><strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引。</p>
<p>聚簇索引和非聚簇索引类似查字典时直接根据经验查字的大概位置和先去查偏旁部首再去翻页查询类似。</p>
<p>MyISAM没有聚簇索引，都是二级索引。</p>
<h4 id="优点">优点</h4>
<ul>
<li>把相关数据保存在一起，减少了磁盘I/O。</li>
<li>数据访问更快。</li>
</ul>
<h3 id="覆盖索引">覆盖索引</h3>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称<br>
之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢<br>
覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。</p>
<h2 id="索引的使用经验">索引的使用经验</h2>
<ul>
<li>在经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
<li>在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>避免 where 子句中对宇段施加函数，这会造成无法命中索引。</li>
<li>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ul>
<h2 id="性能分析">性能分析</h2>
<h3 id="Explain">Explain</h3>
<h4 id="id">id</h4>
<p>如果没有子查询或者联合就只会显示1，如果有就按照顺序编号，对应其在 原始语句的位置。</p>
<h4 id="type">type</h4>
<p>type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次：<br>
system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p>简易版：<br>
system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL<br>
一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p>三个较差情况：<br>
1.range：<br>
只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引<br>
一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询<br>
这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。和index的消耗差不多。</p>
<p>2.index：<br>
依然是全表扫描，只不过是按照索引的次序而不是行，可以避免排序，出现index是sql使用了索引但是没用<strong>通过索引进行过滤</strong>，一般是使用了<strong>覆盖索引</strong>或者是<strong>利用索引进行了排序分组</strong> ，一般是where后面没有优化索引</p>
<p>3.all（最差）：<br>
Full Table Scan，将遍历全表以找到匹配的行</p>
<h4 id="key-len">key_len</h4>
<p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。<br>
key_len字段能够帮你检查是否充分的利用上了索引，越大越好</p>
<h4 id="Extra">Extra</h4>
<p>包含不适合在其他列中显示但十分重要的额外信息，主要用来检测<br>
order by，group by或者关联查询是否使用了索引。<br>
有以下几种情况：<br>
1.Using filesort 2.Using temporary 3.using join buffer都是很差的是使用方式。要建立索引。<br>
4.impossible where：不可能出现的情况，一般为 逻辑出现错误。<br>
5.USING index：<br>
利用索引进行了排序或分组，<br>
表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！<br>
如果同时出现using where，表明索引被用来执行索引键值的查找;<br>
如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</p>
<h2 id="查询优化">查询优化</h2>
<p><strong>单表查询优化</strong><br>
<strong>常见索引失效：</strong><br>
1 . 系统中经常出现的sql语句如下：<br>
EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30</p>
<p>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=4</p>
<p>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=4 AND <a target="_blank" rel="noopener" href="http://emp.name">emp.name</a> = ‘abcd’</p>
<p>解决：<br>
<strong>where后筛选字段有多少就建立多少索引</strong></p>
<p>CREATE INDEX idx_age_deptid_name ON emp(age,deptid,NAME)</p>
<p>1.<strong>最佳左前缀法则</strong></p>
<p>2.不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描,<strong>在where后使用计算、函数、(自动or手动)类型转换都会使索引失效</strong></p>
<p>3.存储引擎不能使用索引中范围条件右边的列，即在建立索引时，范围查询要放到最后</p>
<p>4.mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</p>
<p><a target="_blank" rel="noopener" href="http://5.is">5.is</a> not null 也无法使用索引,但是is null是可以使用索引的</p>
<p>6.like以通配符开头(’%abc…’)mysql索引失效会变成全表扫描的操作</p>
<p>7.字符串不加单引号索引失效，javabean类型和mysql字段的字符类型要一致，不然所以会失效。</p>
<p><strong>关联查询优化</strong></p>
<p>1、保证被驱动表的join字段已经被索引</p>
<p>2、left join 时，选择小表作为驱动表，大表作为被驱动表。</p>
<p>3、inner join 时，mysql会自己帮你把小结果集的表选为驱动表。</p>
<p>4、子查询尽量不要放在被驱动表，有可能使用不到索引。</p>
<p>5、能够直接多表关联的尽量直接关联，不用子查询。</p>
<p>子查询优化：</p>
<p>尽量不要使用not in 或者 not exists</p>
<p>用left outer join on xxx is null 替代</p>
<p><strong>排序分组优化</strong>：</p>
<p>普通order by不能使用索引</p>
<p><strong>无过滤 不索引</strong>，可加上过滤条件，使用索引</p>
<p><strong>顺序错，必排序</strong>排序的顺序要对应</p>
<p><strong>方向反 必排序</strong> desc asc要一样</p>
<p>ORDER BY子句，尽量使用Index方式排序,避免使用FileSort方式排序</p>
<p>group by 使用索引的原则几乎跟order by一致 ，唯一区别是groupby 即使没有过滤条件用到索引，也可以直接使用索引。</p>
<p><code>最后使用索引的手段：覆盖索引 即不要使用select * </code></p>
<!-- 文件: MySQL面试题.md -->
<h1>MySQL面试题</h1>
<h2 id="如何设计一个关系型数据库？-2">如何设计一个关系型数据库？</h2>
<p>首先划分为两大部分，一个存储部分，类似文件系统将数据持久化到硬盘上，<br>
另一个是程序实例部分，创建模块：<br>
存储管理，缓存机制，SQL解析，日志管理，权限划分，容灾机制**，索引管理，锁模块**。</p>
<h2 id="数据库的三范式是什么？">数据库的三范式是什么？</h2>
<ul>
<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>
<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。</li>
<li>第三范式：任何非主属性不依赖于其它非主属性。</li>
</ul>
<h2 id="事务的基本要素-ACID⭐">事务的基本要素 ACID⭐</h2>
<p>Atomicity（原子性）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</p>
<p>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</p>
<p>Isolation（隔离性）：同一时间，只允许一个事务操作同一数据，不同的事务之间彼此没有任何干扰。 事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p>Durability（持久性）：事务处理结束后，对数据的修改是永久的。</p>
<h2 id="char-和-varchar-的区别是什么？">char 和 varchar 的区别是什么？</h2>
<p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入&quot;abc&quot;三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>
<p>char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>
<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h2 id="where与having的区别">where与having的区别</h2>
<ul>
<li>
<p>用的地方不一样</p>
<p>where可以用于select、update、delete和insert into values(select * from table where …)语句中。</p>
<p>having只能用于select语句中</p>
</li>
<li>
<p>执行的顺序不一样</p>
<p>where的搜索条件是在执行语句进行分组之前应用</p>
<p>having的搜索条件是在分组条件后执行的</p>
<p>即如果where和having一起用时，where会先执行，having后执行</p>
</li>
</ul>
<h2 id="数据库的事务隔离-事务隔离级别⭐">数据库的事务隔离/事务隔离级别⭐</h2>
<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p>
<p>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p>
<p>REPEATABLE-READ：可重复读，mysql默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</p>
<p>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p>在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决是不彻底的。 <strong>通过next key lock解决了幻读的问题。</strong></p>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p><strong>补充：</strong></p>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据数据发生了变化。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h3 id="如何解决事务的并发问题⭐">如何解决事务的并发问题⭐</h3>
<p><strong>1. 版本检查</strong></p>
<p>在数据库中保留“版本”字段，跟随数据同时读写，以此判断数据版本。版本可能是时间戳或状态字段。</p>
<p>下例中的 WHERE 子句就实现了简单的版本检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table SET status = 1 WHERE id=1 AND status = 0;</span><br></pre></td></tr></table></figure>
<p>版本检查能够作为“乐观锁”，解决更新丢失的问题。</p>
<p><strong>2.1 共享锁与排它锁</strong></p>
<p>共享锁（Shared locks, S-locks）</p>
<p>基本锁类型之一。加共享锁的对象只允许被当前事务和其他事务读。也称读锁。</p>
<p>能给未加锁和添加了S锁的对象添加S锁。对象可以接受添加多把S锁。</p>
<p>排它锁（Exclusive locks, X-locks）</p>
<p>基本锁类型之一。加排它锁的对象只允许被当前事务读和写。也称独占锁，写锁。</p>
<p>只能给未加锁的对象添加X锁。对象只能接受一把X锁。加X锁的对象不能再加任何锁。</p>
<p>更新锁（Update locks, U-locks）</p>
<p>锁类型之一。引入它是因为多数数据库在实现加X锁时是执行了如下流程：先加S锁，添加成功后尝试更换为X锁。这时如果有两个事务同时加了S锁，尝试换X锁，就会发生死锁。因此增加U锁，<strong>U锁代表有更新意向，只允许有一个事务拿到U锁，该事务在发生写后U锁变X锁，未写时看做S锁。</strong></p>
<p><strong>悲观锁与乐观锁</strong></p>
<p>这两种锁的说法，主要是对“是否真正在数据库层面加锁”进行讨论。</p>
<p>悲观锁（Pessimistic Locking）</p>
<p>悲观锁假定当前事务操纵数据资源时，肯定还会有其他事务同时访问该数据资源，为了避免当前事务的操作受到干扰，先锁定资源。<strong>悲观锁需使用数据库的锁机制实现</strong>，如使用行级排他锁或表级排它锁。</p>
<p>乐观锁（Optimistic Locking）</p>
<p>乐观锁假定当前事务操纵数据资源时，不会有其他事务同时访问该数据资源，因此不在数据库层次上的锁定。<strong>乐观锁使用由程序逻辑控制的技术</strong>来避免可能出现的并发问题。</p>
<p>唯一能够同时保持高并发和高可伸缩性的方法就是使用带版本检查的乐观锁。</p>
<p>乐观锁不能解决脏读的问题，因此仍需要数据库至少启用“读已提交”的事务隔离级别。</p>
<h2 id="说一下乐观锁和悲观锁？⭐">说一下乐观锁和悲观锁？⭐</h2>
<p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
<p>（如SVN、GIT提交代码就是这样的）</p>
<p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p>
<p>一般是 where id=XX for update 来实现 （一般银行转账、工单审批）</p>
<p><strong>优缺点：</strong></p>
<p>乐观锁：性能高、重试失败成本不高建议乐观</p>
<p>悲观锁：性能低，但安全，失败成功高建议悲观，使用不当有死锁风险</p>
<h2 id="多版本并发控制-MVCC-⭐">多版本并发控制(MVCC)⭐</h2>
<p>(Multi-Version Concurrency Control)</p>
<p>可以认为MVCC是行级锁的一个变种，innoDB采用了乐观锁的策略，在每行记录后保存两个隐藏列来实现，这两个列保存了行的版本号信息，每开启一个新事务，版本号自动更新，事务开始时刻的版本号作为事务的版本号。用来和查询到的记录所带的版本号进行比较来判断。</p>
<h2 id="MySQL逻辑架构和执行流程？⭐">MySQL逻辑架构和执行流程？⭐</h2>
<p><img src="C:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CDesktop%5Cgithub%E7%AC%94%E8%AE%B0%5CMySQL%5C1.png" alt="1"></p>
<ul>
<li>最上层的服务类似其他CS结构，比如连接处理，授权处理。</li>
<li>第二层是Mysql的服务层，包括SQL的解析分析优化，存储过程触发器视图等也在这一层实现。</li>
<li>最后一层是存储引擎的实现。</li>
</ul>
<h2 id="说一下-mysql-常用的引擎？">说一下 mysql 常用的引擎？</h2>
<p><strong>InnoDB 引擎</strong>：MySQL 的5.5之后的默认引擎，InnoDB 引擎提供了对数据库事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>
<p><strong>MyISAM 引擎</strong>：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>
<h2 id="Myisam和InnoDB的区别⭐">Myisam和InnoDB的区别⭐</h2>
<ul>
<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁，适合高并发操作。</li>
<li><strong>是否支持外键</strong>： MyISAM不支持，而InnoDB支持</li>
<li><strong>是否支持事务</strong>：MyISAM不支持，而InnoDB支持</li>
<li><strong>缓存</strong>：MyISAM只缓存索引，InnoDB缓存索引和真实数据，所以对内存要求高</li>
<li><strong>崩溃恢复</strong>：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
</ul>
<h2 id="mysql-索引是怎么实现的？">mysql 索引是怎么实现的？</h2>
<p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的 。</p>
<h2 id="B树和B-树的概念和区别">B树和B+树的概念和区别</h2>
<p>1）先说一下B-树是一种多路搜索树，关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。<br>
2）在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而<strong>在实际应用中却是B+树的性能要好些</strong>。</p>
<h2 id="为什么选择B-树作为索引结构⭐">为什么选择B+树作为索引结构⭐</h2>
<ul>
<li>因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些。</li>
<li>B+树的叶子节点使用指针连接在一起，方便顺序遍历和范围查询，这也是优于hash索引的地方。</li>
<li>B+树的查询效率更加稳定，每次查询的效率一样。</li>
</ul>
<p><strong>Hash索引底层是哈希表</strong>，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，<strong>哈希索引只适用于等值查询的场景</strong>。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</p>
<ul>
<li>二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。</li>
<li>平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。</li>
<li>红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。</li>
</ul>
<h2 id="B-树的叶子节点都可以存哪些东西⭐">B+树的叶子节点都可以存哪些东西⭐</h2>
<p>可能存储的是整行数据，也有可能是主键的值</p>
<h2 id="什么样的信息能成为索引">什么样的信息能成为索引</h2>
<p>主键，唯一键，普通键都可，只要能让数据有一定区分性的字段。</p>
<h3 id="聚簇索引⭐">聚簇索引⭐</h3>
<p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p>
<p>非聚簇索引：将数据存储金和索引分开的结构，索引结构的叶子节点指向了数据的对应行</p>
<p><strong>聚簇索引具有唯一性</strong>， 一个表仅有一个聚簇索引 。</p>
<p><strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引。</p>
<p>聚簇索引和非聚簇索引类似查字典时直接根据经验查字的大概位置和先去查偏旁部首再去翻页查询类似。</p>
<p>MyISAM没有聚簇索引，都是二级索引。</p>
<h4 id="优点-2">优点</h4>
<ul>
<li>把相关数据保存在一起，减少了磁盘I/O。</li>
<li>数据访问更快。</li>
</ul>
<h3 id="覆盖索引⭐">覆盖索引⭐</h3>
<p>指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。</p>
<h2 id="最佳左前缀法则⭐">最佳左前缀法则⭐</h2>
<p>指的是查询从索引的最左前列开始并且不跳过索引中的列。<br>
在创建索引的字段中第一个就是最左，每个左边的字段都是后面一个字段的一整个树，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。<strong>要按照顺序命中索引</strong></p>
<h2 id="mysql-问题排查都有哪些手段？">mysql 问题排查都有哪些手段？</h2>
<ul>
<li>使用 show processlist 命令查看当前所有连接信息。</li>
<li>使用 explain 命令查询 SQL 语句执行计划。</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ul>
<h2 id="性能分析的重点字段">性能分析的重点字段</h2>
<h4 id="type-2">type</h4>
<p>type显示的是访问类型 system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL,一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p>三个较差情况：<br>
1.range：<br>
只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引<br>
一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询<br>
这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p>
<p>2.index：<br>
出现index是sql使用了索引但是没用<strong>通过索引进行过滤</strong>，一般是使用了<strong>覆盖索引</strong>或者是<strong>利用索引进行了排序分组</strong> ，一般是where后面没有优化索引</p>
<p>3.all（最差）：<br>
Full Table Scan，将遍历全表以找到匹配的行</p>
<p>备注：一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<h4 id="Extra-2">Extra</h4>
<p>包含不适合在其他列中显示但十分重要的额外信息，主要用来检测<br>
order by，group by或者关联查询是否使用了索引。<br>
有以下几种情况：<br>
1.Using filesort 2.Using temporary 3.using join buffer都是很差的是使用方式。要建立索引。<br>
4.impossible where：不可能出现的情况，一般为 逻辑出现错误。<br>
5.USING index：<br>
利用索引进行了排序或分组，<br>
表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！<br>
如果同时出现using where，表明索引被用来执行索引键值的查找;<br>
如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</p>
<h2 id=""></h2>
<ol>
<li>模糊查询 %like</li>
<li>索引列参与计算,使用了函数</li>
<li>非最左前缀顺序</li>
<li>where对null判断</li>
<li>where不等于</li>
<li>or操作有至少一个字段没有索引</li>
<li>需要回表的查询结果集过大（超过配置的范围）</li>
</ol>
<h2 id="sql-优化可以从哪些方面考虑？⭐">sql 优化可以从哪些方面考虑？⭐</h2>
<p>主要是从怎么<strong>合理创建索引 合理编写 SQL 语句和防止索引失效 合理创建表字段</strong>这3个方面入手</p>
<ul>
<li>
<p><strong>合理创建索引：</strong></p>
</li>
<li>
<p><strong>合理编写 SQL 语句：</strong></p>
<p>不使用 select *，使用 LIMIT 语句来限制返回的数据，IN包含的值不应过多等</p>
</li>
<li>
<p>**防止索引失效：**保证最左前缀法则，尽量不适用前缀模糊查询 %like，避免索引列参与计算或使用了函数，避免在where子句中对字段进行null值判断，看看表编码，表字段是否一样，联合索引中范围查询会让后面的索引字段失效，join查询时要用小表驱动大表</p>
</li>
<li>
<p><strong>合理创建表字段：</strong> 最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库</p>
</li>
</ul>
<h2 id="索引的使用经验-2">索引的使用经验</h2>
<p>创建索引考虑几个因素：</p>
<p>覆盖索引：因为覆盖索引可以减少回表的次数，而且在MySQL5.6后增加了一个索引下推的功能，可以在让覆盖索引配合索引下推，尽量减少回表的次数。</p>
<p>可以explain命令查看执行计划时看到 extra 列的 using index condition 是说明用到了索引， Using filesort，Using temporary 都是不好的，看rows 列可以知道扫描的行数，可以根据这个判断是否需要优化。</p>
<p>我们可以考虑在读少写多的场景下（日志，账单），我们可以使用普通索引，因为innodb对普通索引做了优化，使用了 <strong>Change buffer</strong>，它可以把写操作缓存下来，在读的时候再去merge，这样可以减少io次数，提高语句执行速度，提高内存利用率。</p>
<p>还可以考虑索引统计信息是否有问题，analyze table重新统计信息，因为索引信息并不是一个准确值，是一个随机采样的过程。如果发现执行计划中的key列使用的索引不好时，应急预案可以考虑使用 force index 强制索引</p>
<h2 id="数据库调优经验">数据库调优经验</h2>
<p>使用了索引却仍然不是很快，就使用  explain 分析了一下发现表中有多个索引，因为可能涉及回表，排序的操作，MySQL 优化器选用了错误的索引导致查询效率偏低，然后通过 SQL 语句中使用 useindex 来指定索引解决。</p>
<h2 id="批量往mysql导入1000万数据有什么方法？">批量往mysql导入1000万数据有什么方法？</h2>
<ul>
<li>
<p>减少IO次数</p>
</li>
<li>
<p>SQL写法优化，一条SQL语句插入多条数据</p>
</li>
<li>
<p>合理设置批量大小</p>
</li>
<li>
<p>尽量顺序插入， 减少索引的维护压力</p>
</li>
</ul>
<h3 id="redolog-undolog-binlog">redolog,undolog,binlog</h3>
<ul>
<li>undoLog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如&quot;把id=‘B’ 修改为id = ‘B2’ ，那么undo日志就会用来存放id ='B’的记录”。当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,则会使用undo日志来实现回滚操作,保证事务的一致性。当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</li>
<li>redoLog 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。</li>
<li>binlog由Mysql的Server层实现,是逻辑日志,记录的是sql语句的原始逻辑，比如&quot;把id=‘B’ 修改为id = ‘B2’。binlog会写入指定大小的物理文件中,是追加写入的,当前文件写满则会创建新的文件写入。 产生:事务提交的时候,一次性将事务中的sql语句,按照一定的格式记录到binlog中。用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑),实现主从同步。业务数据不一致或者错了，用binlog恢复。</li>
</ul>
<h3 id="binlog和redolog的区别">binlog和redolog的区别</h3>
<ol>
<li>redolog是在InnoDB存储引擎层产生，而binlog是MySQL数据库的上层服务层产生的。</li>
<li>两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句。而innodb存储引擎层面的重做日志是物理日志。</li>
<li>两种日志与记录写入磁盘的时间点不同，binlog日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。</li>
<li>binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redolog是循环使用。</li>
<li>binlog可以作为恢复数据使用，主从复制搭建，redolog作为异常宕机或者介质故障后的数据恢复使用。</li>
</ol>
<!-- 文件: Mybatis.md -->
<h1>MyBatis 整体架构</h1>
<p>MyBatis 最上面是接口层，接口层就是开发人员在 Mapper 或者是 Dao 接口中的接口定义，是查询、新增、更新还是删除操作；中间层是数据处理层，主要是配置 Mapper -&gt; XML 层级之间的参数映射，SQL 解析，SQL 执行，结果映射的过程。上述两种流程都由基础支持层来提供功能支撑，基础支持层包括连接管理，事务管理，配置加载，缓存处理等。</p>
<p><img src="C:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200220202650971.png" alt="image-20200220202650971"></p>
<h2 id="接口层">接口层</h2>
<p>在不与 Spring 集成的情况下，使用 MyBatis 执行数据库的操作主要如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;myBatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(is);</span><br><span class="line">sqlSession = factory.openSession();</span><br></pre></td></tr></table></figure>
<p>其中的<code>SqlSessionFactory</code>,<code>SqlSession</code>是 MyBatis 接口的核心类，尤其是 SqlSession，这个接口是 MyBatis 中最重要的接口，这个接口能够让你执行命令，获取映射，管理事务。</p>
<h4 id="数据处理层"><strong>数据处理层</strong></h4>
<ul>
<li><strong>配置解析</strong></li>
</ul>
<p>在 Mybatis 初始化过程中，会加载 <code>mybatis-config.xml</code> 配置文件、映射配置文件以及 Mapper 接口中的注解信息，解析后的配置信息会形成相应的对象并保存到 <code>Configration</code> 对象中。之后，根据该对象创建 SqlSessionFactory 对象。待 Mybatis 初始化完成后，可以通过 SqlSessionFactory 创建 SqlSession 对象并开始数据库操作。</p>
<ul>
<li><strong>SQL 解析与 scripting 模块</strong></li>
</ul>
<p>Mybatis 实现的动态 SQL 语句，几乎可以编写出所有满足需要的 SQL。</p>
<p>Mybatis 中 scripting 模块会根据用户传入的参数，解析映射文件中定义的动态 SQL 节点，形成数据库能执行的 SQL 语句。</p>
<ul>
<li><strong>SQL 执行</strong></li>
</ul>
<p>SQL 语句的执行涉及多个组件，包括 MyBatis 的四大核心，它们是: <code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>。SQL 的执行过程可以用下面这幅图来表示</p>
<p><img src="C:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200220202531623.png" alt="image-20200220202531623"></p>
<h4 id="基础支持层"><strong>基础支持层</strong></h4>
<ul>
<li>反射模块</li>
</ul>
<p>Mybatis 中的反射模块，对 Java 反射进行了很好的封装，提供了简易的 API，方便上层调用，并且对反射操作进行了一系列的优化，比如，缓存了类的 <code>元数据（MetaClass）</code>和对象的<code>元数据（MetaObject）</code>，提高了反射操作的性能。</p>
<ul>
<li>类型转换模块</li>
</ul>
<p>Mybatis 的别名机制，能够简化配置文件，该机制是类型转换模块的主要功能之一。类型转换模块的另一个功能<strong>是实现 JDBC 类型与 Java 类型的转换</strong>。在 SQL 语句绑定参数时，会将数据由 Java 类型转换成 JDBC 类型；在映射结果集时，会将数据由 JDBC 类型转换成 Java 类型。</p>
<ul>
<li>日志模块</li>
</ul>
<p>在 Java 中，有很多优秀的日志框架，如 Log4j、Log4j2、slf4j 等。Mybatis 除了提供了详细的日志输出信息，还能够集成多种日志框架，其日志模块的主要功能就是集成第三方日志框架。</p>
<ul>
<li>资源加载模块</li>
</ul>
<p>该模块主要封装了类加载器，确定了类加载器的使用顺序，并提供了加载类文件和其它资源文件的功能。</p>
<ul>
<li>解析器模块</li>
</ul>
<p>该模块有两个主要功能：一个是封装了 <code>XPath</code>，为 Mybatis 初始化时解析 <code>mybatis-config.xml</code>配置文件以及映射配置文件提供支持；另一个为处理动态 SQL 语句中的占位符提供支持。</p>
<ul>
<li>数据源模块</li>
</ul>
<p>Mybatis 自身提供了相应的数据源实现，也提供了与第三方数据源集成的接口。数据源是开发中的常用组件之一，很多开源的数据源都提供了丰富的功能，如连接池、检测连接状态等，选择性能优秀的数据源组件，对于提供 ORM 框架以及整个应用的性能都是非常重要的。</p>
<ul>
<li>事务管理模块</li>
</ul>
<p>一般地，Mybatis 与 Spring 框架集成，由 Spring 框架管理事务。但 Mybatis 自身对数据库事务进行了抽象，提供了相应的事务接口和简单实现。</p>
<ul>
<li>缓存模块</li>
</ul>
<p>Mybatis 中有<code>一级缓存</code>和<code>二级缓存</code>，这两级缓存都依赖于缓存模块中的实现。但是需要注意，这两级缓存与 Mybatis 以及整个应用是运行在同一个 JVM 中的，共享同一块内存，如果这两级缓存中的数据量较大，则可能影响系统中其它功能，所以需要缓存大量数据时，优先考虑使用 Redis、Memcache 等缓存产品。</p>
<ul>
<li>Binding 模块</li>
</ul>
<p>在调用 <code>SqlSession</code> 相应方法执行数据库操作时，需要制定映射文件中定义的 SQL 节点，如果 SQL 中出现了拼写错误，那就只能在运行时才能发现。为了能尽早发现这种错误，Mybatis 通过 Binding 模块将用户自定义的 Mapper 接口与映射文件关联起来，系统可以通过调用自定义 Mapper 接口中的方法执行相应的 SQL 语句完成数据库操作，从而避免上述问题。注意，在开发中，我们只是创建了 Mapper 接口，而并没有编写实现类，这是因为 Mybatis 自动为 Mapper 接口创建了动态代理对象。</p>
<h1>MyBatis 核心组件</h1>
<h2 id="SqlSessionFactory">SqlSessionFactory</h2>
<p>SqlSessionFactory 是 MyBatis 框架中的一个接口，它主要负责的是</p>
<ul>
<li>MyBatis 框架初始化操作</li>
<li>为开发人员提供<code>SqlSession</code> 对象</li>
</ul>
<h3 id="SqlSessionFactory-的执行流程">SqlSessionFactory 的执行流程</h3>
<p>下面来对 SqlSessionFactory 的执行流程来做一个分析</p>
<p>首先第一步是 SqlSessionFactory 的创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>
<p>从这行代码入手，首先创建了一个 <code>SqlSessionFactoryBuilder</code> 工厂，这是一个建造者模式的设计思想，由 builder 建造者来创建 SqlSessionFactory 工厂</p>
<p>然后调用 SqlSessionFactoryBuilder 中的 <code>build</code> 方法传递一个<code>InputStream</code> 输入流，Inputstream 输入流中就是你传过来的配置文件 mybatis-config.xml，SqlSessionFactoryBuilder 根据传入的 InputStream 输入流和<code>environment</code>、<code>properties</code>属性创建一个<code>XMLConfigBuilder</code>对象。SqlSessionFactoryBuilder 对象调用 XMLConfigBuilder 的<code>parse()</code>方法。</p>
<p>XMLConfigBuilder 会解析<code>/configuration</code>标签，configuration 是 MyBatis 中最重要的一个标签。</p>
<h4 id="configuration-的配置">configuration 的配置</h4>
<ul>
<li><code>properties</code>，外部属性，这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般用来给 <code>environment</code> 标签中的 <code>dataSource</code> 赋值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>settings</code> ，MyBatis 中极其重要的配置，它们会改变 MyBatis 的运行时行为。</li>
</ul>
<p>可以在此标签内设置 缓存，懒加载，自动驼峰命名规则映射等。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="SqlSession">SqlSession</h2>
<p>在 MyBatis 初始化流程结束，也就是 SqlSessionFactoryBuilder -&gt; SqlSessionFactory 的获取流程后，我们就可以通过 SqlSessionFactory 对象得到 <code>SqlSession</code> 然后执行 SQL 语句了。</p>
<p>SqlSession 对象是 MyBatis 中最重要的一个对象，这个接口能够让你执行命令，获取映射，管理事务。SqlSession 中定义了一系列模版方法，让你能够执行简单的 <code>CRUD</code> 操作，也可以通过 <code>getMapper</code> 获取 Mapper 层，执行自定义 SQL 语句，因为 SqlSession 在执行 SQL 语句之前是需要先开启一个会话，涉及到事务操作，所以还会有 <code>commit</code>、 <code>rollback</code>、<code>close</code> 等方法。这也是模版设计模式的一种应用。</p>
<h2 id="Executor">Executor</h2>
<h4 id="Executor-的继承结构"><strong>Executor 的继承结构</strong></h4>
<p>每一个 SqlSession 都会拥有一个 Executor 对象，这个对象负责增删改查的具体操作，我们可以简单的将它理解为 JDBC 中 Statement 的封装版。也可以理解为 SQL 的执行引擎，要干活总得有一个发起人吧，可以把 Executor 理解为发起人的角色。</p>
<p>Executor 执行器，它有两个实现类，分别是<code>BaseExecutor</code>和 <code>CachingExecutor</code>。</p>
<p><code>BaseExecutor</code> 是一个抽象类，这种通过抽象的实现接口的方式是<code>适配器设计模式之接口适配</code> 的体现，是 Executor 的默认实现，实现了大部分 Executor 接口定义的功能，降低了接口实现的难度。BaseExecutor 的子类有三个，分别是 SimpleExecutor、ReuseExecutor 和 BatchExecutor。</p>
<p><code>SimpleExecutor</code> : 简单执行器，是 MyBatis 中<strong>默认使用</strong>的执行器，每执行一次 update 或 select，就开启一个 Statement 对象，用完就直接关闭 Statement 对象 (可以是 Statement 或者是 PreparedStatment 对象)</p>
<p><code>ReuseExecutor</code> : 可重用执行器，这里的重用指的是重复使用 Statement，它会在内部使用一个 Map 把创建的 Statement 都缓存起来，每次执行 SQL 命令的时候，都会去判断是否存在基于该 SQL 的 Statement 对象，如果存在 Statement 对象并且对应的 connection 还没有关闭的情况下就继续使用之前的 Statement 对象，并将其缓存起来。因为每一个 SqlSession 都有一个新的 Executor 对象，所以我们缓存在 ReuseExecutor 上的 Statement 作用域是同一个 SqlSession。</p>
<p><code>BatchExecutor</code> : 批处理执行器，用于将多个 SQL 一次性输出到数据库</p>
<p><code>CachingExecutor</code>: 缓存执行器，先从缓存中查询结果，如果存在就返回之前的结果；如果不存在，再委托给 Executor delegate 去数据库中取，delegate 可以是上面任何一个执行器。</p>
<h3 id="Executor-的具体执行过程">Executor 的具体执行过程</h3>
<ul>
<li>当有一个查询请求访问的时候，首先会经过 Executor 的实现类 <code>CachingExecutor</code> ，先从缓存中查询 SQL 是否是第一次执行，如果是第一次执行的话，那么就直接执行 SQL 语句，并创建缓存，如果第二次访问相同的 SQL 语句的话，那么就会直接从缓存中提取。</li>
<li>如果没有的话，就再重新创建 <code>Executor</code> 执行器执行 SQL 语句，  创建我们上面提到的三种执行器</li>
<li>到这里，执行器所做的工作就完事了，Executor 会把后续的工作交给 <code>StatementHandler</code> 继续执行。</li>
</ul>
<h3 id="StatementHandler">StatementHandler</h3>
<p><code>StatementHandler</code> 是四大组件中最重要的一个对象，负责操作 Statement 对象与数据库进行交互，在工作时还会使用 <code>ParameterHandler</code> 和 <code>ResultSetHandler</code>对参数进行映射，对结果进行实体类的绑定</p>
<p><strong>StatementHandler 的继承结构</strong>和 <code>Executor</code>  比较相似</p>
<p>主要有三个实现类</p>
<ul>
<li><strong>SimpleStatementHandler</strong>: 管理 Statement 对象并向数据库中推送不需要预编译的 SQL 语句。</li>
<li><strong>PreparedStatementHandler</strong>: 管理 Statement 对象并向数据中推送需要预编译的 SQL 语句。</li>
<li><strong>CallableStatementHandler</strong>：管理 Statement 对象并调用数据库中的存储过程。</li>
</ul>
<h4 id="StatementHandler-的创建">StatementHandler 的创建</h4>
<p>MyBatis 会根据 SQL 语句的类型进行对应 StatementHandler 的创建 。</p>
<h4 id="和-的区别是什么？">#{}和${}的区别是什么？</h4>
<p>#{}是预编译处理，${}是字符串替换。mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；mybatis在处理${}时，就是把${}替换成变量的值。使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
<h4 id="Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？">Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h4>
<p>还有很多其他的标签， resultMap ， parameterMap 加上动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中为 sql 片段标签，通过<code>标签引入 sql 片段，</code>为不支持自增的主键生成策略标签。</p>
<h3 id="mybatis-有几种分页方式？">mybatis 有几种分页方式？</h3>
<p>数组分页</p>
<p>sql分页</p>
<p>拦截器分页</p>
<p>RowBounds分页</p>
<h3 id="mybatis-逻辑分页和物理分页的区别是什么？">mybatis 逻辑分页和物理分页的区别是什么？</h3>
<ul>
<li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li>
<li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</li>
</ul>
<!-- 文件: Redis 面试题.md -->
<h1>Redis面试题</h1>
<h3 id="Redis是什么">Redis是什么</h3>
<p>Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。</p>
<p>Redis作为一个内存数据库。  性能优秀，数据在内存中，读写速度非常快 ， 单进程单线程，是线程安全的，采用IO多路复用机制；</p>
<p>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等；</p>
<p>支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载；</p>
<p>支持 主从复制，哨兵，高可用；</p>
<p>可以用作分布式锁；  可以作为消息中间件使用，支持发布订阅</p>
<h3 id="应用场景⭐">应用场景⭐</h3>
<ol>
<li>缓存</li>
<li>共享Session</li>
<li>消息队列系统</li>
<li>分布式锁</li>
</ol>
<h3 id="Redis-和-memcached-的区别">Redis 和 memcached 的区别</h3>
<ol>
<li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
<li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li>
</ol>
<h3 id="redis-为什么是单线程的？">redis 为什么是单线程的？</h3>
<p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。 可以避免多线程上下文切换。</p>
<h3 id="为什么Redis这么快？⭐">为什么Redis这么快？⭐</h3>
<p>完全基于内存,绝大部分请求是纯粹的内存操作,执行效率高<br>
采用单线程,单线程也能处理高并发请求,想多核也可启动多实例</p>
<p>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</p>
<p>核心是基于非阻塞的 IO 多路复用机制。</p>
<h3 id="Redis-支持的数据类型有哪些？应用？⭐">Redis 支持的数据类型有哪些？应用？⭐</h3>
<ol>
<li>String字符串:字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型， Value 不仅是 String，也可以是数字。常用在缓存、计数、共享Session、限速等。</li>
<li>Hash哈希:在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车。</li>
<li>List列表（双向链表）:列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。 数据结构：List 就是链表，可以用来当消息队列用。Redis 提供了 List 的 Push 和 Pop 操作，还提供了操作某一段的 API，可以直接查询或者删除某一段的元素。 实现方式：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。</li>
<li>Set集合：集合（set）类型也是用来保存多个的字符串元素，集合是通过 hashtable 实现的。 但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</li>
<li>Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。</li>
</ol>
<p><strong>String 在你们项目怎么用的？</strong></p>
<p><strong>常用命令:</strong> set,get,decr,incr,mget 等。</p>
<p>在显示某个人的基本数据的时候，比如名字，粉丝数，关注数，使用 String 保存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:  user:id:3506728370  </span><br><span class="line">&#123;&quot;id&quot;:3506728370,&quot;name&quot;:&quot;春晚&quot;,&quot;fans&quot;:12210862,&quot;blogs&quot;:6164, &quot;focus&quot;:83&#125;</span><br></pre></td></tr></table></figure>
<p>设置一个定时刷新的操作，这样用户不需要直接读取数据库。怎么设置？setx key   value，一定时间循环判断key是否失效，到期后再去数据库读取。</p>
<p><strong>List 在你们项目怎么用的？</strong></p>
<p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p>
<ol>
<li>
<p>朋友圈点赞，要求按照点赞顺序显示点赞好友信息<br>
如果取消点赞，移除对应好友信息，但是不能使用pop了，怎么办呢？</p>
<p>解决方案</p>
<p>lrem key count value <strong>移除指定数据</strong><br>
count：移除的数目<br>
value：具体要移除的内容</p>
</li>
<li>
<p>个人用户的关注列表需要按照用户的关注顺序展示。</p>
</li>
</ol>
<p><strong>Set 在你们项目怎么用的？</strong></p>
<p>每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户<br>
对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？</p>
<p><strong>分析</strong><br>
系统分析出各个分类的最新或最热点信息条目并组织成set集合<br>
随机挑选其中部分信息<br>
配合用户关注信息分类中的热点信息组织成展示的全信息集合</p>
<p><strong>解决方案</strong></p>
<ul>
<li>
<p>随机获取集合中指定数量的数据</p>
<p>srandmember key [count]</p>
</li>
<li>
<p>随机获取集合中的某个数据并将该数据移出集合</p>
<p>spop key [count]</p>
</li>
</ul>
<p><strong>zset</strong></p>
<p>在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p>
<h3 id="zset跳表的数据结构⭐">zset跳表的数据结构⭐</h3>
<p>增加了向前指针的链表叫作跳表跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p>
<p>原理：</p>
<p>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了。</p>
<p><strong>为什么使用跳跃表</strong></p>
<p>首先，因为 zset 要支持随机的插入和删除，所以它 <strong>不宜使用数组来实现</strong>，关于排序问题，我们也很容易就想到 <strong>红黑树/ 平衡树</strong> 这样的树形结构，为什么 Redis 不使用这样一些结构呢？</p>
<ol>
<li><strong>性能考虑：</strong> 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部 <em>(下面详细说)</em>；</li>
<li><strong>实现考虑：</strong> 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；</li>
</ol>
<h3 id="redis-设置过期时间">redis 设置过期时间</h3>
<p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是<strong>短信验证码都是有时间限制的</strong>，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p>
<p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p>
<p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p>
<h3 id="数据过期策略⭐">数据过期策略⭐</h3>
<p><strong>定期删除+惰性删除。</strong></p>
<p>通过名字大概就能猜出这两个删除方式的意思了。</p>
<ul>
<li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li>
<li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p>
<h3 id="数据淘汰机制⭐">数据淘汰机制⭐</h3>
<p>当内存到达最大内存限制时进行的数据淘汰策略</p>
<ol>
<li>新写入操作会报错。（Redis 默认策略）</li>
<li>在键空间中，移除最近最少使用的 Key。（LRU推荐使用）</li>
<li>在键空间中，随机移除某个 Key。</li>
<li>在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。</li>
<li>在设置了过期时间的键空间中，随机移除某个 Key。</li>
<li>在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。</li>
</ol>
<p><strong>LRU 算法实现</strong>：1.通过双向链表来实现，新数据插入到链表头部；2.每当缓存命中（即缓存<br>
数据被访问），则将数据移到链表头部；3.当链表满的时候，将链表尾部的数据丢弃。<br>
LinkedHashMap：HashMap 和双向链表合二为一即是 LinkedHashMap。HashMap 是无序<br>
的，LinkedHashMap 通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插<br>
入顺序（默认），也可以是访问顺序。</p>
<h3 id="Redis的LRU具体实现：">Redis的LRU具体实现：</h3>
<p>传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致执行select *的时候大量非热点数据占领头部数据，所以需要改进。Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。</p>
<h3 id="Redis-持久化的两种方式⭐">Redis 持久化的两种方式⭐</h3>
<ul>
<li>RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略。 当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。</li>
<li>AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。 使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中。aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。 缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步(AOF)。</li>
</ul>
<p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p>
<p><strong>RDB 持久化优点</strong><br>
RDB是一个紧凑压缩的二进制文件，存储效率高<br>
RDB恢复数据速度比AOF快</p>
<p><strong>RDB持久化缺点</strong><br>
无法做到实时持久化，具有较大可能丢失数据<br>
存储数量较大时，效率较低，I／O性能较低<br>
基于fork创建子进程，内存产生额外消耗<br>
宕机带来的数据丢失风险</p>
<p><strong>AOF 优点</strong></p>
<ul>
<li>AOF 可以更好的保护 数据不丢失，一般 AOF 会每隔 1 秒，最多丢失 1 秒钟的数据。</li>
<li>写入性能非常高，而且文件不容易破损</li>
<li><strong>适合做灾难性的误删除的紧急恢复</strong>。</li>
</ul>
<p><strong>AOF 缺点</strong></p>
<p>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</p>
<p>恢复速度较慢</p>
<h4 id="RDB-与-AOF-如何选择">RDB 与 AOF 如何选择</h4>
<p>对数据非常敏感，建议使用默认的AOF持久化方案<br>
AOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据<br>
数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案</p>
<p>综合：<br>
如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF<br>
如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB，RDB 非常适合灾难恢复。<br>
双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量</p>
<h3 id="为什么要用缓存？">为什么要用缓存？</h3>
<p>用缓存，主要有两个用途：<strong>高性能</strong>、<strong>高并发</strong>。</p>
<h3 id="怎么保证缓存和数据库数据的一致性？⭐">怎么保证缓存和数据库数据的一致性？⭐</h3>
<p>分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。</p>
<p>我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。</p>
<ul>
<li>合理设置缓存的过期时间。</li>
<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。</li>
<li>缓存失败时增加重试机制。</li>
</ul>
<h3 id="redis-怎么实现分布式锁？">redis 怎么实现分布式锁？</h3>
<p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>
<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁</p>
<p>也可以配合<code>EXPIRE key seconds</code>自动释放锁<br>
设置key的生存时间,当key过期时(生存时间为0) ,会被自动删除<br>
风险/ <strong>缺陷</strong> ：原子性没有得到满足，所以不建议。</p>
<h3 id="缓存雪崩">缓存雪崩</h3>
<p><strong>在一个较短的时间内，缓存中较多的key集中过期或者缓存挂了</strong>，导致了<strong>数据库服务器崩溃</strong></p>
<p>缓存雪崩的事前事中事后的解决方案如下：</p>
<p>在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效。或者设置热点数据永不过期，有更新操作就更新缓存就好了</p>
<h3 id="缓存穿透">缓存穿透</h3>
<p><strong>原因：</strong></p>
<ol>
<li>Redis中大面积出现未命中</li>
<li>出现非正常URL访问</li>
</ol>
<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<p>**布隆过滤器（Bloom Filter）**这个也能很好的预防缓存穿透的发生，就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查DB刷新KV再return</p>
<h3 id="缓存击穿">缓存击穿</h3>
<p>缓存击穿是指一个Key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存。</p>
<p>解决：设置热点数据永不过期，或者加上个锁就搞定了。</p>
<p><strong>假如 Redis  里面有 1  亿个 key ，其中有 10w 个 个 key  是以某个固定的已知的前缀开头的，如</strong><br>
<strong>果将它们全部找出来？</strong><br>
使用 keys 指令可以扫出指定模式的 key 列表。<br>
对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问<br>
题？<br>
这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一<br>
段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指<br>
令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客<br>
户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p>
<h3 id="实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？">实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？</h3>
<p>缓存和数据库数据一致性问题</p>
<h3 id="主从复制">主从复制</h3>
<p><strong>作用：</strong><br>
读写分离：master写、slave读，提高服务器的读写负载能力<br>
负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量<br>
故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复<br>
数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式<br>
高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</p>
<p><strong>过程：</strong></p>
<ul>
<li>从节点执行 <strong>slaveof IP，port</strong> 发送指令</li>
<li>主节点响应</li>
<li>从节点保存主节点信息（IP，port），建立和主节点的 Socket 连接。</li>
<li>从节点发送 Ping 信号，主节点返回 Pong，确定两边能互相通信。</li>
<li>连接建立后，主节点将所有数据发送给从节点（数据同步）。</li>
<li>主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</li>
</ul>
<p><strong>复制/数据同步过程分为两个阶段</strong></p>
<ol>
<li>全量复制：<br>
slave接收到master生成的RDB文件，先清空自身的旧数据，然后执行RDB恢复过程，然后告知master已经恢复完毕。</li>
<li>部分复制（增量复制）<br>
主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。master把自己之前创建的复制缓冲区的数据发送到slave，slave接收到aof指令后执行重写操作，恢复数据。</li>
</ol>
<p><strong>主从复制会存在以下问题：</strong></p>
<ul>
<li>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</li>
<li>主节点的写能力受到单机的限制。</li>
<li>主节点的存储能力受到单机的限制。</li>
</ul>
<p><strong>哨兵：</strong></p>
<p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。</p>
<p><strong>作用：</strong></p>
<p><strong>监控</strong><br>
不断的检查master和slave是否正常运行。<br>
master存活检测、master与slave运行情况检测</p>
<p><strong>通知（提醒）</strong><br>
当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</p>
<p><strong>自动故障转移</strong><br>
断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</p>
<!-- 文件: Spring Cloud.md -->
<h2 id="Spring-Cloud-的理解？">Spring Cloud 的理解？</h2>
<p>Spring Cloud就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 <strong>服务发现注册</strong> 、<strong>配置中心</strong> 、<strong>消息总线</strong> 、<strong>负载均衡</strong> 、<strong>断路器</strong> 、<strong>数据监控</strong> 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p>
<h3 id="服务发现框架——Eureka">服务发现框架——Eureka</h3>
<p><strong>服务注册 Register</strong> ：</p>
<p>当 Eureka 客户端（服务提供者）向 Eureka Server 注册时，它存储该服务的信息 ，比如IP地址、端口，运行状况指示符URL，主页等。</p>
<p><strong>服务续约 Renew</strong> ：</p>
<p><strong>Eureka 客户端会每隔30秒(默认情况下)发送一次心跳来续约</strong> 。 通过续约来告知 Eureka Server  该 Eureka 客户仍然存在，没有出现问题。正常情况下，如果 Eureka Server 在90秒没有收到 Eureka 客户端的续约，它会将实例从其注册表中删除。</p>
<p><strong>获取注册列表信息 Fetch Registries</strong> ：</p>
<p>Eureka 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。Eureka  客户端和 Eureka 服务器可以使用JSON / XML格式进行通讯。</p>
<p><strong>服务下线 Cancel</strong> ：</p>
<p>Eureka 客户端在程序关闭时向 Eureka 服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<code>DiscoveryManager.getInstance().shutdownComponent();</code></p>
<p><strong>服务剔除 Eviction</strong> ：</p>
<p>在默认的情况下，当 Eureka 客户端连续90秒(3个续约周期)没有向服务器发送服务续约，即心跳，服务器会将该服务实例从服务注册列表删除，即服务剔除。</p>
<p><strong>架构图</strong>：</p>
<p><img src="C:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200229172633604.png" alt="image-20200229172633604"></p>
<p>可以充当服务发现的组件有很多：Zookeeper ，Consul ， Eureka 等。</p>
<h2 id="Eureka-原理⭐">Eureka 原理⭐</h2>
<p>Eureka 主要包括两块： Eureka Server 和 Eureka Client。</p>
<p><strong>Eureka Server，服务端</strong>，有三个功能： <strong>服务注册</strong>  <strong>提供注册表</strong>  <strong>同步状态</strong></p>
<p><strong>Eureka Client，客户端</strong>，是一个 Java 客户端，用于简化与 Eureka Server 的交互。它会拉取、更新和缓存 Eureka Server 中的信息。因此当所有的 Eureka Server  节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。<strong>服务续约</strong>， <strong>服务剔除</strong>， <strong>服务下线</strong> 的功能。</p>
<p>Eurka 工作流程是这样的：</p>
<p>1、Eureka Server 启动成功，等待服务端注册。</p>
<p>2、Eureka Client 启动时根据配置的 Eureka Server 地址去注册中心注册服务</p>
<p>3、Eureka Client 会每 30s 向 Eureka Server 发送一次心跳请求，证明客户端服务正常</p>
<p>4、当 Eureka Server 90s 内没有收到 Eureka Client 的心跳，注册中心则认为该节点失效，会注销该实例</p>
<p>5、单位时间内 Eureka Server 统计到有大量的 Eureka Client 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端</p>
<p>6、当 Eureka Client 心跳请求恢复正常之后，Eureka Server 自动退出自我保护模式</p>
<p>7、Eureka Client 定时从注册中心获取服务注册表，并且将获取到的信息缓存到本地</p>
<p>8、服务调用时，Eureka Client 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存</p>
<p>9、Eureka Client 获取到目标服务器信息，发起服务调用</p>
<p>10、Eureka Client 程序关闭时向 Eureka Server 发送取消请求，Eureka Server 将实例从注册表中删除</p>
<h2 id="Eureka-和-ZooKeeper-的区别-⭐">Eureka 和 ZooKeeper 的区别 ⭐</h2>
<ul>
<li>C (Consistency) 强一致性</li>
<li>A(Availability) 可用性</li>
<li>P (Partition tolerance) 分区容错性</li>
</ul>
<p>Zookeeper保证的是CP，Eureka保证的是AP。</p>
<p><strong>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整 个注册服务瘫痪</strong></p>
<h3 id="负载均衡之-Ribbon">负载均衡之 Ribbon</h3>
<p>Ribbon 是一个客户端/进程内负载均衡器，<strong>运行在消费者端</strong> 。</p>
<p>其工作原理就是 <code>Consumer</code> 端获取到了所有的服务列表之后，在其<strong>内部</strong> 使用<strong>负载均衡算法</strong> ，进行对多个系统的调用。</p>
<h4 id="Nginx-和-Ribbon-的对比">Nginx 和 Ribbon 的对比</h4>
<p>nginx 是客户端所有请求统一交给 nginx，由 nginx 进行实现负载均衡请求转发，属于服务器端负载均衡。</p>
<p>Ribbon 是从 eureka 注册中心服务器端上获取服务注册信息列表，缓存到本地，然后在本地实现轮询负载均衡策略，属于客户端负载均衡。</p>
<h4 id="Ribbon-的几种负载均衡算法">Ribbon 的几种负载均衡算法</h4>
<p>负载均衡，不管 <code>Nginx</code> 还是 <code>Ribbon</code> 都需要其算法的支持，如果我没记错的话 <code>Nginx</code> 使用的是 轮询和加权轮询算法。而在 <code>Ribbon</code> 中有更多的负载均衡调度算法，其默认是使用的 <code>RoundRobinRule</code> 轮询策略。</p>
<p><strong>RoundRobinRule</strong> ：轮询策略。<code>Ribbon</code> 默认采用的策略。若经过一轮轮询没有找到可用的 <code>provider</code>，其最多轮询 10 轮。若最终还没有找到，则返回 null。</p>
<p>默认轮询算法，并且可以更换默认的负载均衡算法，只需要在配置文件中做出修改。</p>
<h3 id="Open-Feign">Open Feign</h3>
<p>OpenFeign 也是运行在消费者端的，使用 Ribbon 进行负载均衡，所以 OpenFeign 直接内置了 Ribbon。 主要用于消费者和服务者的调用</p>
<h3 id="Hystrix–断路器">Hystrix–断路器</h3>
<p>Hystrix 就是一个能进行 <strong>熔断</strong> 和 <strong>降级</strong> 的库，通过使用它能提高整个系统的弹性。</p>
<p>所谓 <strong>熔断</strong> 就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过 <strong>断路器</strong> 直接将此请求链路断开。</p>
<p>也就是我们上面服务A调用服务B在指定时间窗内，调用的失败率到达了一定的值，那么 Hystrix 则会自动将服务A与B之间的请求都断了，以免导致服务雪崩现象。</p>
<p>其实这里所讲的 <strong>熔断</strong> 就是指的 Hystrix中的 <strong>断路器模式</strong> ，你可以使用简单的 <code>@HystrixCommand</code> 注解来标注某个方法，这样 Hystrix 就会使用 <strong>断路器</strong> 来“包装”这个方法，每当调用时间超过指定时间时(默认为1000ms)，断路器将会中断对这个方法的调用。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;@HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1200&quot;)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Xxx&gt; <span class="title function_">getXxxx</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的回复</strong> 。这也就对应着 Hystrix 的 <strong>后备处理</strong> 模式。你可以通过设置 <code>fallbackMethod</code> 来给一个方法设置备用的代码逻辑。比如这个时候有一个热点新闻出现了，用户会通过id去查询新闻的详情，但是因为这条新闻太火了，大量用户同时访问可能会导致系统崩溃，那么我们就进行 <strong>服务降级</strong> ，一些请求会做一些降级处理比如当前人数太多请稍后查看等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定了后备方法调用</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;getHystrixNews&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/get/news&quot;)</span></span><br><span class="line"><span class="keyword">public</span> News <span class="title function_">getNews</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用新闻系统的获取新闻api 代码逻辑省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> News <span class="title function_">getHystrixNews</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="comment">// 做服务降级</span></span><br><span class="line">    <span class="comment">// 返回当前人数太多，请稍后查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务熔断原理">服务熔断原理</h2>
<p>hystrix会监控微服务之间调用的状况，当失败的调用到一定阀值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。 是通过spring 的 AOP 功能实现的 HystrixCommand 注解的方法是一个切点，有一个对方法增强的类，对他增强，如果出现失败就中断这个方法的调用，返回失败。</p>
<h2 id="微服务网关——Zuul">微服务网关——Zuul</h2>
<p>ZUUL 是为了实现动态路由、监视、弹性和安全性而构建的。<strong>就是这样的一个对于消费者的统一入口。</strong></p>
<h4 id="路由功能">路由功能</h4>
<p><code>Zuul</code> 需要向 Eureka 进行注册， 以此来拿到所有 <code>Consumer</code> 的信息，从而直接可以做路由映射。</p>
<p><strong>基本配置：</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="string">port:9000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 这里只要注册 Eureka 就行了</span></span><br><span class="line">      <span class="string">defaultZone:http://localhost:9997/eureka</span></span><br></pre></td></tr></table></figure>
<p>然后在启动类上加入 <code>@EnableZuulProxy</code> 注解就行了。没错，就是那么简单。</p>
<p><strong>统一前缀</strong></p>
<p>这个很简单，就是我们可以在前面加一个统一的前缀，比如我们刚刚调用的是 <code>localhost:9000/consumer1/studentInfo/update</code>，这个时候我们在 <code>yaml</code> 配置文件中添加如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  prefix:/zuul</span><br></pre></td></tr></table></figure>
<p>这样我们就需要通过 <code>localhost:9000/zuul/consumer1/studentInfo/update</code> 来进行访问了。</p>
<p><strong>路由策略配置</strong></p>
<p>你会发现前面的访问方式(直接使用服务名)，需要将微服务名称暴露给用户，会存在安全性问题。所以，可以自定义路径来替代微服务名称，即自定义路由策略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  routes:    consumer1:/FrancisQ1/**    consumer2:/FrancisQ2/**</span><br></pre></td></tr></table></figure>
<p>这个时候你就可以使用 <code>localhost:9000/zuul/FrancisQ1/studentInfo/update</code> 进行访问了。</p>
<p><strong>服务名屏蔽</strong></p>
<p>这个时候你别以为你好了，你可以试试，在你配置完路由策略之后使用微服务名称还是可以访问的，这个时候你需要将服务名屏蔽。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  ignore-services:&quot;*&quot;</span><br></pre></td></tr></table></figure>
<p><strong>路径屏蔽</strong></p>
<p><code>Zuul</code> 还可以指定屏蔽掉的路径 URI，即只要用户请求中包含指定的 URI 路径，那么该请求将无法访问到指定的服务。通过该方式可以限制用户的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  ignore-patterns:**/auto/**</span><br></pre></td></tr></table></figure>
<p>这样关于 auto 的请求我们就可以过滤掉了。</p>
<blockquote>
<p>** 代表匹配多级任意路径</p>
<p>*代表匹配一级任意路径</p>
</blockquote>
<p><strong>敏感请求头屏蔽</strong></p>
<p>默认情况下，像 Cookie、Set-Cookie 等敏感请求头信息会被 zuul 屏蔽掉，我们可以将这些默认屏蔽去掉，当然，也可以添加要屏蔽的请求头。</p>
<h4 id="过滤功能">过滤功能</h4>
<p>所有请求都经过网关(Zuul)，那么我们可以进行各种过滤，这样我们就能实现 <strong>限流</strong> ，<strong>灰度发布</strong> ，<strong>权限控制</strong> 等等。</p>
<p>过滤器类型：Pre、Routing、Post。前置Pre就是在请求之前进行过滤，Routing路由过滤器就是我们上面所讲的路由策略，而Post后置过滤器就是在 <code>Response</code> 之前进行过滤的过滤器。</p>
<h2 id="配置管理——Config">配置管理——Config</h2>
<p>当我们的微服务系统开始慢慢地庞大起来，那么多 <code>Consumer</code> 、<code>Provider</code> 、<code>Eureka Server</code> 、<code>Zuul</code> 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能<strong>去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用</strong> 。</p>
<p>首先对于分布式系统而言我们就不应该去每个应用下去分别修改配置文件，再者对于重启应用来说，服务无法访问所以直接抛弃了可用性，这是我们更不愿见到的。</p>
<p><code>Spring Cloud Config</code> 就是能将各个 应用/系统/模块的配置文件存放到 <strong>统一的地方然后进行管理</strong> (Git 或者 SVN)。</p>
<p>我们的应用只有启动的时候才会进行配置文件的加载，那么我们的 <code>Spring Cloud Config</code> 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。</p>
<p>怎么进行动态修改配置文件呢？  一般我们会使用 <code>Bus</code> 消息总线 + <code>Spring Cloud Config</code> 进行配置的动态刷新。</p>
<h3 id="Spring-Cloud-Bus">Spring Cloud Bus</h3>
<p>你可以简单理解为 <code>Spring Cloud Bus</code> 的作用就是<strong>管理和广播分布式系统中的消息</strong> ，也就是消息引擎系统中的广播模式。当然作为 <strong>消息总线</strong> 的 <code>Spring Cloud Bus</code> 可以做很多事而不仅仅是客户端的配置刷新功能。</p>
<p>而拥有了 <code>Spring Cloud Bus</code> 之后，我们只需要创建一个简单的请求，并且加上 <code>@ResfreshScope</code> 注解就能进行配置的动态修改了 。</p>
<!-- 文件: Spring IOC 源码.md -->
<p>applicationContext 其实就是一个 BeanFactory</p>
<p>最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。  ListableBeanFactory获取多个 Bean</p>
<p>HierarchicalBeanFactory  可以在应用中起多个 BeanFactory</p>
<p>源码分析：</p>
<p>从 ClassPathXmlApplicationContext 的构造方法说起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); <span class="comment">// 核心方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>核心方法为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p>
<h2 id="启动过程分析">启动过程分析</h2>
<p>refresh方法总览：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 刷新前的预处理,初始化一些属性设置,检验属性的合法等,保存容器中的一些早期的事件；</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取BeanFactory,这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="comment">//将创建的BeanFactory【DefaultListableBeanFactory】返回；</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//BeanFactory的预准备工作（对BeanFactory进行一些设置）</span></span><br><span class="line">      <span class="comment">//设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，比如：</span></span><br><span class="line">      <span class="comment">//ApplicationContextAwareProcessor</span></span><br><span class="line">      <span class="comment">//手动注册几个特殊的 bean</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         <span class="comment">//两大接口：</span></span><br><span class="line">  		 <span class="comment">//BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 	</span></span><br><span class="line">         <span class="comment">//postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">//注册BeanPostProcessor（Bean的后置处理器）作用：拦截 bean 的注册过程</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的组件（做国际化功能；消息绑定，消息解析）；</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         <span class="comment">// 留给子容器（子类）,子类重写这个方法，在容器刷新的时候可以自定义逻辑；</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口	</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化所有的单实例bean；</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">          </span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在开始一点一点的分析refresh方法</p>
<h3 id="创建-Bean-容器前的准备工作">创建 Bean 容器前的准备工作</h3>
<p>这个比较简单，直接看代码中的几个注释即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 记录启动时间，</span></span><br><span class="line">   <span class="comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span></span><br><span class="line">   <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">   <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验 xml 配置文件</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建-Bean-容器，加载并注册-Bean">创建 Bean 容器，加载并注册 Bean</h3>
<p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p>
<p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>
<p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p>
<p>// AbstractApplicationContext.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;   </span><br><span class="line">    refreshBeanFactory();   </span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();&#125;</span><br></pre></td></tr></table></figure>
<p>// AbstractRefreshableApplicationContext.java 124</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span></span><br><span class="line">   <span class="comment">// ApplicationContext 是否有 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 下面这两个方法很重要，别跟丢了，具体细节之后说</span></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载 Bean 到 BeanFactory 中</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（<strong>DefaultListableBeanFactory</strong>）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>
<p>问题来了： 为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？</p>
<p>DefaultListableBeanFactory实现了 ConfigurableListableBeanFactory  和 AbstractAutowireCapableBeanFactory  ，从而成为了功能最多的 BeanFactory 。 这也是为什么这边会使用这个类来实例化的原因。</p>
<p><strong>如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</strong></p>
<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>
<h4 id="BeanDefinition-接口定义">BeanDefinition 接口定义</h4>
<p>我们来看下 BeanDefinition 的接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_APPLICATION</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_SUPPORT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_INFRASTRUCTURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setParentName</span><span class="params">(String parentName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   String <span class="title function_">getParentName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setBeanClassName</span><span class="params">(String beanClassName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   String <span class="title function_">getBeanClassName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span>;</span><br><span class="line"></span><br><span class="line">   String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setDependsOn</span><span class="params">(String... dependsOn)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setAutowireCandidate</span><span class="params">(<span class="type">boolean</span> autowireCandidate)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAutowireCandidate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setPrimary</span><span class="params">(<span class="type">boolean</span> primary)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   ConstructorArgumentValues <span class="title function_">getConstructorArgumentValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   MutablePropertyValues <span class="title function_">getPropertyValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAbstract</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getRole</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getResourceDescription</span><span class="params">()</span>;</span><br><span class="line">   BeanDefinition <span class="title function_">getOriginatingBeanDefinition</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>注意：这里接口很多但是还没有利用到反射来获取定义的类的实例，到后面从才会出现。</p>
<p>现在继续往下看 refreshBeanFactory() 方法中的剩余部分：</p>
<h4 id="customizeBeanFactory">customizeBeanFactory</h4>
<p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 定义覆盖</span></span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowCircularReferences != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 间的循环依赖</span></span><br><span class="line">      beanFactory.setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>
<p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>
<p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p>
<p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p>
<h4 id="加载-Bean-loadBeanDefinitions">加载 Bean: loadBeanDefinitions</h4>
<p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p>
<p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p>
<p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析，然后根据读取配置文件标签的内容，相应的产生对应的实例， 这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息 。</p>
<h5 id="注册-Bean">注册 Bean</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">   Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span></span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">   oldBeanDefinition = <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         <span class="comment">// 如果不允许覆盖的话，抛异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         <span class="comment">// log...用框架定义的 Bean 覆盖用户自定义的 Bean </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         <span class="comment">// log...用新的 Bean 覆盖旧的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 覆盖</span></span><br><span class="line">      <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">      <span class="comment">// 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">      <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">      <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">         <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">            updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(<span class="built_in">this</span>.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               <span class="built_in">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">         <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">         <span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">         <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">         <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">         <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">         <span class="comment">//     registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">         <span class="comment">// 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，</span></span><br><span class="line">         <span class="comment">// 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">         <span class="built_in">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这个不重要，在预初始化的时候会用到，不必管它。</span></span><br><span class="line">      <span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，到这里已经初始化了 Bean 容器，bean标签的配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>
<h3 id="Bean-容器实例化完成后">Bean 容器实例化完成后</h3>
<h3 id="准备-Bean-容器-prepareBeanFactory">准备 Bean 容器: prepareBeanFactory</h3>
<p>Spring 把我们在 xml 配置的 bean 都注册以后，会 “手动” 注册一些特殊的 bean。</p>
<h3 id="初始化所有的-singleton-beans">初始化所有的 singleton beans</h3>
<p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p>
<p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p>
<p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经 “手动” 注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p>
<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p>
<p>// AbstractApplicationContext.java 834</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span></span><br><span class="line">   <span class="comment">// 什么，看代码这里没有初始化 Bean 啊！</span></span><br><span class="line">   <span class="comment">// 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StringValueResolver</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> String <span class="title function_">resolveStringValue</span><span class="params">(String strVal)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">   <span class="comment">// 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">   <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 开始初始化</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="getBean">getBean</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span></span><br><span class="line"><span class="comment">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span></span><br><span class="line">   <span class="comment">// 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意跟着这个，这个是返回值</span></span><br><span class="line">   Object bean; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查下是不是已经创建过了</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span></span><br><span class="line">   <span class="comment">// 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span></span><br><span class="line">      <span class="comment">// 如果是 FactoryBean 的话，返回它创建的那个实例对象</span></span><br><span class="line">      <span class="comment">// (FactoryBean 知识，读者若不清楚请移步附录)</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span></span><br><span class="line">         <span class="comment">// 往往是因为陷入了循环引用</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查一下这个 BeanDefinition 在容器中是否存在</span></span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回父容器的查询结果</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         <span class="comment">// typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span></span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">         <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="comment">// 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span></span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 注册一下依赖关系</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="comment">// 先初始化被依赖项</span></span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">// 执行创建 Bean，详情后面再说</span></span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     <span class="keyword">throw</span> ex;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               <span class="comment">// 执行创建 Bean</span></span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行创建 Bean</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; bean != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>检查下bean是不是已经创建过了，如果是普通 Bean 的话，直接返回 sharedInstance，如果是 FactoryBean 的话，返回它创建的那个实例对象，然后检查一下这个 BeanDefinition 在容器中是否存在，然后准备创建bean</p>
<p>对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。如果是 singleton scope 的，创建 singleton 的实例，然后执行创建 Bean（ <strong>createBean</strong> ）；如果是 prototype scope 的，创建 prototype 的实例，然后执行创建 Bean，如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理，最后，检查一下类型对不对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// AbstractAutowireCapableBeanFactory 447</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保 BeanDefinition 中的 Class 被加载</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span></span><br><span class="line">   <span class="comment">// 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span></span><br><span class="line">   <span class="comment">// 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span></span><br><span class="line">      <span class="comment">// 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 重头戏，创建 bean</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="创建-Bean">创建 Bean</h4>
<p>我们继续往里看 doCreateBean 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 &quot;bean 实例&quot;</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedInstance() : <span class="literal">null</span>);</span><br><span class="line">   <span class="comment">// 类型</span></span><br><span class="line">   Class&lt;?&gt; beanType = (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedClass() : <span class="literal">null</span>);</span><br><span class="line">   mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">   <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">   <span class="comment">// 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">               <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span></span><br><span class="line">         <span class="comment">// 这里就是处理 bean 初始化完成后的各种回调</span></span><br><span class="line">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean as disposable.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p>
<p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。</p>
<h5 id="创建-Bean-实例">创建 Bean 实例</h5>
<p>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p>
<p>整个ioc创建完毕。</p>
<h2 id="Bean-的完整生命周期">Bean 的完整生命周期</h2>
<ul>
<li>
<p>Bean容器/BeanFactory 通过对象的构造器或工厂方法先实例化 Bean；</p>
</li>
<li>
<p>再根据 Resource 中的信息再通过设定好的方法（典型的有setter，统称为BeanWrapper）对 Bean 设置属性值，得到 BeanDefintion 对象，然后 put 到 beanDefinitionMap 中，调用 getBean 的时候，从  beanDefinitionMap 里，拿出 Class 对象进行注入，同时，如果有依赖关系，将递归调用 getBean 方法，即依赖注入的过程。</p>
</li>
<li>
<p>检查 xxxAware 相关接口，比如 BeanNameAware，BeanClassLoaderAware，ApplicationContextAware（ BeanFactoryAware）等等，如果有就调用相应的 setxxx 方法把所需要的xxx传入到 Bean 中。</p>
<p><strong>补充</strong>：关于 Aware ，Aware 就是感知的意思， Aware 的目的是为了让Bean获得Spring容器的服务。 实现了这类接口的 bean 会存在“意识感”，从而让容器调用 setxxx 方法把所需要的 xxx 传到 Bean 中。</p>
</li>
<li>
<p>此时检查是否存在有于 Bean 关联的任何  BeanPostProcessors， 执行 postProcessBeforeInitialization() 方法（前置处理器）。</p>
</li>
<li>
<p>如果 Bean 实现了InitializingBean接口（正在初始化的 Bean），执行 afterPropertiesSet() 方法。</p>
</li>
<li>
<p>检查是否配置了自定义的 init-method 方法，如果有就调用。</p>
</li>
<li>
<p>此时检查是否存在有于 Bean 关联的任何  BeanPostProcessors， 执行 postProcessAfterInitialization() 方法（后置处理器）。返回 wrapperBean（包装后的 Bean）。</p>
</li>
<li>
<p>这时就可以开始使用 Bean 了，当容器关闭时，会检查 Bean 是否实现了 DisposableBean 接口，如果有就调用 destory() 方法。</p>
</li>
<li>
<p>如果 Bean 配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p>
</li>
</ul>
<p>上面整个过程就是 Bean 的整个生命周期了。</p>
<p><strong>Bean 单例和多例的情况：</strong></p>
<p>在实际情况中一般并不会实现很多扩展接口，我们知道，Bean 的基本类型分为 singleton（单例） 和 prototype（原型/多例） 两种，在容器创建过程中，单例 Bean 默认跟随容器一起实例化，而当我们指定 Bean节点的 lazy-init=”true” 时，只有在第一次获取 Bean 的时候才会初始化 Bean。当然，如果想让所有单例 Bean 都延迟加载，可以在根节点设置此属性。</p>
<p>当 scope=“prototype” 时，容器也会延迟初始化 Bean，并不会立刻创建对象，而是在第一次请求该 bean 时才初始化（如调用 getBean 方法时）。和单例不同的情况是：在对象销毁时，容器不会帮我们调用任何方法， 因为是非单例，这个类型的对象有很多个，Spring容器一旦把这个对象交给你之后，就不再管理这个对象了。 如果 bean 的 scope 设为 prototype 时，当容器关闭时，destroy 方法不会被调用。对于 prototype 作用域的 bean，有一点非常重要，<strong>那就是 Spring不能对一个 prototype bean 的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个 prototype 实例后，将它交给客户端，随后就对该prototype 实例不闻不问了。</strong></p>
<p>也许你会问，那么怎么释放被 prototype 作用域 bean 占用的资源？</p>
<p>我们可以通过 Bean 的后置处理器， 该处理器持有要被清除的bean的引用。</p>
<p>Spring 被设计成<strong>一个管理应用程序模块定义的容器以及工厂，而不是管理模块自身的容器</strong>，让模块可以分别独立开发，实现了模块之间的解耦。</p>
<p>为什么要使用Spring：</p>
<ol>
<li>Spring提供一个容器/工厂，统一管理模块的定义，根据需要创建。</li>
<li>把模块的配置参数统一管理，模块不需要自行读取配置。</li>
<li>Spring提供依赖注入，把依赖的模块自动推送进来，不需要模块自己拉取。</li>
<li>此外，Spring提供了对很多其他第三方框架的集成功能，减少了样板代码（boilerplate）。</li>
</ol>
<!-- 文件: Spring 面试题.md -->
<h2 id="谈谈你对-Spring的理解">谈谈你对 Spring的理解</h2>
<p>让 java 开发模块化，并且全面。Spring 通过控制反转降低耦合性，一个对象的依赖通过被动注入的方式而非主动 new，还通过代理模式实现了面向切面编程。</p>
<h2 id="IOC-是什么，什么是-Spring-IOC-容器？⭐">IOC 是什么，什么是 Spring IOC 容器？⭐</h2>
<p>IOC 是一种设计思想。 **IOC 容器是 Spring 用来实现 IOC 的载体， IOC 容器在某种程度上就是个Map（key，value）,key是 name 属性，value 是对应的对象。**容器创建 Bean 对象， 使用依赖注入来管理对象之间的相互依赖关系，配置它们并管理它们的完整生命周期，很大程度上简化应用的开发，降低了耦合度。</p>
<p>容器通过读取提供的配置,比如 XML，注解或 Java 代码来接收对象信息进行实例化，配置和组装。</p>
<p>Spring在创建容器时有一个点就是利用了模板方法设计模式设计了 refresh 方法，这个方法是模板方法，低级容器实现了 obtainFreshBeanFactory 的抽象方法，调用 refreshBeanFactory 加载了所有 BeanDefinition 和 Properties 到 <strong>DefaultListableBeanFactory</strong> 容器中。发送了注册事件后高级容器启动功能，比如接口回调，监听器，创建单例bean，发布事件等功能。</p>
<h3 id="IoC-的实现机制-初始化流程⭐">IoC 的实现机制/初始化流程⭐</h3>
<p>主要实现原理就是工厂模式加反射机制。</p>
<p>调用 refresh() 方法：</p>
<ul>
<li>
<p>刷新准备，设置开始时间，状态， 初始化占位符等操作</p>
</li>
<li>
<p>获取内部的 BeanFactory，Spring 容器在启动的时候，先会保存所有注册进来的 Bean 的定义信息， 注册到 BeanFactory 中。</p>
</li>
<li>
<p>设置 BeanFactory 的类加载器和后置处理器，添加几个 BeanPostProcessor，手动注册默认的环境 bean</p>
</li>
<li>
<p>为子类提供后置处理 BeanFactory 的扩展能力，初始化上下文之前，可以复写 postProcessBeanFactory这个方法</p>
</li>
<li>
<p>执行 Context 中注册的 BeanFactory 后置处理器，对 SpringBoot 来说，这一步会进行 BeanDefintion 的解析</p>
</li>
<li>
<p>按优先级在 BeanFactory 注册 Bean 的后置处理器，这是在 Bean 初始化前后执行的方法</p>
</li>
<li>
<p>初始化国际化，事件广播器的模块，注册事件监听器</p>
</li>
<li>
<p>然后 <strong>Spring容器就会创建这些非延迟加载的单例 Bean</strong></p>
</li>
<li>
<p>最后广播事件，ApplicationContext 初始化/刷新完成</p>
</li>
</ul>
<p>具体源码实现分析请看我的另一篇文章 。</p>
<h3 id="Spring-Bean">Spring Bean</h3>
<h4 id="什么是-Spring-Bean？">什么是 Spring Bean？</h4>
<p>是基于用户提供的配置创建的，构成了应用程序主干的对象，是由 Spring IoC 容器实例化，装配和管理的。</p>
<p><strong>Bean 在代码层面上可以简单认为是 BeanDefinition 的实例</strong></p>
<h4 id="Bean-的作用域（scope）">Bean 的作用域（scope）</h4>
<ul>
<li><strong>Singleton</strong> - 每个 Spring IoC 容器仅有一个单实例。</li>
<li><strong>Prototype</strong> - 每次请求都会产生一个新的实例。</li>
<li><strong>Request</strong> - 每次请求都会创建一个实例</li>
<li><strong>Session</strong> - 在一个会话周期内只有一个实例</li>
<li>Global-session - 类似于标准的 HTTP Session 作用域，5.0版本后已不再使用</li>
<li><strong>Appilcation</strong> - 在一个 ServletContext 中只有一个实例</li>
<li><strong>Websocket</strong> - 在一个 Websocket 只有一个实例</li>
</ul>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后几个才可用。</p>
<h4 id="Bean-的生命周期⭐">Bean 的生命周期⭐</h4>
<ul>
<li>
<p>Bean容器/BeanFactory 通过对象的构造器或工厂方法先实例化 Bean；</p>
</li>
<li>
<p>再根据 Resource 中的信息再通过设定好的方法（典型的有setter，统称为BeanWrapper）对 Bean 设置属性值，得到 BeanDefintion 对象，然后 put 到 beanDefinitionMap 中，调用 getBean 的时候，从  beanDefinitionMap 里拿出 Class 对象进行注入（<strong>使用了反射</strong>），同时如果有依赖关系，将递归调用 getBean 方法，即依赖注入的过程。</p>
</li>
<li>
<p>检查 xxxAware 相关接口，比如 BeanNameAware，BeanClassLoaderAware，ApplicationContextAware（ BeanFactoryAware）等等，如果有就调用相应的 setxxx 方法把所需要的xxx传入到 Bean 中。</p>
<p><strong>补充</strong>：关于 Aware ，Aware 就是感知的意思， Aware 的目的是为了让Bean获得Spring容器的服务。 实现了这类接口的 bean 会存在“意识感”，从而让容器调用 setxxx 方法把所需要的 xxx 传到 Bean 中。</p>
</li>
<li>
<p>此时检查是否存在有于 Bean 关联的任何  BeanPostProcessors， 执行 postProcessBeforeInitialization() 方法（前置处理器）。</p>
</li>
<li>
<p>如果 Bean 实现了InitializingBean接口（正在初始化的 Bean），执行 afterPropertiesSet() 方法。</p>
</li>
<li>
<p>检查是否配置了自定义的 init-method 方法，如果有就调用。</p>
</li>
<li>
<p>此时检查是否存在有于 Bean 关联的任何  BeanPostProcessors， 执行 postProcessAfterInitialization() 方法（后置处理器）。返回 wrapperBean（包装后的 Bean）。</p>
</li>
<li>
<p>这时就可以开始使用 Bean 了，当容器关闭时，会检查 Bean 是否实现了 DisposableBean 接口，如果有就调用 destory() 方法。</p>
</li>
<li>
<p>如果 Bean 配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p>
</li>
</ul>
<p>上面整个过程就是 Bean 的整个生命周期了。</p>
<p><strong>Bean 单例和多例的情况：</strong></p>
<p>在实际情况中一般并不会实现很多扩展接口，我们知道，Bean 的基本类型分为 singleton（单例） 和 prototype（原型/多例） 两种，在容器创建过程中，单例 Bean 默认跟随容器一起实例化，而当我们指定 Bean节点的 lazy-init=”true” 时，只有在第一次获取 Bean 的时候才会初始化 Bean。当然，如果想让所有单例 Bean 都延迟加载，可以在根节点设置此属性。</p>
<p>当 scope=“prototype” 时，容器也会延迟初始化 Bean，并不会立刻创建对象，而是在第一次请求该 bean 时才初始化（如调用 getBean 方法时）。和单例不同的情况是：在对象销毁时，容器不会帮我们调用任何方法。</p>
<p>Spring不能对一个 prototype bean 的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个 prototype 实例后，将它交给客户端，随后就对该prototype 实例不闻不问了。</p>
<p>也许你会问，那么怎么释放被 prototype 作用域 bean 占用的资源？</p>
<p>我们可以通过 Bean 的后置处理器， 该处理器持有要被清除的bean的引用。</p>
<p>Spring 被设计成<strong>一个管理应用程序模块定义的容器以及工厂，而不是管理模块自身的容器</strong>，让模块可以分别独立开发，实现了模块之间的解耦。</p>
<p>为什么要使用Spring：</p>
<ol>
<li>Spring提供一个容器/工厂，统一管理模块的定义，根据需要创建。</li>
<li>把模块的配置参数统一管理，模块不需要自行读取配置。</li>
<li>Spring提供依赖注入，把依赖的模块自动推送进来，不需要模块自己拉取。</li>
<li>此外，Spring提供了对很多其他第三方框架的集成功能，减少了样板代码（boilerplate）。</li>
</ol>
<h2 id="常见扩展接口">常见扩展接口</h2>
<p>BeanFactoryPostProcessor：处理所有bean前,对bean factory进行预处理<br>
BeanDefinitionRegistryPostProcessor：可以添加自定义的bean<br>
BeanPostProcessor：支持在Bean初始化前、后对bean进行处理<br>
ApplicationContextAware：可以获得ApplicationContext及其中的bean<br>
InitializingBean：在bean创建完成,所有属性注入完成后执行<br>
DisposableBean：在bean销毁前执行<br>
ApplicationListener：用来监听产生的应用事件</p>
<h3 id="Spring的后置处理器">Spring的后置处理器</h3>
<ol>
<li>BeanPostProcessor：Bean的后置处理器，主要在bean初始化前后工作。</li>
<li>InstantiationAwareBeanPostProcessor：继承于BeanPostProcessor，主要在实例化bean前后工作； AOP创建代理对象就是通过该接口实现。</li>
<li>BeanFactoryPostProcessor：Bean工厂的后置处理器，在bean定义(bean definitions)加载完成后，bean尚未初始化前执行。</li>
<li>BeanDefinitionRegistryPostProcessor：继承于BeanFactoryPostProcessor。其自定义的方法postProcessBeanDefinitionRegistry会在bean定义(bean definitions)将要加载，bean尚未初始化前真执行，即在BeanFactoryPostProcessor的postProcessBeanFactory方法前被调用。</li>
</ol>
<h3 id="spring-自动装配-bean-有哪些方式？">spring 自动装配 bean 有哪些方式？</h3>
<p>Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。</p>
<p>spring中bean装配有两种方式：</p>
<ul>
<li>隐式的bean发现机制和自动装配</li>
<li>在java代码或者XML中进行显示配置</li>
</ul>
<h3 id="ApplicationContext和BeanFactory的区别⭐">ApplicationContext和BeanFactory的区别⭐</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory,</span><br><span class="line">    MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供实例化对象 和获取这两个功能。BeanFactory在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化。</p>
</li>
<li>
<p>ApplicationContext（<strong>应用上下文</strong>） 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能，继承了多个接口，因此具备了更多的功能。 如国际化，访问资源，载入多个（有继承关系）上下文 ，消息发送、响应机制，AOP等。</p>
</li>
</ul>
<h2 id="循环依赖">循环依赖</h2>
<h3 id="循环依赖是什么？⭐">循环依赖是什么？⭐</h3>
<p>bean A依赖于另一个bean B时，bean B依赖于bean A：</p>
<p>当Spring上下文加载所有bean时，它会尝试按照它们完全工作所需的顺序创建bean。例如，如果我们没有循环依赖，如下例所示：</p>
<p>豆A→豆B→豆C.</p>
<p>Spring将创建bean C，然后创建bean B（并将bean注入其中），然后创建bean A（并将bean B注入其中）。</p>
<p>但是，当具有循环依赖时，Spring无法决定应该首先创建哪个bean，因为它们彼此依赖。</p>
<p>以setter方式构成的循环依赖，spring可以帮你解决，以构造器方式构成的循环依赖，spring无法搞定。</p>
<p>setter 注入和构造器注入的区别就在于创建bean的过程中，setter注入可以先用无参数构造方法返回bean实例，再注入依赖的属性，使用到了 Spring 的三级缓存，而constructor方式<strong>无法先返回bean的实例，必须先实例化它所依赖的属性，这样一来就会造成死循环所以会失败。</strong></p>
<p>我们使用比较多的在属性上@Autowired的方式，在spring内部的处理中，与setter方法不太一样，但用此种方式循环依赖也可以解决，原理同上，只要能先实例化出来，提前暴露出来，就可以解决循环依赖的问题。</p>
<h3 id="Spring-如何解决循环依赖？⭐">Spring 如何解决循环依赖？⭐</h3>
<p>Spring使用了三级缓存解决了循环依赖的问题。在populateBean()给属性赋值阶段里面Spring会解析你的属性，并且赋值，当发现，A对象里面依赖了B，此时又会走getBean方法，但这个时候，你去缓存中是可以拿的到的。因为我们在对createBeanInstance对象创建完成以后已经放入了缓存当中，所以创建B的时候发现依赖A，直接就从缓存中去拿，此时B创建完，A也创建完。至此Bean的创建完成，最后将创建好的Bean放入单例缓存池中。</p>
<p>上面已经大概的解释了一下，现在来详细说说：</p>
<p><strong>我们知道，Bean 的创建最为核心三个方法解释如下：</strong></p>
<ul>
<li><code>createBeanInstance</code>：例化，其实也就是调用对象的<strong>构造方法</strong>实例化对象</li>
<li><code>populateBean</code>：填充属性，这一步主要是对bean的依赖属性进行注入(<code>@Autowired</code>)</li>
<li><code>initializeBean</code>：回到一些形如<code>initMethod</code>、<code>InitializingBean</code>等方法</li>
</ul>
<p>从对单例Bean的初始化可以看出，循环依赖主要发生在<strong>第二步（populateBean）</strong>，也就是field属性注入的处理。</p>
<p><strong>现在再来了解一下三级缓存：</strong></p>
<ol>
<li><code>singletonObjects</code>：第一级，单例缓存池。用于存放完全初始化好的 bean，<strong>从该缓存中取出的 bean 可以直接使用</strong></li>
<li><code>earlySingletonObjects</code>：第二级。提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性的 bean）</li>
<li><code>singletonFactories</code>：第三级，单例对象工厂缓存 。单例对象工厂的cache，存放 bean 工厂对象</li>
</ol>
<p><strong>了解完缓存就可以开始了解单例 Bean 的创建过程：</strong></p>
<ol>
<li>先从一级缓存singletonObjects中去获取。（如果获取到就直接return）</li>
<li>如果获取不到或者对象正在创建中（isSingletonCurrentlyInCreation()），那就再从二级缓存earlySingletonObjects中获取。（如果获取到就直接return）</li>
<li>如果还是获取不到，且允许singletonFactories（allowEarlyReference=true）通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。<strong>（如果获取到了就把这个 bean 从 singletonFactories 中移除，并且放进 earlySingletonObjects。其实也就是从三级缓存移动（是剪切）到了二级缓存）</strong></li>
</ol>
<p><strong>解决循环依赖的关键就在这个三级缓存，下面给出 A,B 循环依赖的情况 Spring 是如何操作的：</strong></p>
<ol>
<li>使用context.getBean(A.class)，为了获取容器内的单例A，若A不存在，就会走A这个Bean的创建流程，显然初次获取A是不存在的，所以开始创建 A</li>
<li>开始实例化A（<strong>createBeanInstance</strong>，注意此处仅仅是实例化），并将它放进缓存（此时A已经实例化完成，已经可以被引用了）</li>
<li>开始准备初始化A（populateBean）：解析 A 的依赖发现依赖注入了 B（此时需要去容器内获取B）</li>
<li>此时开始实例化 B，到了依赖注入B时，会通过getBean(B)去容器内找B。</li>
<li>实例化B，并将其放入缓存。（此时B也能够被引用了）</li>
<li>开始准备初始化B，发现依赖注入A（此时需要去容器内获取A）</li>
<li><strong>此处重要</strong>：初始化B时会调用getBean(A)去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以getBean(A)能够正常返回</li>
<li><strong>B初始化成功</strong>，return（注意此处return相当于是返回最上面的 getBean(B) 这句代码，回到了初始化A的流程中）。</li>
<li>因为B实例已经成功返回了，因此最终<strong>A也初始化成功</strong></li>
<li>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B</li>
</ol>
<h2 id="AOP">AOP</h2>
<h3 id="解释一下什么是-AOP？">解释一下什么是 AOP？</h3>
<p>AOP（Aspect-Oriented Programming，面向切面编程），可以说是 OOP 的补充和完善。OOP 定义了从上到下的关系，但并不适合定义从左到右的关系，例如权限认证、日志、事务处理。这些导致了大量代码的重复，而不利于各个模块的重用。而AOP技术将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<h2 id="AOP-的原理（重要）⭐">AOP 的原理（重要）⭐</h2>
<p>开启了 AOP 功能后，容器在注册 Bean 的后置处理器的时候，就会注册一个相关的后置处理器（AspectJAutoProxyCreator），在创建单实例 Bean 的时候，这个后置处理器就会拦截业务逻辑组件和切面组件的创建过程，怎么拦截呢？就是等组件创建完后，判断是否是通知方法，如果是就把切面的通知方法包装成增强器（Advisor），给业务逻辑组件（目标类）创建一个代理对象，代理的方式由 Spring 来判断返回这个代理对象，容器创建完成后这个代理对象执行目标方法的时候，执行拦截器链依次执行通知方法。</p>
<h2 id="JDK-动态代理和-CGLIB-的区别⭐">JDK 动态代理和 CGLIB 的区别⭐</h2>
<p><strong>静态代理与动态代理</strong><br>
静态代理，是编译时增强，AOP 框架会在编译阶段生成 AOP 代理类，在程序运行前代理类的.class文件就已经存在了。常见的实现：JDK静态代理，AspectJ 。<br>
动态代理，是运行时增强，它不修改代理类的字节码，而是在程序运行时，运用反射机制，在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>JDK 动态代理基于接口，所以只有接口中的方法会被增强，而 CGLIB 基于类继承，需要注意就是如果方法使用了 final 修饰，或者是 private 方法，是不能被增强的。</p>
<h3 id="实现原理">实现原理</h3>
<p>JDK动态代理：基于反射，利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。<br>
CGLIB动态代理：基于操作字节码，通过加载代理对象的类字节码，为代理对象创建一个子类，并在子类中拦截父类方法并织入方法增强逻辑。底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的。</p>
<h2 id="AspectJ-和-Spring-AOP">AspectJ 和 Spring AOP</h2>
<h3 id="区别">区别</h3>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong></p>
<h2 id="springAOP-项目中的实际应用">springAOP 项目中的实际应用</h2>
<p>只需要事务处理那些操作数据库的方法，所以使用了自定义注解</p>
<p>建议从项目中的事务注解讲</p>
<p>如果项目有实际应用的AOP自定义注解更好,</p>
<p>没有也不要慌把spring自带的事务注解讲明白也可以</p>
<p>面试官主要考察有没有AOP的思想,</p>
<p>实际项目中AOP应用太广泛了  日志,权限,事务等等都可以利用AOP去完成统一设计.</p>
<h2 id="SpringMVC">SpringMVC</h2>
<h2 id="Springmvc-请求处理的流程⭐">Springmvc 请求处理的流程⭐</h2>
<ol>
<li>
<p>客户端发送url请求，前端控制器（<strong>DispatcherServlet</strong>）接收到这个请求然后转发给处理器映射器（<strong>HandlerMapping</strong>）。</p>
</li>
<li>
<p>处理器映射器会对url请求进行分析，找到对应的后端控制器（Handler），并且生成处理器对象及处理器拦截器（形成一条执行链）返回给前端控制器。</p>
</li>
<li>
<p>根据处理器映射器返回的后端控制器(Handler)的名称/索引， 前端控制器 会找合适的处理器适配器( <strong>HandlerAdapter</strong> )</p>
</li>
<li>
<p>处理器适配器会去执行后端控制器(Handler在开发的时候会被叫成<strong>Controller</strong>）。补充：执行之前会有转换器、数据绑定、校验器等等操作。完成上面这些才会去执行后端控制器。</p>
</li>
<li>
<p>后端控制器Handler执行完成之后返回一个 <strong>ModelAndView</strong> 对象， Model 是返回的数据对象，View 是个逻辑上的 View。</p>
</li>
<li>
<p>处理器适配器会将这个 ModelAndView 返回前端控制器。前端控制器会将 ModelAndView 对象交给合适的视图解析器 <strong>ViewResolver</strong> 。</p>
</li>
<li>
<p>视图解析器（ViewResolver）解析 ModelAndView 对象,返回 <strong>视图对象（view）</strong>。</p>
</li>
<li>
<p>前端控制器请求视图对视图对象（View）进行渲染(数据填充)之后返回并响应给浏览器/客户端。</p>
</li>
</ol>
<h3 id="Springmvc-有哪些组件">Springmvc 有哪些组件</h3>
<p>**1、**前端控制器DispatcherServlet（不需要工程师开发）,由框架提供（重要）</p>
<p>作用：<strong>Spring MVC 的入口函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。</strong></p>
<p><strong>2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong></p>
<p>作用：根据请求的url查找Handler。HandlerMapping负责根据用户请求找到Handler即处理器（Controller），SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p><strong>3、处理器适配器HandlerAdapter</strong></p>
<p>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<p><strong>4、处理器Handler(需要工程师开发)</strong></p>
<p>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p>
<p><strong>5、视图解析器View resolver(不需要工程师开发),由框架提供</strong></p>
<p>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>
<p><strong>6、视图View(需要工程师开发)</strong></p>
<p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>
<h2 id="常用注解">常用注解</h2>
<p><strong>类型类</strong></p>
<ul>
<li>
<p>@Controller：负责注册一个bean 到spring 上下文中</p>
</li>
<li>
<p>@Service</p>
</li>
<li>
<p>@Repository</p>
</li>
<li>
<p>@Component</p>
</li>
<li>
<p>@Configuration：声明当前类为配置类，相当于xml形式的Spring配置</p>
</li>
<li>
<p>@Bean：注解在方法上，声明当前方法的返回值为一个 bean</p>
<p><strong>@Bean和@Component的区别</strong></p>
<ul>
<li>
<p>@Component 在类上使用，表示这是一个组件类，需要 Spring 为这个类创建 Bean</p>
</li>
<li>
<p>@Bean 在方法上使用，告诉 Spring 这个方法将返回一个 Bean 对象，需要把返回的对象注册到应用上下文中</p>
</li>
</ul>
</li>
</ul>
<p><strong>设置类</strong></p>
<ul>
<li>@Required：确保值一定被设置</li>
<li>@Autowired &amp;&amp; @Qualifier
<ul>
<li>@Qualifier：当一个接口有多个实现的时候，为了指名具体调用哪个类的实现。</li>
</ul>
</li>
<li>@Scope：生命周期</li>
</ul>
<p><strong>Web类</strong></p>
<ul>
<li>
<p>@RequestMapping &amp;&amp; @GetMapping @ PostMapping</p>
<ul>
<li>RequestMapping：用于映射Web请求，包括访问路径和参数（类或方法上）</li>
</ul>
</li>
<li>
<p>@PathVariable &amp;&amp; @RequestParam</p>
<ul>
<li>@PathVariable：用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</li>
</ul>
</li>
<li>
<p>@RequestBody &amp;&amp; @ResponseBody</p>
<ul>
<li>
<p>@RequestBody 接收JSON数据</p>
<p>该注解用于读取 Request 请求的 body 部分数据。允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p>
</li>
<li>
<p>@ResponseBody 将java对象转换成json格式的字符串，返回给浏览器。该注解用于将 Controller 的方法返回的对象，写入到 Response 对象的 body 数据区。 （返回值旁或方法上）</p>
</li>
</ul>
</li>
</ul>
<p><strong>功能类</strong></p>
<ul>
<li>@ImportResource：引用类</li>
<li>@ComponentScan：自动扫描</li>
<li>@EnableCaching &amp;&amp; Cacheable： 开启注解式的缓存支持/缓存</li>
<li>@Transactional：开启事务</li>
<li>@Aspect &amp;&amp; Poincut：切面和切点</li>
<li>@Scheduled：来申明这是一个任务</li>
</ul>
<ul>
<li>
<p>@RequestController  <strong>@RestController=@ResponseBody+@Controller</strong> 意味着，该Controller的所有方法都默认加上了@ResponseBody。</p>
</li>
<li>
<p>@ControllerAdvice 使一个Contoller成为全局的异常处理类,类中用@ExceptionHandler方法注解的方法可以处理所有Controller发生的异常。</p>
</li>
<li>
<p>@ModelAttribute最主要的作用是将数据添加到模型对象中，用于视图页面展示时使用。 等价于 model.addAttribute(“attributeName”, abc)。</p>
</li>
</ul>
<h2 id="Spring-框架中用到了哪些设计模式？">Spring 框架中用到了哪些设计模式？</h2>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li><strong>策略模式：</strong></li>
</ul>
<p>详细待补充。。。</p>
<h2 id="Spring-事务">Spring 事务</h2>
<h3 id="Spring-管理事务的方式有几种？">Spring 管理事务的方式有几种？</h3>
<ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h2 id="事务注解-Transactional实现机制⭐">事务注解@Transactional实现机制⭐</h2>
<p>在应用系统调用声明@Transactional 的目标方法时，Spring 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional 的属性配置信息，代理对象来决定该声明@Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在拦截时，会在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器操作数据源 DataSource 提交或回滚事务。</p>
<h3 id="Transactional-rollbackFor-Exception-class-注解">@Transactional(rollbackFor = Exception.class)注解</h3>
<p>我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p>
<h2 id="事务传播行为-机制⭐">事务传播行为/机制⭐</h2>
<p>事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。</p>
<p>Spring中的7个事务传播行为:</p>
<ol>
<li>REQUIRED（默认）：支持使用当前事务，如果当前事务不存在，创建一个新事务。</li>
<li>SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。</li>
<li>MANDATORY：强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。</li>
<li>REQUIRES_NEW：创建一个新事务，如果当前事务存在，把当前事务挂起。</li>
<li>NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。</li>
<li>NEVER：无事务执行，如果当前有事务则抛出Exception。</li>
<li>NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</li>
</ol>
<!-- 文件: SpringBean 的生命周期.md -->
<h2 id="Bean-的完整生命周期-2">Bean 的完整生命周期</h2>
<ul>
<li>
<p>Bean容器/BeanFactory 通过对象的构造器或工厂方法先实例化 Bean；</p>
</li>
<li>
<p>再根据 Resource 中的信息再通过设定好的方法（典型的有setter，统称为BeanWrapper）对 Bean 设置属性值，得到 BeanDefintion 对象，然后 put 到 beanDefinitionMap 中，调用 getBean 的时候，从  beanDefinitionMap 里，拿出 Class 对象进行注入，同时，如果有依赖关系，将递归调用 getBean 方法，即依赖注入的过程。</p>
</li>
<li>
<p>检查 xxxAware 相关接口，比如 BeanNameAware，BeanClassLoaderAware，ApplicationContextAware（ BeanFactoryAware）等等，如果有就调用相应的 setxxx 方法把所需要的xxx传入到 Bean 中。</p>
<p><strong>补充</strong>：关于 Aware ，Aware 就是感知的意思， Aware 的目的是为了让Bean获得Spring容器的服务。 实现了这类接口的 bean 会存在“意识感”，从而让容器调用 setxxx 方法把所需要的 xxx 传到 Bean 中。</p>
</li>
<li>
<p>此时检查是否存在有于 Bean 关联的任何  BeanPostProcessors， 执行 postProcessBeforeInitialization() 方法（前置处理器）。</p>
</li>
<li>
<p>如果 Bean 实现了InitializingBean接口（正在初始化的 Bean），执行 afterPropertiesSet() 方法。</p>
</li>
<li>
<p>检查是否配置了自定义的 init-method 方法，如果有就调用。</p>
</li>
<li>
<p>此时检查是否存在有于 Bean 关联的任何  BeanPostProcessors， 执行 postProcessAfterInitialization() 方法（后置处理器）。返回 wrapperBean（包装后的 Bean）。</p>
</li>
<li>
<p>这时就可以开始使用 Bean 了，当容器关闭时，会检查 Bean 是否实现了 DisposableBean 接口，如果有就调用 destory() 方法。</p>
</li>
<li>
<p>如果 Bean 配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p>
</li>
</ul>
<!-- 文件: SpringBoot.md -->
<h3 id="什么是-Spring-Boot？">什么是 Spring Boot？</h3>
<p><strong>如果必须启动一个新的 Spring 项目，我们必须添加构建路径或 maven 依赖项，配置 application server，添加 Spring 配置。因此，启动一个新的 Spring 项目需要大量的工作，因为我们目前必须从头开始做所有事情</strong>。  Spring Boot 是这个问题的解决方案。Spring boot 构建在现有 Spring 框架之上。使用 Spring boot，可以避免以前必须执行的所有样板代码和配置。</p>
<h3 id="Spring-Boot-的优点是什么">Spring Boot 的优点是什么?</h3>
<p>编码：减少开发、测试的时间和工作量。</p>
<p>配置：使用 JavaConfig 有助于避免使用 XML。没有 web.xml 文件，只需添加带 @ configuration 注释的类。</p>
<p>避免大量 maven 导入和各种版本冲突。</p>
<p>部署：不需要单独的 Web 服务器。这意味着您不再需要启动 Tomcat 或其他任何东西。</p>
<h2 id="Spring-Boot-启动流程⭐">Spring Boot 启动流程⭐</h2>
<p>首先 prepareEnvironment 配置环境，然后准备 Context 上下文，ApplicationContext 的后置处理器，初始化 lnitializers，通知处理上下文准备和加载时间，然后开始refresh。</p>
<p>prepareEnvironment</p>
<p>createApplicationContext<br>
postProcessApplicationContext<br>
applylnitializers<br>
listeners.contextPrepared<br>
listeners.contextLoaded<br>
refreshContext</p>
<h3 id="Spring-Boot提供了两种常用的配置文件：">Spring Boot提供了两种常用的配置文件：</h3>
<ul>
<li>properties文件</li>
<li>yml文件</li>
</ul>
<h2 id="Spring-Boot-的核心注解是哪个？⭐">Spring Boot 的核心注解是哪个？⭐</h2>
<p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：       @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p>
<p>@ComponentScan：Spring组件扫描。</p>
<h2 id="Spring-Boot-自动配置原理是什么⭐">Spring Boot 自动配置原理是什么⭐</h2>
<p>@EnableAutoConfiguration这个注解开启自动配置，它的作用：</p>
<ul>
<li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件</li>
<li>这个类父类有一个方法：selectImports()，这个方法返回 <strong>configurations</strong> ：</li>
<li>List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置
<ul>
<li>将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中</li>
</ul>
</li>
<li>加载某个组件的时候根据注解的条件判断每个加入的组件是否生效，如果生效就把类的属性和配置文件绑定起来</li>
<li>这时就读取配置文件的值加载组件</li>
</ul>
<h3 id="SpringBoot、SpringMVC和Spring区别">SpringBoot、SpringMVC和Spring区别</h3>
<p>spring boot只是一个配置工具,整合工具,辅助工具.</p>
<p>springmvc是框架,项目中实际运行的代码</p>
<p>Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring 的ioc和 aop，ioc 提供了依赖注入的容器， aop解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。</p>
<p>用最简练的语言概括就是：</p>
<ul>
<li>Spring 是一个“引擎”；</li>
<li>Spring MVC 是基于Spring的一个 MVC 框架；</li>
<li>Spring Boot 是基于Spring的条件注册的一套快速开发整合包</li>
</ul>
<h2 id="SpringBoot-拦截器和过滤器">SpringBoot 拦截器和过滤器</h2>
<p>​        1、Filter是依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。</p>
<p>2、Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理的方式来执行。</p>
<p>3、Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;logFilter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogCostFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;LogFilter Execute cost=&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑比较简单，就是在方法执行前先记录时间戳，然后通过过滤器链完成请求的执行，在返回结果之间计算执行的时间。这里需要主要，这个类必须继承Filter类，这个是Servlet的规范，这个跟以前的Web项目没区别。 这里直接用@WebFilter就可以进行配置，同样，可以设置url匹配模式，过滤器名称等。这里需要注意一点的是@WebFilter这个注解是Servlet3.0的规范，并不是Spring boot提供的。除了这个注解以外，我们还需在配置类中加另外一个注解：@ServletComponetScan，指定扫描的包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.pandy.blog.dao&quot;)</span></span><br><span class="line"><span class="meta">@ServletComponentScan(&quot;com.pandy.blog.filters&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们已经介绍了过滤器的配置方法，接下来我们再来看看如何配置一个拦截器。我们使用拦截器来实现上面同样的功能，记录请求的执行时间。首先我们实现拦截器类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogCostInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Interceptor cost=&quot;</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要实现HandlerInterceptor这个接口，这个接口包括三个方法，preHandle是请求执行前执行的，postHandler是请求结束执行的，但只有preHandle方法返回true的时候才会执行，afterCompletion是视图渲染完成后才执行，同样需要preHandle返回true，该方法通常用于清理资源等工作。除了实现上面的接口外，我们还需对其进行配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LogCostInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们继承了WebMVCConfigurerAdapter，看过前面的文章的朋友应该已经见过这个类了，在进行静态资源目录配置的时候我们用到过这个类。这里我们重写了addInterceptors这个方法，进行拦截器的配置，主要配置项就两个，一个是指定拦截器，第二个是指定拦截的URL。</p>
<h2 id="spring-boot处理一个http请求的全过程">spring boot处理一个http请求的全过程</h2>
<ul>
<li>由前端发起请求</li>
<li>根据路径，Springboot会加载相应的Controller进行拦截</li>
<li>拦截处理后，跳转到相应的Service处理层</li>
<li>跳转到ServiceImplement(service实现类)</li>
<li>在执行serviceimplement时会加载Dao层，操作数据库</li>
<li>再跳到Dao层实现类</li>
<li>执行会跳转到mapper层</li>
<li>然后MallMapper会继续找对应的mapper.xml配置文件</li>
<li>之后便会跳转到第4步继续执行，执行完毕后会将结果返回到第1步，然后</li>
<li>便会将数据以JSON的形式返回到页面，同时返回状态码，正常则会返回200，便会回到步骤1中查询判断。</li>
</ul>
<!-- 文件: Spring的设计理念和设计模式分析.md -->
<h1>Spring 的架构</h1>
<p>Spring 总共有十几个组件，不过真正核心的组件只有几个：<strong>Core，Context，Beans</strong>。</p>
<h2 id="Spring-的设计理念">Spring 的设计理念</h2>
<p>然而最最核心的是 Beans 组件，为什么这么说，其实在  Spring 就是面向 Bean 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中才是真正的主角。</p>
<p>Bean 在 Spring 中作用就像 Object 对 OOP 的意义一样，没有对象的概念就像没有面向对象编程，Spring 中没有 Bean 也就没有 Spring 存在的意义。就像一次演出舞台都准备好了但是却没有演员一样。为什么要 Bean 这种角色 Bean 或者为何在 Spring 如此重要，这由 Spring 框架的设计目标决定，Spring 为何如此流行，我们用 Spring 的原因是什么，想想你会发现原来 Spring 解决了一个非常关键的问题他可以让你把对象之间的依赖关系转而用配置文件来管理，也就是他的依赖注入机制。而这个注入关系在一个叫 Ioc 容器中管理，那 Ioc 容器就是被 Bean 包裹的对象。Spring 正是通过把对象包装在 Bean 中而达到对这些对象的管理以及一些列额外操作的目的。</p>
<h3 id="核心组件如何协同工作">核心组件如何协同工作</h3>
<p>前面说 Bean 是 Spring 中关键因素，那 Context 和 Core 又有何作用呢？前面把 Bean 比作一场演出中的演员的话，那 Context 就是这场演出的舞台背景，而 Core 应该就是演出的道具了。只有他们在一起才能具备演出一场好戏的最基本条件。当然有最基本的条件还不能使这场演出脱颖而出，还要他表演的节目足够的精彩，这些节目就是 Spring 能提供的特色功能了。</p>
<p>我们知道 Bean 包装的是 Object，而 Object 必然有数据，如何给这些数据提供生存环境就是 Context 要解决的问题，对 Context 来说他就是要发现每个 Bean 之间的关系，为它们建立这种关系并且要维护好这种关系。所以 Context 就是一个 Bean 关系的集合，这个关系集合又叫 Ioc 容器，一旦建立起这个 Ioc 容器后 Spring 就可以为你工作了。那 Core 组件又有什么用武之地呢？其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具，从这个角度看来，Core 这个组件叫 Util 更能让你理解。</p>
<h2 id="核心组件详解">核心组件详解</h2>
<p>下面将详细介绍每个组件内部类的层次关系，以及它们在运行时的时序顺序。我们在使用 Spring 是应该注意的地方。</p>
<h3 id="Bean-组件">Bean 组件</h3>
<p>前面已经说明了 Bean 组件对 Spring 的重要性，下面看看 Bean 这个组件式怎么设计的。Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。</p>
<h4 id="Bean-工厂">Bean 工厂</h4>
<p>Spring Bean 的创建是典型的工厂模式，它的顶级接口是 BeanFactory。防止大家产生看晕，对于这个工厂的继承层次我就不说的太详细了，所有的接口都有使用的场合，我们需要知道 BeanFactory 有三个较重要的子类：ListableBeanFactory（可列表的）、HierarchicalBeanFactory（有继承关系的） 和 AutowireCapableBeanFactory（可以自动装配的）。 而我们最常使用的 ApplicationContext 类继承了 ListableBeanFactory、HierarchicalBeanFactory。</p>
<p>ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。</p>
<p>综上，ApplicationContext 容器通过继承可以拥有可列表，有继承关系的能力，而它内部也定义了一个得到自动装配的工厂接口，从而实现了自动装配能力。</p>
<h4 id="BeanDefinition">BeanDefinition</h4>
<p>说完了 Bean 工厂，现在来说说 Bean 本身，而 Bean 的定义主要由 BeanDefinition 描述。</p>
<p>其实  BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean （<code>&lt;bean/&gt;</code> 或 注解）其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。 所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。 得到 BeanDefinition  了，下面要对他进行解析，这个过程很复杂，因为很多可扩展的地方，xxxReader就是解析类，我暂时不过多介绍。</p>
<h3 id="Context-组件">Context 组件</h3>
<p>Context 在 Spring 的 org.springframework.context 包下，前面已经讲解了 Context 组件在 Spring 中的作用，他实际上就是给 Spring 提供一个运行时的环境，用以保存各个对象的状态。下面看一下这个环境是如何构建的。</p>
<p><strong>ApplicationContext</strong> 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口：EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource,ApplicationEventPublisher, ResourcePatternResolver，这五个接口主要是扩展了 Context 的功能。</p>
<p>ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源，这将在 Core 中详细说明。</p>
<p>ApplicationContext 的常用子类主要包含：</p>
<ul>
<li>
<p>ClassPathXmlApplicationContext：可以加载类路径下的配置文件，不在的话加载不了</p>
</li>
<li>
<p>FileSystemXmlApplicationContext：可以加载磁盘任意路径下的配置文件（必须有访问权限）</p>
</li>
<li>
<p>AnnotationConfigApplicationContext  用于读取注解创建容器的</p>
</li>
</ul>
<p>总体来说 ApplicationContext 必须要完成以下几件事：</p>
<ul>
<li>标识一个应用环境</li>
<li>利用 BeanFactory 创建 Bean 对象</li>
<li>保存对象关系表</li>
<li>能够捕获各种事件</li>
</ul>
<p><strong>Context 作为 Spring 的 Ioc 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</strong></p>
<h3 id="Core-组件">Core 组件</h3>
<p>Core 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式  Resource。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。</p>
<p>Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。  对资源的提供者来说，Resource 也可以把资源包装起来交给其他人，所以也屏蔽了资源的提供者。</p>
<p>那么 Context 和 Resource 的类关系是怎么样的？他们是如何协同工作的？</p>
<p>Context 是把资源的加载、解析和描述工作委托给了 ResourcePatternResolver 类来完成，他相当于一个接头人，他把资源的加载、解析和资源的定义整合在一起便于其他组件使用。Core 组件中还有很多类似的方式。</p>
<h2 id="创建-BeanFactory-工厂">创建 BeanFactory 工厂</h2>
<p>介绍了 Core 组件、Bean 组件和 Context 组件的结构与相互关系，下面这里从使用者角度看一下他们是如何运行的，  以及我们如何让 Spring 完成各种功能，Spring 到底能有那些功能，这些功能是如何得来的。</p>
<p><strong>Ioc 容器实际上就是 Context 组件结合其他两个组件共同构建了一个 Bean 关系网。</strong></p>
<p>下面就是经典的 refresh() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 刷新前的预处理,初始化一些属性设置,检验属性的合法等,保存容器中的一些早期的事件；</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取BeanFactory,这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="comment">//将创建的BeanFactory【DefaultListableBeanFactory】返回；</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//BeanFactory的预准备工作（对BeanFactory进行一些设置）</span></span><br><span class="line">      <span class="comment">//设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，比如：</span></span><br><span class="line">      <span class="comment">//ApplicationContextAwareProcessor</span></span><br><span class="line">      <span class="comment">//手动注册几个特殊的 bean</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         <span class="comment">//两大接口：</span></span><br><span class="line">  		 <span class="comment">//BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 	</span></span><br><span class="line">         <span class="comment">//postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">//注册BeanPostProcessor（Bean的后置处理器）作用：拦截 bean 的注册过程</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的组件（做国际化功能；消息绑定，消息解析）；</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         <span class="comment">// 留给子容器（子类）,子类重写这个方法，在容器刷新的时候可以自定义逻辑；</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口	</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化所有的单实例bean；</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">          </span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化所有的单实例bean的过程中，有一个非常重要的 Bean —— FactoryBean，可以说 Spring 一大半的扩展的功能都与这个 Bean 有关，这是个特殊的 Bean 是一个工厂 Bean，可以产生 Bean 的 Bean，这里的产生 Bean 是指 Bean 的实例，如果一个类继承 FactoryBean 用户只要实现他的 getObject 方法，就可以自己定义产生实例对象的方法。然而在 Spring 内部这个 Bean 的实例对象是 FactoryBean，通过调用这个对象的 getObject 方法就能获取用户自定义产生的对象，从而为 Spring 提供了很好的扩展性。Spring 获取 FactoryBean 本身的对象是在前面加上 &amp; 来完成的。</p>
<h5 id="Bean-实例创建流程图">Bean 实例创建流程图</h5>
<p><img src="C:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CDesktop%5Cgithub%E7%AC%94%E8%AE%B0%5Cspring%5Cbean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.gif" alt="bean的实例化"></p>
<p>普通的 Bean 就是通过调用 getBean 方法来创建的。</p>
<p>getBean 调用 doGetBean，再调用 createBean，再调用 doCreateBean。</p>
<p>doCreateBean 有三个重要方法，一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 Bean初始化 initializeBean 。</p>
<p>创建好的实例对象放入缓存对象保存。</p>
<h3 id="Ioc-容器的扩展点">Ioc 容器的扩展点</h3>
<p>对 Spring 的 Ioc 容器来说，主要有这么几个可扩展的点。BeanFactoryPostProcessor， BeanPostProcessor。他们分别是在构建 BeanFactory 和构建 Bean 对象时调用。还有就是 InitializingBean 和 DisposableBean， 他们分别是在 Bean 实例创建和销毁时被调用。用户可以实现这些接口中定义的方法，Spring 就会在适当的时候调用他们。还有一个是 FactoryBean 他是个特殊的 Bean，这个 Bean 可以被用户更多的控制。</p>
<p>这些扩展点通常也是我们使用 Spring 来完成我们特定任务的地方，如何精通 Spring 就看你有没有掌握好 Spring 有哪些扩展点，并且如何使用他们，要知道如何使用他们就必须了解他们内在的机理。可以用下面一个比喻来解释。</p>
<p>我们把 Ioc 容器比作一个箱子，这个箱子里有若干个球的模子，可以用这些模子来造很多种不同的球，还有一个造这些球模的机器，这个机器可以产生球模。那么他们的对应关系就是：BeanFactory 是那个造球模的机器，球模就是 Bean，而球模造出来的球就是 Bean 的实例。那前面所说的几个扩展点又在什么地方呢？ BeanFactoryPostProcessor 对应到当造球模被造出来时，你将有机会可以对其做出适当的修正，也就是他可以帮你修改球模。而 InitializingBean 和 DisposableBean 是在球模造球的开始和结束阶段，你可以完成一些预备和扫尾工作。BeanPostProcessor 就可以让你对球模造出来的球做出适当的修正。最后还有一个 FactoryBean，它可是一个神奇的球模。这个球模不是预先就定型了，而是由你来给他确定它的形状，既然你可以确定这个球模型的形状，当然他造出来的球肯定就是你想要的球了，这样在这个箱子里你可以发现所有你想要的球。</p>
<h1>Spring 中设计模式分析</h1>
<p>Spring 主要使用了工厂模式，单例模式，模版模式，代理模式和策略模式。</p>
<!-- 文件: 多线程面试题.md -->
<h1>多线程面试题</h1>
<p><strong>临界资源</strong></p>
<p>临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p>
<p><strong>临界区：</strong></p>
<p>每个进程中访问临界资源的那段代码称为临界区（criticalsection），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。</p>
<h2 id="线程和进程的区别？⭐">线程和进程的区别？⭐</h2>
<ul>
<li>进程是系统资源分配的最小单位，线程是程序执行的最小单位</li>
<li>进程使用独立的数据空间，而线程共享线程的数据空间</li>
<li>进程的切换效率比线程低</li>
<li>通信方式不同</li>
</ul>
<h2 id="进程间通信方式">进程间通信方式</h2>
<ol>
<li>无名管道：半双工的，即数据只能在一个方向上流动，只能用于具有亲缘关系的进程之间的通信，可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li>
<li>FIFO命名管道：FIFO是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li>
<li>消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li>
<li>信号量：信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li>
<li>共享内存：共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。</li>
</ol>
<p><strong>TODO:简单介绍进程的切换过程</strong></p>
<p>主要考察线程上下文的切换代价，要回答切换会保持寄存器、栈等线程相关的现场，需要由用户态切换到内核态，最后知道可以通过vmstate命令查看上下文的切换状况</p>
<h2 id="线程通信方式">线程通信方式</h2>
<ul>
<li>volatile 关键字： 使用共享内存的思想，多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。</li>
<li>使用 Object 类的wait() 和 notify() 方法</li>
<li>使用 ReentrantLock 结合 Condition的 await() 和 signal() 方法</li>
<li>信号量 <strong>Semaphore</strong>，可以控制对共享资源的并发访问度，有 accquire() 和 release() 方法</li>
<li><strong>CountDownLatch</strong>：控制线程等待，计数器功能，可以用来等待多个线程执行任务后进行汇总</li>
<li><strong>CyclicBarrier</strong>：类似CountDownLatch但更强大，可以重复使用，控制多个线程，一般测试使用</li>
<li>基本LockSupport实现线程间的阻塞和唤醒</li>
</ul>
<h3 id="死锁的4个必要条件⭐">死锁的4个必要条件⭐</h3>
<ol>
<li>互斥条件：一个资源每次只能被一个线程使用；</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h2 id="如何分析是否有线程死锁？-⭐">如何分析是否有线程死锁？ ⭐</h2>
<p>使用jconsole图形化工具直接检查死锁</p>
<p>使用jstack命令行分析线程Dump信息</p>
<h2 id="理解线程的同步与异步、阻塞与非阻塞">理解线程的同步与异步、阻塞与非阻塞</h2>
<p>同步与异步的区别是任务是否在同一个线程中执行的 ，阻塞与非阻塞的区别是异步执行任务时线程是不是会阻塞等待结果还是会继续等待后面的逻辑</p>
<h2 id="创建线程有哪几种方式，如何实现？">创建线程有哪几种方式，如何实现？</h2>
<p>①. 继承Thread类创建线程类</p>
<ul>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
<p>②. 通过Runnable接口创建线程类</p>
<ul>
<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
<p>③. 通过Callable和Future创建线程</p>
<ul>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li>
</ul>
<p>④. 通过线程池创建线程</p>
<ul>
<li>调用Executors.newFixedThreadPool方法创建线程池。</li>
<li>Runnable的匿名内部类创建线程。</li>
<li>结束要调用shutdown关闭线程池。</li>
</ul>
<h2 id="runnable-和-callable-有什么区别">runnable 和 callable 有什么区别</h2>
<ul>
<li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li>
<li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li>
</ul>
<h2 id="sleep和wait的区别⭐">sleep和wait的区别⭐</h2>
<p><strong>本质区别</strong><br>
Thread.sleep只会让出CPU ,不会导致锁行为的改变<br>
Object.wait不仅让出CPU , 还会释放已经占有的同步资源锁</p>
<ul>
<li>wait属于Object类，sleep属于Thread类</li>
<li>wait会释放对象锁，而sleep不会</li>
<li>wait需要在同步块中使用，sleep可以在任何地方使用</li>
<li>sleep需要捕获异常、wait不需要</li>
</ul>
<h2 id="notify-和-notifyAll-有什么区别">notify()和 notifyAll()有什么区别</h2>
<p><strong>锁池EntiyList</strong>：当一个线程需要调用调用此方法时必须获得该对象的锁，而该对象的锁被其他线程占用，该线程就需要在一个地方等待锁释放，这个地方就是锁池。（准备抢锁的池子）<br>
<strong>等待池WaitSet</strong>：调用了wait方法的线程会释放锁并进入等待池，在等待池的线程不会竞争锁。（休息的池子）</p>
<p>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</p>
<p>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。</p>
<h2 id="线程的-run-和-start-有什么区别？-为什么不能直接调用-run-方法？">线程的 run()和 start()有什么区别？/为什么不能直接调用 run() 方法？</h2>
<p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start()方法来启动一个线程，这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码，真正实现了多线程运行。 此时start()方法启动的线程是处于就绪状态， 但并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p><strong>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已</strong>，直接调用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h2 id="线程的生命周期和状态">线程的生命周期和状态</h2>
<ul>
<li>
<p>新建(New) :创建后尚未启动的线程的状态</p>
</li>
<li>
<p>可运行(Runnable):就绪和运行两种状态统称为运行中</p>
</li>
<li>
<p>阻塞(Blocked):等待获取排它锁</p>
</li>
<li>
<p>无限期等待(Waiting): 阻塞和等待的区别在于，阻塞是被动的，而等待是主动的，不会被分配CPU执行时间,需要显式被唤醒</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody>
</table>
<ul>
<li>限期等待(Timed Waiting):在一定时间后会由系统自动唤醒</li>
</ul>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody>
</table>
<p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<ul>
<li>结束(Terminated):已终止线程的状态,线程已经结束执行</li>
</ul>
<h2 id="线程的各种状态的切换（重要）⭐">线程的各种状态的切换（重要）⭐</h2>
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/线程状态切换.png"/> </div><br>
<ol>
<li>得到一个线程类，new出一个实例线程就进入new状态（新建状态）。</li>
<li>调用start方法就进入Runnable（可运行状态）</li>
<li>如果此状态被操作系统选中并获得时间片就进入Running状态</li>
<li>如果Running状态的线程的时间片用完或者调用yield方法就<strong>可能</strong>回到Runnable状态</li>
<li>处于Running状态的线程如果在进入同步代码块/方法就会进入Blocked状态（阻塞状态），锁被其它线程占有，这个时候被操作系统挂起。得到锁后会回到Running状态。</li>
<li>处于Running状态的线程如果调用了wait/join/LockSupport.park()就会进入等待池（无限期等待状态）， 如果没有被唤醒或等待的线程没有结束，那么将一直等待。</li>
<li>处于Running状态的线程如果调用了sleep(睡眠时间)/wait(等待时间)/join(等待时间)/ LockSupport.parkNanos(等待时间)/LockSupport.parkUntil(等待时间)方法之后进入限时等待状态，等待时间结束后自动回到原来的状态。</li>
<li>处于Running状态的线程方法执行完毕或者异常退出就会进入死亡状态。</li>
</ol>
<h2 id="有哪几种实现生产者消费者模式的方法？">有哪几种实现生产者消费者模式的方法？</h2>
<p>锁、信号量、线程通信、阻塞队列。</p>
<h2 id="什么是上下文切换-⭐">什么是上下文切换?⭐</h2>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式（程序计数器）。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<h2 id="创建线程池ThreadPoolExecutor有哪几种方式？">创建线程池ThreadPoolExecutor有哪几种方式？</h2>
<p>①. newFixedThreadPool(int nThreads)<br>
创建一个固定线程数量的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，新的任务会暂存在任务队列中，待有线程空闲时便处理任务。</p>
<p>②. newCachedThreadPool()<br>
创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<p>③. newSingleThreadExecutor()<br>
这是一个单线程的Executor，它的特点是能确保依照任务在队列中的顺序来串行执行，适用于保证异步执行顺序的场景。</p>
<p>④. newScheduledThreadPool(int corePoolSize)（推荐）<br>
创建了一个固定长度的线程池，以定时的方式来执行任务，适用于定期执行任务的场景。</p>
<p>⑤.newWorkStealingPool<br>
使用ForkJoinPool ,多任务队列的固定并行度，适合任务执行时长不均匀的场景</p>
<p>前四个都是使用 ThreadPoolExecutor() 的不同初始化参数创建的。</p>
<p>场景：大量短期的任务场景适合使用 Cached 线程池，系统资源比较紧张时使用固定线程池。慎用无界队列，有OOM风险。<strong>自己项目有一个可能高吞吐量的场景就使用了 Cached 线程池</strong></p>
<h2 id="线程池都有哪些状态">线程池都有哪些状态</h2>
<p>RUNNING :能接受新提交的任务,并且也能处理阻塞队列中的任务<br>
SHUTDOWN :不再接受新提交的任务,但可以处理存量任务<br>
STOP :不再接受新提交的任务,也不处理存量任务<br>
TIDYING :所有的任务都已终止<br>
TERMINATED : 结束方法terminated()执行完后进入该状态</p>
<h2 id="线程池核心参数⭐">线程池核心参数⭐</h2>
<ul>
<li><strong>corePoolSize</strong>：线程池里的线程数量，核心线程池大小</li>
<li><strong>maxPoolSize</strong>：线程池里的最大线程数量</li>
<li><strong>workQueue</strong>： 任务队列，用于存放提交但是尚未被执行的任务。</li>
<li>keepAliveTime：当线程池中的线程数量大于 corePoolSize 时，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了  keepAliveTime 才会被回收销毁； 参数的时间单位为 unit。</li>
<li>阻塞队列种类</li>
<li>threadFactory：线程工厂，用于创建线程，一般可以用默认的</li>
<li>handler：拒绝策略</li>
</ul>
<h3 id="线程池的拒绝策略⭐">线程池的拒绝策略⭐</h3>
<ol>
<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li>
<li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由提交任务的线程直接处理该任务</li>
</ol>
<h2 id="如何向线程池提交任务">如何向线程池提交任务</h2>
<p><strong>有2种</strong>：分别使用execute 方法和 submit 方法</p>
<h2 id="执行execute-方法和submit-方法的区别是什么呢？">执行execute()方法和submit()方法的区别是什么呢？</h2>
<ol>
<li><strong>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以了解任务执行情况</strong>，并且可以通过 Future 的 get() 方法来获取返回值，还可以取消任务执行。底层也是通过 execute() 执行的。</li>
</ol>
<h2 id="线程池常用的阻塞队列？">线程池常用的阻塞队列？</h2>
<ul>
<li><strong>ArrayBlockingQueue</strong>：基于数组实现的一个单端阻塞队列，只能从队尾出队。</li>
<li><strong>LinkedBlockingQueue</strong>：基于链表实现的一个双端阻塞队列，分别从队头队尾操作入队出队。</li>
<li>PriorityBlockingQueue：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。</li>
<li>DelayQueue：基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li>
</ul>
<h2 id="怎么保证多线程的运行安全-保证线程安全的方法⭐">怎么保证多线程的运行安全/保证线程安全的方法⭐</h2>
<p>前提是保证下面三个方面：</p>
<p>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</p>
<p>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</p>
<p>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p>
<p><strong>可以使用 CAS、Synchronized、Lock、ThreadLocal 来实现。</strong></p>
<h2 id="如何尽可能提高多线程并发性能？">如何尽可能提高多线程并发性能？</h2>
<p>尽量减少临界区范围、使用ThreadLocal、减少线程切换、使用读写锁或CopyOnWrite机制</p>
<h2 id="为什么要使用线程池⭐">为什么要使用线程池⭐</h2>
<ol>
<li>减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下</li>
</ol>
<h2 id="线程池满了，往线程池里提交任务会发生什么样的情况，具体分几种情况">线程池满了，往线程池里提交任务会发生什么样的情况，具体分几种情况</h2>
<ul>
<li>如果你使用的<strong>LinkedBlockingQueue（阻塞队列）</strong>，也就是<strong>无界队列</strong>的话，没关系，<strong>继续添加任务</strong>到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个<strong>无穷大的队列，可以无限存放任务</strong>；如果你使用的是<strong>有界队列</strong>比方说<strong>ArrayBlockingQueue</strong>的话，任务首先会被添加到ArrayBlockingQueue中，<strong>ArrayBlockingQueue满了</strong>，则会使用<strong>拒绝策略RejectedExecutionHandler</strong>处理满了的任务，默认是<strong>AbortPolicy</strong>。</li>
<li>线程池的饱和策略：当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了<strong>4种策略</strong></li>
</ul>
<h2 id="向线程池提交一个线程的原理-步骤⭐">向线程池提交一个线程的原理/步骤⭐</h2>
<p>也叫做ThreadPoolexecutor工作流程</p>
<ul>
<li>先判断核心线程池是否已满
<ul>
<li>如果没有满就创建线程</li>
<li>如果满了就判断等待队列是否已满
<ul>
<li>如果没满就加入等待队列</li>
<li>如果满了就判断最大线程池是否已满
<ul>
<li>没有满就提交给线程池</li>
<li>满了就执行拒绝策略</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何指定多个线程的执行顺序-如何控制线程池线程的优先级-⭐">如何指定多个线程的执行顺序/ 如何控制线程池线程的优先级 ⭐</h3>
<ol>
<li>设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。</li>
<li>在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值，不是，则 wait，是则执行本线程。</li>
</ol>
<h3 id="线程池的线程数量怎么确定">线程池的线程数量怎么确定</h3>
<ol>
<li>一般来说，如果是CPU密集型应用，则线程池大小设置为N+1。</li>
<li>一般来说，如果是IO密集型应用，则线程池大小设置为2N+1。</li>
<li>在IO优化中，线程等待时间所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越少线程。这样的估算公式可能更适合：最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</li>
</ol>
<h2 id="常用的线程分析工具与方法">常用的线程分析工具与方法</h2>
<p>jstack 分析线程的运行状态，查看锁对象的持有状况。</p>
<p>jconsole：JDK自带的图形化界面工具</p>
<h2 id="volatile作用⭐">volatile作用⭐</h2>
<p>在多线程开发中保证了共享变量的“ 可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p>
<p><strong>volatile 告诉编译器它修饰的变量会不断的被修改，编译器就会通过强制主内存读写同步，防止指令重排序来保证原子性，可见性和有序性。但不能代替锁，不能保证i++这种复合操作的原子性。</strong></p>
<h2 id="Java-中是如何实现线程同步的？">Java 中是如何实现线程同步的？</h2>
<p>1.同步方法 synchronized 关键字修饰的方法（悲观锁）</p>
<p>2.使用特殊域变量(volatile)实现线程同步（保持可见性，多线程更新某一个值时，比如说线程安全单例双检查锁）</p>
<p>3.ThreadLocal（每个线程获取的都是该变量的副本）</p>
<p>4.使用重入锁实现线程同步（相对 synchronized 锁粒度更细了，效率高）</p>
<p>​    一个java.util.concurrent 包来支持同步。</p>
<p>​     ReentrantLock 类是可重入、互斥、实现了 Lock 接口的锁</p>
<p>​     ReentrantLock() : 创建一个 ReentrantLock 实例</p>
<p>​      lock() : 获得锁</p>
<p>​      unlock() : 释放锁</p>
<p>5.java.util.concurrent.atomic 包 （乐观锁）</p>
<p>​      方便程序员在多线程环境下，无锁的进行原子操作</p>
<p>​</p>
<h2 id="i-是线程安全的吗？">i++是线程安全的吗？</h2>
<p>分2种情况</p>
<ol>
<li>局部变量肯定是线程安全的（原因：方法内局部变量是线程私有的）</li>
<li>成员变量多个线程共享时，就不是线程安全的（原因：成员变量是线程共享的，因为 i++ 是三步操作。</li>
</ol>
<h2 id="介绍-Synchronized">介绍 Synchronized</h2>
<p>保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p><strong>三种使用方式：</strong></p>
<p>synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。</p>
<h2 id="Synchronized-的实现原理">Synchronized 的实现原理</h2>
<p>对象在内存中分为对象头，实例数据和对齐填充三个区域。在对象头中保存了锁标志位和指向 Monitor 对象的起始地址。当 Monitor 被某个线程占用后就会处于锁定状态。 <strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> synchronized 修饰的方法使用是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h3 id="JDK1-6-之后的synchronized-关键字底层做了一些优化">JDK1.6 之后的synchronized 关键字底层做了一些优化</h3>
<p>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化，详见 JVM 篇。</p>
<h2 id="Synchronized与Lock的区别⭐">Synchronized与Lock的区别⭐</h2>
<ul>
<li>synchronized是java内置关键字在jvm层面，Lock是个java类。</li>
<li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁，并且可以主动尝试去获取锁。</li>
<li>synchronized会自动释放锁，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁。</li>
<li>ReentrantLock更加灵活，提供了超时获取锁，可中断锁，在获取不到锁的情况会自己结束，而synchronized不可以</li>
<li>synchronized的锁不可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li>
</ul>
<h2 id="乐观锁和悲观锁的区别？">乐观锁和悲观锁的区别？</h2>
<h4 id="悲观锁">悲观锁</h4>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现</p>
<h4 id="乐观锁">乐观锁</h4>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong></p>
<h2 id="如何实现一个乐观锁？">如何实现一个乐观锁？</h2>
<p>在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<h2 id="ReentrantLock如何实现公平和非公平锁">ReentrantLock如何实现公平和非公平锁</h2>
<p>公平锁需要系统维护一个有序队列，获取锁时会判断阻塞队列里是否有线程再等待，若有获取锁就会失败，并且会加入阻塞队列。</p>
<p>非公平锁获取锁时不会判断阻塞队列是否有线程再等待，所以对于已经在等待的线程来说是不公平的，但如果是因为其它原因没有竞争到锁，它也会加入阻塞队列。</p>
<p>进入阻塞队列的线程，竞争锁时都是公平的，因为队列为先进先出（FIFO）。</p>
<h1>JUC工具类</h1>
<h2 id="Atomic类">Atomic类</h2>
<p>所谓原子类说简单点就是具有原子/原子操作特征的类。</p>
<h3 id="基本数据类型的原子类">基本数据类型的原子类</h3>
<ul>
<li>AtomicLong/AtomicInteger/AtomicBoolean：通过底层工具类 unsafe 类实现，基于 CAS。unsafe 类提供了类似 C 的指针操作，都是本地方法。</li>
<li>LongAdder/LongAccumulator：基于 Cell 实现，基于分段锁思想，是一种以空间换时间的策略，适合高并发场景。</li>
<li>AtomicReference：引用类型原子类，用于原子性对象的读写。</li>
<li>AtomicStampedReference/AtomicMarkableReference：解决 ABA 问题的类</li>
</ul>
<h3 id="Atomic类如何保证原子性⭐">Atomic类如何保证原子性⭐</h3>
<p>​      CAS，Compare and Swap即比较并交换。主要利用 CAS (compare and swap) + volatile 和 unsafe 类的 底层 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h2 id="CAS-可能会导致什么问题？">CAS 可能会导致什么问题？</h2>
<p>ABA问题，就是在写入时读取到的数据是和预期的一样的 A，但是这个 A 可能已经被其他线程修改成 B 再修改回来了。解决办法：增加额外的标志位或时间戳。</p>
<h1>AQS</h1>
<p>AQS的全称为（AbstractQueuedSynchronizer），在java.util.concurrent.locks包下面。</p>
<p><strong>AQS定义两种资源共享方式</strong></p>
<ul>
<li>
<p><strong>Exclusive</strong>（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p>
</li>
<li>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li>
<p><strong>Share</strong>（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p>
</li>
</ul>
<p><strong>异步工具类：</strong></p>
<p>Executors<br>
CompletableFuture：支持流式调用,多future组合,可以设置完成时间<br>
FutureTask<br>
ForkJoinPool ：分治思想+工作窃取</p>
<h3 id="ThreadLocal-实现原理">ThreadLocal 实现原理</h3>
<p>每个线程独享的局部变量，ThreadLocal使用弱引用 ThreadLocalMap 保存弱引用的局部变量。使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。</p>
<h2 id="ThreadLocal用来解决什么问题？">ThreadLocal用来解决什么问题？</h2>
<p>ThreadLocak不是用来解决多线程共享变量的问题，而是线程数据隔离的问题</p>
<!-- 文件: 并发基础.md -->
<h1>并发基础</h1>
<h2 id="JMM（Java-内存模型）">JMM（Java 内存模型）</h2>
<h3 id="原子性（Atomictiy）">原子性（Atomictiy）</h3>
<p>原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<h3 id="可见性（Visibility）">可见性（Visibility）</h3>
<p>可见性是指当一个线程修改了某一个共享变量的值时，其他线程能否立即知道这个修改。</p>
<p>缓存优化，硬件优化，指令重排，编辑器的优化。可能导致的可见性问题。</p>
<h3 id="有序性（Ordering）">有序性（Ordering）</h3>
<p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<h3 id="指令重排">指令重排</h3>
<p>在汇编语言层面，计算机使用流水线技术来执行命令，为了防止流水线中断，就需要使用指令重排。</p>
<h3 id="那些指令不能重排：Happen-Before-规则">那些指令不能重排：Happen-Before 规则</h3>
<ul>
<li>程序顺序原则：一个线程内保证语义的串行性。</li>
<li>volatile 规则：volatile 变量的写先于读发生，保证了这个变量的可见性。</li>
<li>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</li>
<li>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li>
<li>Thread 对象的结束先行发生于 join() 方法返回。</li>
<li>对线程 interrupt() 方法的调用先行发生于被中断线程的代码，因此可以通过 interrupted() 方法检测到是否有中断发生。</li>
<li>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</li>
</ul>
<h2 id="线程中断">线程中断</h2>
<p>线程中断是一种重要的线程协作机制。线程中断并不会使线程立即退出，而是给线程发送一个通知，告知线程需要退出了。至于目标线程接到通知后如何处理是由它自己决定。这也是和stop方法的根本区别。</p>
<p>有三个方法与线程中断有关：</p>
<ul>
<li>interrupt() // 通知目标线程中断，也就是设置中断标志位</li>
<li>isInterrupted() // 通过检查编中断标志位判断线程是否被中断</li>
<li>interrupted() // 静态方法，判断是否被中断并清楚当前中断状态</li>
</ul>
<h3 id="InterruptedException">InterruptedException</h3>
<p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="interrupted">interrupted()</h3>
<p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="等待（wait）和通知（notify）">等待（wait）和通知（notify）</h2>
<p>这两个方法是Object类中的，任何对象都可以调用这两个方法。</p>
<p>wait()方法只能在synchronized方法或synchronized块中使用（原因：wait方法会释放锁，只有在syn中才有锁）</p>
<p>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</p>
<p>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。</p>
<p><strong>锁池EntiyList</strong>：当一个线程需要调用调用此方法时必须获得该对象的锁，而该对象的锁被其他线程占用，该线程就需要在一个地方等待锁释放，这个地方就是锁池。（准备抢锁的池子）<br>
<strong>等待池WaitSet</strong>：调用了wait方法的线程会释放锁并进入等待池，在等待池的线程不会竞争锁。（休息的池子）</p>
<p>值得注意的是无论是wait方法还是notify方法都需要首先获得目标对象的一个监视锁（monitor lock），得到锁后才可以执行方法。</p>
<p>wait 和 sleep 的区别：</p>
<p>Thread.sleep只会让出CPU ,不会释放任何资源；<br>
Object.wait不仅让出CPU , 还会释放已经占有的同步资源锁。</p>
<h2 id="volatile">volatile</h2>
<p>JVM提供的轻量级同步机制<br>
含义：<br>
它是保证可见性的有效手段，还可以禁止指令重排序。但不能保证线程安全性<br>
原因：因为 Java 里面的运算并非是原子操作（处理器要么把这组操作全部执行完，中间不允许被其他操作所打断，要么这组操作不要执行。）<br>
如：int a = b + 1; 需要三步：取 a 的值，计算 a=b+1，然后把 a 的值写回内存<br>
但是！ 这三个操作处理器是不一定就会连续执行的，有可能执行了第一个操作之后，处理器就跑去执行别的操作了 。</p>
<p>当你使用 volatile 声明一个变量时就等于告诉虚拟机这个变量很有可能被修改，为了确保这个变量被修改后，所有线程都可以看到这个改动，虚拟机就必须采用一些措施保证这个变量的可见性。</p>
<p>volatile 关键字也可以保证数据的可见性和有序性。</p>
<h3 id="volatile的作用">volatile的作用</h3>
<p>对 long、double 提供原子性操作<br>
有序性：提供内存屏障，避免指令重排序<br>
保证可见性</p>
<h2 id="synchronized">synchronized</h2>
<p>synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次只有一个线程能进入同步块，从而保证线程间的安全性。</p>
<p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<h3 id="synchronized-的用法">synchronized 的用法</h3>
<ul>
<li>作用于对象：对给定的对象加锁，线程进入同步代码块之前要获得给定对象的锁。</li>
<li>作用于实例方法：相当于对当前实例加锁，线程进入同步代码前要获得当前实例的锁</li>
<li>作用于静态方法：相当于对当前类加锁，线程进入同步代码前要获得当前类的锁</li>
</ul>
<h3 id="synchronized-和-volatile-的区别是什么？">synchronized 和 volatile 的区别是什么？</h3>
<p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>
<p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</p>
<p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</p>
<p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p>
<p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>
<h1>JDK 并发包（JUC）</h1>
<h2 id="重入锁-ReentrantLock">重入锁 ReentrantLock</h2>
<p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。两者性能差距不大， 完全可以使用 ReentrantLock替代 synchronized。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 synchronized 相比，重入锁有着显式的操作过程，必须由开发人员指定何时加锁，何时释放。</p>
<p>对于一个线程来说，连续获得两次同一把锁是允许的，但要记得释放同样的次数。这也是为什么叫重入锁的原因。</p>
<h3 id="ReentrantLock的高级功能：">ReentrantLock的高级功能：</h3>
<p><strong>1.中断响应</strong></p>
<p>ReentrantLock 提供了在等待锁的过程中，取消对锁的请求的方法 lockInterruptibly() 方法。可以对线程中断进行响应的锁申请动作，即在等待锁的过程中可以响应线程的中断。</p>
<p><strong>2.锁申请等待限时</strong></p>
<p>ReentrantLock.tryLock()方法可以实现等待超时后自动放弃锁请求。</p>
<p><strong>3.公平锁</strong></p>
<p>在大多数情况下，锁的申请都是非公平的。儿而重入锁可以对公平性进行控制，从而避免了线程饥饿现象。然而公平锁需要系统维护一个有序队列，成本较高，性能低下，因此非必要情况不要使用公平锁。</p>
<h3 id="ReentrantLock-的实现，包含三要素：">ReentrantLock 的实现，包含三要素：</h3>
<ul>
<li>原子状态。原子状态使用 CAS 操作来存储当前锁的状态，判断锁是否被其他线程持有。</li>
<li>等待队列（等待池）。</li>
<li>阻塞原语 park(),unpark()，用来挂起和恢复线程。有关 park(),unpark() 的介绍，见下文线程阻塞工具类： LockSupport。</li>
</ul>
<h3 id="重入锁的搭档：Condition">重入锁的搭档：Condition</h3>
<p>ReentrantLock 和 Condition 的关系类似于synchronized 与 wait(),notify() 的关系。</p>
<p>Condition 接口提供基本方法如下：</p>
<ul>
<li>void await() throws InterruptedException; 类似 wait 方法。</li>
<li>void awaitUninterruptibly();  与 await() 方法基本相同。但不会在等待过程中响应线程中断。</li>
<li>void signal();  与 notify()  方法类似。</li>
</ul>
<h3 id="信号量（Semaphore）">信号量（Semaphore）</h3>
<p>无论是内部锁还是重入锁，一次都只允许一个线程访问一个资源，而信号量可以制定多个线程访问同一个资源。</p>
<h3 id="读写锁（ReadWriteLock）">读写锁（ReadWriteLock）</h3>
<p>ReadWriteLock是读写分离锁们可以有限帮助减少锁竞争，提升系统性能。</p>
<p>如果在系统中，读操作次数远远大于写操作，则可以使用读写锁。</p>
<h3 id="倒计数器（CountDownLatch）">倒计数器（CountDownLatch）</h3>
<p>这个工具常用来控制线程等待，可以让一个线程等待到倒计数结束再执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchDemo demo=<span class="keyword">new</span> <span class="title class_">CountDownLatchDemo</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟检查任务</span></span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>)*<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;check complete&quot;</span>);</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            exec.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待检查</span></span><br><span class="line">        end.await();</span><br><span class="line">        <span class="comment">//发射火箭</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Fire!&quot;</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>countDown 方法通知计数器一个线程已经完成，倒计数减一。主线程在CountDownLatch 上等待，所有检查任务完成后继续执行。</p>
<h3 id="循环栅栏（CyclicBarrier）">循环栅栏（CyclicBarrier）</h3>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环栅栏。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<h3 id="线程阻塞工具类（LockSupport）">线程阻塞工具类（LockSupport）</h3>
<p>LockSupport 可以在线程内任意位置让线程阻塞，与 suspend 方法相比，弥补了由于 resume 方法发生导致线程无法继续执行的情况，和 wait 方法相比，他不需要获得锁也不会抛出中断异常。</p>
<p>LockSupport 包含静态方法 park 可以阻塞当前线程，unpark 方法可以解开。</p>
<p>LockSupport 使用类似信号量的机制，为每个线程准备了一个许可，如果这个许可可用，park 方法会返回，并把这个许可变为不可用，如果许可不可用，就阻塞线程。unpark 则相反。这个机制使得即使 unpark 方法操作发生在 park 之前，也可以使下一次的 park方法操作立即返回。</p>
<h2 id="线程池">线程池</h2>
<h3 id="创建线程池的方式">创建线程池的方式</h3>
<p>①. newFixedThreadPool(int nThreads)<br>
创建一个固定线程数量的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，新的任务会暂存在任务队列中，待有线程空闲时便处理任务。</p>
<p>②. newCachedThreadPool()<br>
创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<p>③. newSingleThreadExecutor()<br>
这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>
<p>④. newScheduledThreadPool(int corePoolSize)（推荐）<br>
创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。他也有Single版本。</p>
<h3 id="线程池实现原理">线程池实现原理</h3>
<p><strong>FixedThreadPool</strong> ， <strong>SingleThreadExecutor</strong> ， <strong>CachedThreadPool</strong> 三个方法内部均使用了 ThreadPoolExecutor 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                            <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                            TimeUnit unit,</span></span><br><span class="line"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                            ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                            RejectedExecutionHandler handler)</span> </span><br></pre></td></tr></table></figure>
<p>参数含义如下：</p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 最大线程数量。</li>
<li><strong><code>workQueue</code>:</strong> 任务队列，当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :线程工厂，用于创建线程，一般用默认即可。</li>
<li><strong><code>handler</code></strong> :拒绝策略。当任务太多来不及处理时，如何拒绝任务。</li>
</ul>
<p>这里给出 ThreadPoolExecutor 的核心调度方法 execute() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    		<span class="comment">//保存的线程池当前的一些状态信息</span></span><br><span class="line">   		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">           <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">               <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               c = ctl.get();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">               <span class="comment">//如果再次检查线程池的状态不在运行，那就移除请求，然后采取拒绝策略</span></span><br><span class="line">               <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                   reject(command);</span><br><span class="line">                <span class="comment">// 如果线程池在运行，并且当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                   addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">    		<span class="comment">//如果不为空就直接添加执行</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">               reject(command);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果 workerCountOf© 函数取得的线程池的线程总数小于 corePoolSize 核心线程数时，将任务通过 addWorker(command, true) 直接调度执行。</li>
<li>否则，会在 workQueue.offer(command) 准备进入等待队列，如果进入成功就等待。</li>
<li>如果进入等待队列失败，就判断最大线程池是否满，如果没有就直接把任务提交给线程池，如果满了就执行拒绝策略。</li>
</ol>
<p>addWorker() 的第二个参数true表示核心线程数为限制，false 表示最大线程数为限制。</p>
<h3 id="拒绝策略">拒绝策略</h3>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 直接丢弃新进来无法处理的任务。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h3 id="ThreadFactory">ThreadFactory</h3>
<p>自定义线程创建，ThreadFactory 是一个接口，只有一个创建线程的方法，我们可以通过这个自定义线程池。</p>
<p>下面这个例子就是自定义线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>()&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">						Thread t= <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">						t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">						System.out.println(<span class="string">&quot;create &quot;</span>+t);</span><br><span class="line">						<span class="keyword">return</span> t;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">               );</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			es.submit(task);</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ForkJoin-框架">ForkJoin 框架</h3>
<p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p>
<p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。</p>
<h2 id="并发集合">并发集合</h2>
<p>JUC包中包含了并发集合类有：ConcurrentHashMap,CopyOnWriteArrayList,ConcurrentLinkedQueue,</p>
<p>BlockingQueue,ConcurrentSkipListMap.</p>
<h3 id="CAS（乐观锁）">CAS（乐观锁）</h3>
<p>CAS(Compare And Swap)，比较交换。与锁相比，使用 CAS 会使程序看起来更复杂一些，但天生避免死锁，线程间的互相影响也小于锁的方式，拥有比锁更好的性能。</p>
<p>CAS 的算法过程：它包含三个参数V,E,N，其中 V(value)表示要更新的变量，E(expect)表示预期值，N(new)表示新值。仅当 V 值 等于 E 时，才会将 V 设置成 N，如果V 和 E 不同，说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</p>
<p>CAS 是抱着乐观的态度进行的，他总认为自己可以完成操作，当多个线程同时使用 CAS 操作以操作一个变量时，只有一个会胜出，其余会失败。失败的线程不会被挂起，仅是被告知失败，允许再次尝试或者放弃操作。基于这样的原理，CAS 操作即使没有锁也可以发现各个线程之间的干扰，进行恰当的处理。</p>
<h3 id="高效读写的队列：ConcurrentLinkedQueue">高效读写的队列：ConcurrentLinkedQueue</h3>
<p>ConcurrentLinkedQueue 这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p>
<p>ConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。</p>
<p>ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。</p>
<h3 id="高效读取：CopyOnWriteArrayList">高效读取：CopyOnWriteArrayList</h3>
<p>读取完全不加锁，写入也不会阻塞读取，当写入时进行一次自我赋值进行操作，不修改原本的内容，详解请看 Java 容器分析。</p>
<h3 id="数据共享通道：BlockingQueue">数据共享通道：BlockingQueue</h3>
<p>Java 提供的线程安全的 Queue 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中阻塞队列的典型例子就是 BlockingQueue。</p>
<p>阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p>
<p>BlockingQueue是一个接口而不是一个具体实现，主要实现包括： ArrayBlockingQueue、LinkedBlockingQueue。</p>
<h2 id="锁优化">锁优化</h2>
<h3 id="提高锁性能的几点建议">提高锁性能的几点建议</h3>
<p>1.减少锁持有时间，只在必要的时候进行同步</p>
<p>2.减小锁粒度，就是缩小锁定对象的范围，降低锁冲突的可能性。</p>
<p>3.在读多写少的场合使用读写分离锁替换独占锁</p>
<p>4.锁分离</p>
<p>5.锁粗化， 如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。 锁粗化就是把加锁的范围扩展（粗化）到整个操作序列的外部。</p>
<h3 id="JVM对锁的优化">JVM对锁的优化</h3>
<p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p>
<h4 id="偏向锁">偏向锁</h4>
<p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。如果锁竞争比较大的情况就不要使用了。</p>
<h4 id="轻量级锁">轻量级锁</h4>
<p>如果偏向锁失败，虚拟机不会立即挂起线程，还会使用一种轻量级锁的优化手段， 轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<h4 id="自旋锁">自旋锁</h4>
<p>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<h4 id="锁消除">锁消除</h4>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<h3 id="ThreadLocal-（待办）">ThreadLocal （待办）</h3>
<h3 id="死锁">死锁</h3>
<p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p><strong>如何避免线程死锁?</strong></p>
<p><strong>破坏互斥条件</strong></p>
<p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
<p><strong>破坏请求与保持条件</strong></p>
<p>一次性申请所有的资源。</p>
<p><strong>破坏不剥夺条件</strong></p>
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<!-- 文件: 深入理解MySQL基础篇.md -->
<h1>MySQL体系结构与存储引擎</h1>
<h2 id="MySQL体系结构">MySQL体系结构</h2>
<p>先看 MySQL 数据库的体系结构，如下图所示。</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/MySQL%E6%9E%B6%E6%9E%84.png" style="zoom: 80%;" />
<p>MySQL体系结构由ClientConnectors层、MySQLServer层及存储引擎层组成。</p>
<p><strong>ClientConnectors层</strong></p>
<p>负责处理客户端的连接请求，与客户端创建连接。目前 MySQL 几乎支持所有的连接类型，例如常见的 JDBC、Python、Go 等。</p>
<p><strong>MySQL Server 层</strong></p>
<p>MySQLServer层主要包括ConnectionPool、Service&amp;utilities、SQLinterface、Parser解析器、Optimizer查询优化器、Caches缓存等模块。</p>
<ol>
<li>
<p>ConnectionPool，负责处理和存储数据库与客户端创建的连接，线程池资源管理，一个线程负责管理一个连接。还包括了用户认证模块，就是用户登录身份的认证和鉴权及安全管理，也就是用户执行操作权限校验。</p>
</li>
<li>
<p>Service &amp; utilities 是管理服务&amp;工具集，包括备份恢复、安全管理、集群管理服务和工具。</p>
</li>
<li>
<p>SQL interface，负责接收客户端发送的各种 SQL 语句，比如 DML、DDL 和存储过程等。</p>
</li>
<li>
<p>Parser 解析器会对 SQL 语句进行语法解析生成解析树。</p>
</li>
<li>
<p>Optimizer 查询优化器会根据解析树生成执行计划，并选择合适的索引，然后按照执行计划执行 SQL 语言并与各个存储引擎交互。</p>
</li>
<li>
<p>Caches缓存包括各个存储引擎的缓存部分，比如：InnoDB存储的BufferPool，Caches中也会缓存一些权限，也包括一些 Session 级别的缓存。</p>
</li>
</ol>
<p><strong>存储引擎层</strong></p>
<p>存储引擎包括MyISAM、InnoDB，以及支持归档的Archive和内存的Memory等。MySQL是插件式的存储引擎，只要正确定义与MySQLServer交互的接口，任何引擎都可以访问MySQL。</p>
<p><strong>物理存储层</strong></p>
<p>存储引擎底部是物理存储层，是文件的物理存储层，包括二进制日志、数据文件、错误日志、慢查询日志、全日志、redo/undo 日志等。</p>
<p>下面是一条SQL SELECT语句的执行过程：</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" style="zoom: 80%;" />
<h2 id="存储引擎-2">存储引擎</h2>
<p>存储引擎是 MySQL 中具体与文件打交道的子系统，它是根据 MySQL AB 公司提供的文件访问层的抽象接口，定制的一种文件访问机制，这种机制就叫作存储引擎。</p>
<p>InnoDB 存储引擎的具体架构如下图所示。上半部分是实例层（计算层），位于内存中，下半部分是物理层，位于文件系统中。</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/InnoDB%E6%9E%B6%E6%9E%84.png" style="zoom: 80%;" />
<h3 id="实例层">实例层</h3>
<p>实例层分为线程和内存。</p>
<p>InnoDB 重要的线程有 Master Thread，Master Thread 是 InnoDB 的主线程，负责调度其他各线程。</p>
<ul>
<li>
<p>MasterThread的优先级最高,其内部包含几个循环：主循环（loop）、后台循环（backgroundloop）、刷新循环（flushloop）、暂停循环（suspendloop）。Master Thread 会根据其内部运行的相关状态在各循环间进行切换。</p>
<p>大部分操作在主循环（loop）中完成，其包含 1s 和 10s 两种操作。</p>
</li>
<li>
<p>buf_dump_thread 负责将 buffer pool 中的内容 dump 到物理文件中，以便再次启动 MySQL 时，可以快速加热数据。</p>
</li>
<li>
<p>page_cleaner_thread负责将bufferpool中的脏页刷新到磁盘，在5.6版本之前没有这个线程，刷新操作都是由主线程完成的，所以在刷新脏页时会非常影响MySQL的处理能力，在5.7 版本之后可以通过参数设置开启多个 page_cleaner_thread。</p>
</li>
<li>
<p>purge_thread 负责将不再使用的 Undo 日志进行回收。</p>
</li>
<li>
<p>read_thread 处理用户的读请求，并负责将数据页从磁盘上读取出来，可以通过参数设置线程数量。</p>
</li>
<li>
<p>write_thread 负责将数据页从缓冲区写入磁盘，也可以通过参数设置线程数量，page_cleaner 线程发起刷脏页操作后 write_thread 就开始工作了。</p>
</li>
<li>
<p>redo_log_thread 负责把日志缓冲中的内容刷新到 Redo log 文件中。</p>
</li>
<li>
<p>insert_buffer_thread 负责把 Insert Buffer 中的内容刷新到磁盘。</p>
</li>
</ul>
<p>实例层的内存部分主要包含InnoDBBufferPool，这里包含InnoDB最重要的缓存内容。数据和索引页、undo页、insertbuffer页、自适应Hash索引页、数据字典页和锁信息等。additionalmemorypool后续已不再使用。Redobuffer里存储数据修改所产生的Redolog。doublewritebuffer是 double write 所需的 buffer，主要解决由于宕机引起的物理写入操作中断，数据页不完整的问题。</p>
<h3 id="物理层">物理层</h3>
<p>物理层在逻辑上分为系统表空间、用户表空间和 Redo日志。</p>
<p>系统表空间里有 ibdata 文件和一些 Undo，ibdata 文件里有 insert buffer 段、double write段、回滚段、索引段、数据字典段和 Undo 信息段。</p>
<p>用户表空间是指以 .ibd 为后缀的文件，文件中包含 insert buffer 的 bitmap 页、叶子页（这里存储真正的用户数据）、非叶子页。</p>
<p>Redo日志中包括多个Redo文件，这些文件循环使用，当达到一定存储阈值时会触发checkpoint刷脏页操作，同时也会在MySQL实例异常宕机后重启，InnoDB表数据自动还原恢复过程中使用。</p>
<h3 id="内存和物理结构">内存和物理结构</h3>
<p>内存和物理结构，如下图所示。</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84.png" style="zoom: 80%;" />
<p><strong>BufferPool</strong></p>
<p>用户读取或者写入的最新数据都存储在BufferPool中，如果BufferPool中没有找到则会读取物理文件进行查找，之后存储到BufferPool中并返回给MySQLServe。Buffer Pool 采用LRU 机制。</p>
<p>BufferPool决定了一个SQL执行的速度快慢，如果查询结果页都在内存中则返回结果速度很快，否则会产生物理读（磁盘读），返回结果时间变长。但我们又不能将所有数据页都存储到BufferPool中。在单机单实例情况下，我们可以配置BufferPool为物理内存的60%~80%，剩余内存用于session产生的sort和join等，以及运维管理使用。如果是单机多实例，所有实例的bufferpool总量也不要超过物理内存的80%。开始时我们可以根据经验设置一个BufferPool的经验值，比如16GB，之后业务在MySQL运行一段时间后可以根据show global status like’%buffer_pool_wait%’ 的值来看是否需要调整 Buffer Pool 的大小。</p>
<p><strong>Redolog</strong></p>
<p>Redolog是一个循环复用的文件集，<strong>负责记录InnoDB中所有对BufferPool的物理修改日志</strong>，当Redolog文件空间中，检查点位置的LSN和最新写入的LSN差值（checkpoint_age）达到Redolog文件总空间的75%后，InnoDB会进行异步刷新操作，直到降至75%以下，并释放Redolog的空间；当checkpoint_age达到文件总量大小的 90% 后，会触发同步刷新，此时 InnoDB 处于挂起状态无法操作。</p>
<p>补充：</p>
<ul>
<li>日志序号 (LSN:Log sequence number) 标识特定日志文件记录在日志文件中的位置。</li>
<li>checkpoint_age：检查点，将缓冲池中的脏页刷回到磁盘。当缓冲池不够用时，根据LRU算法溢出的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。</li>
</ul>
<p>每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。可以通过命令SHOW ENGINE INNODB STATUS来观察 。</p>
<p>这样我们就看到<strong>Redolog的大小直接影响了数据库的处理能力</strong>，如果设置太小会导致强行checkpoint操作频繁刷新脏页，那我们就需要将Redolog设置的大一些，5.6版本之前Redo log 设置的大一些，5.6 版本之前 Redo log 总大小不能超过 3.8GB，5.7 版本之后放开了这个限制。</p>
<p>事务提交时 log buffer 会刷新到 Redo log 文件中，具体刷新机制由参数控制。</p>
<h3 id="Myisam和InnoDB的区别">Myisam和InnoDB的区别</h3>
<ul>
<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁，而InnoDB 支持行级锁和表级锁,默认为行级锁，适合高并发操作。</li>
<li><strong>是否支持外键</strong>： MyISAM不支持，而InnoDB支持</li>
<li><strong>是否支持事务</strong>：MyISAM不支持，而InnoDB支持</li>
<li><strong>缓存</strong>：MyISAM只缓存索引，InnoDB缓存索引和真实数据，所以对内存要求高</li>
<li><strong>崩溃恢复</strong>：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>InnoDB 支持 MVCC，MyISAM 不支持；</li>
</ul>
<p>InnoDB 表最大还可以支持 64TB，支持聚簇索引、支持压缩数据存储，支持数据加密，支持查询/索引/数据高速缓存，支持自适应hash索引、空间索引，支持热备份和恢复等</p>
<h2 id="InnoDB-核心要点">InnoDB 核心要点</h2>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/InnoDB知识体系.png" style="zoom: 80%;" />
<p>ARIES 三原则</p>
<p>WriteAheadLogging（WAL）。</p>
<ul>
<li>先写日志后写磁盘，日志成功写入后事务就不会丢失，后续由checkpoint机制来保证磁盘物理文件与Redo日志达到一致性；</li>
<li>利用Redo 记录变更后的数据，即 Redo 记录事务数据变更后的值；</li>
<li>利用 Undo 记录变更前的数据，即 Undo 记录事务数据变更前的值，用于回滚和其他事务多版本读。</li>
</ul>
<p>show engine innodb status\G 的结果里面有详细的 InnoDB 运行态信息，分段记录的，包括内存、线程、信号、锁、事务。</p>
<h1>深入理解事务与锁机制</h1>
<h2 id="事务及其特性">事务及其特性</h2>
<p>一个逻辑工作单元要成为事务，在关系型数据库管理系统中，必须满足 4 个特性，即所谓的 ACID：原子性、一致性、隔离性和持久性。</p>
<p>Atomicity（原子性）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</p>
<p>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</p>
<p>Isolation（隔离性）：同一时间，只允许一个事务操作同一数据，不同的事务之间彼此没有任何干扰。</p>
<p>Durability（持久性）：事务处理结束后，对数据的修改是永久的。</p>
<h3 id="一致性">一致性</h3>
<p>一致性其实包括两部分内容，分别是约束一致性和数据一致性。</p>
<ul>
<li>约束一致性：数据库创建表结构时所制定的外键，唯一索引等约束。</li>
<li>数据一致性：是一个综合性的规定，或者说是一个把握全局的规定。因为它是由原子性、持久性、隔离性共同保证的结果，而不是单单依赖于某一种技术。</li>
</ul>
<h3 id="原子性">原子性</h3>
<p>原子性就是前面提到的两个“要么”，即要么改了，要么没改。也就是说用户感受不到一个正在改的状态。MySQL 是通过 WAL（Write Ahead Log）技术来实现这种效果的。</p>
<p>举例来讲，如果事务提交了，那改了的数据就生效了，如果此时BufferPool的脏页没有刷盘，如何来保证改了的数据生效呢？就需要使用Redo日志恢复出来的数据就需要使用Redo日志恢复出来的数据。而如果事务没有提交，且BufferPool的脏页被刷盘了，那这个本不应该存在的数据如何消失呢？就需要通过 Undo 来实现了，Undo 又是通过 Redo 来保证的，所以最终原子性的保证还是靠 Redo 的 WAL 机制实现的。</p>
<h3 id="持久性">持久性</h3>
<p>所谓持久性，就是指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，接下来的操作或故障不应该对其有任何影响。持久性是如何保证的呢？一旦事务提交，通过原子性，即便是遇到宕机，也可以从逻辑上将数据找回来后再次写入物理存储空间，这样就从逻辑和物理两个方面保证了数据不会丢失，即保证了数据不会丢失，即保证了数据库的持久性。</p>
<h3 id="隔离性">隔离性</h3>
<p>所谓隔离性，指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。锁和多版本控制就符合隔离性。</p>
<h2 id="并发事务控制">并发事务控制</h2>
<h3 id="单版本控制-锁">单版本控制-锁</h3>
<p>锁用独占的方式来保证在只有一个版本的情况下事务之间相互隔离，所以锁可以理解为单版本控制。在MySQL事务中，锁的实现与隔离级别有关系，在RR（RepeatableRead）隔离级别下，MySQL为了解决幻读的问题，以牺牲并行度为代价，通过Gap锁来防止数据的写入，而这种锁，因为其并行度不够，冲突很多，经常会引起死锁。现在流行的Row模式可以避免很多冲突甚至死锁问题，所以推荐默认使用 Row + RC（Read Committed）模式的隔离级别，可以很大程度上提高数据库的读写并行度。</p>
<p>补充： 在row level模式下，bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条被修改。</p>
<h3 id="多版本控制-MVCC">多版本控制-MVCC</h3>
<p>MVCC，是指在数据库中，为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。</p>
<p>那个多版本是如何生成的呢？每一次对数据库的修改，都会在Undo日志中记录当前修改记录的事务号及修改前数据状态的存储地址（即ROLL_PTR），以便在必要的时候可以回滚到老的数据版本。例如，一个读事务查询到当前记录，而最新的事务还未提交，根据原子性，读事务看不到最新数据，但可以去回滚段中找到老版本的数据，这样就生成了多个版本。多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。</p>
<h2 id="技术原理">技术原理</h2>
<h3 id="原子性技术原理">原子性技术原理</h3>
<p>每一个写事务，都会修改BufferPool，从而产生相应的Redo日志，这些日志信息会被记录到ib_logfiles文件中。因为Redo日志是遵循WriteAheadLog的方式写的，所以事务是顺序被记录的。在MySQL中，任何BufferPool中的页被刷到磁盘之前，都会先写入到日志文件中，这样做有两方面的保证。如果BufferPool中的这个页没有刷成功，此时数据库挂了，那在数据库再次启动之后，可以通过 Redo 日志将其恢复出来，以保证脏页写下去的数据不会丢失，所以必须要保证 Redo 先写。</p>
<p>为 Buffer Pool 的空间是有限的，要载入新页时，需要从 LRU 链表中淘汰一些页，而这些页必须要刷盘之后，才可以重新使用，那这时的刷盘，就需要保证对应的 LSN 的日志也要提前写到 ib_logfiles 中，如果没有写的话，恰巧这个事务又没有提交，数据库挂了，在数据库启动之后，这个事务就没法回滚了。所以如果不写日志的话，这些数据对应的回滚日志可能就不存在，导致未提交的事务回滚不了，从而不能保证原子性，所以原子性就是通过 WAL 来保证的。</p>
<h3 id="持久性技术原理">持久性技术原理</h3>
<p>通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持久性。这个过程与前面提到的Redo日志、事务状态、数据库恢复、参数innodb_flush_log_at_trx_commit 有关，还与 binlog 有关。</p>
<h3 id="隔离性技术原理">隔离性技术原理</h3>
<p>InnoDB 支持的隔离性有 4 种，隔离性从低到高分别为：读未提交、读提交、可重复读、可串行化。</p>
<p>具体说到隔离性的实现方式，我们通常用ReadView表示一个事务的可见性。RC级别的事务可见性比较高，它可以看到已提交的事务的所有修改。而RR级别的事务，则没有这个功能，一个读事务中，不管其他事务对这些数据做了什么修改，以及是否提交，只要自己不提交，查询的数据结果就不会变。</p>
<p>随着时间的推移，读提交每一条读操作语句都会获取一次 Read View，每次更新之后，都会获取数据库中最新的事务提交状态，也就可以看到最新提交的事务了，即每条语句执行都会更新其可见性视图。</p>
<p>而反观可重复读，这个可见性视图，只有在自己当前事务提交之后，才去更新，所以与其他事务是没有关系的。</p>
<p><strong>在 RR 级别下，长时间未提交的事务会影响数据库的 PURGE 操作，从而影响数据库的性能，所以可以对这样的事务添加一个监控</strong>。</p>
<h3 id="一致性技术原理">一致性技术原理</h3>
<p>数据的完整性是通过其他三个特性来保证的，为了保证数据的完整性，提出来三个特性，这三个特性又是由同一个技术来实现的，所以理解 Redo/Undo 才能理解数据库的本质。</p>
<h3 id="MVCC-实现原理">MVCC 实现原理</h3>
<p>MVCC最大的好处是读不加锁，读写不冲突。在读多写少的OLTP（On-LineTransactionProcessing）应用中，读写不冲突是非常重要的，极大的提高了系统的并发性能。</p>
<p>在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。</p>
<ul>
<li>快照读：读取的是记录的可见版本（有可能是历史版本），不用加锁。</li>
<li>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录。</li>
</ul>
<p>如何区分快照读和当前读呢？ 可以简单的理解为：</p>
<ul>
<li>快照读：简单的 select 操作，属于快照读，不需要加锁。</li>
<li>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</li>
</ul>
<p>下面用一个事务对某行记录更新的过程来说明MVCC中多版本的实现。</p>
<p>假设 F1～F6 是表中字段的名字，1～6 是其对应的数据。后面三个隐含字段分别对应该行的隐含ID、事务号和回滚指针，如下图所示。</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/MVCC%E5%AE%9E%E7%8E%B0.png" alt="image-20200412113401177" style="zoom:80%;" />
<ul>
<li>隐含ID（DB_ROW_ID），6个字节，当由InnoDB自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值。</li>
<li>事务号（DB_TRX_ID），6个字节，标记了最新更新这条行记录的TransactionID，每处理一个事务，其值自动+1。</li>
<li>回滚指针（DB_ROLL_PT），7个字节，指向当前记录项的RollbackSegment的Undolog记录，通过这个指针才能查找之前版本的数据。</li>
</ul>
<p>首先，假如这条数据是刚 INSERT 的，可以认为 ID 为 1，其他两个字段为空。</p>
<p>然后，当事务 1 更改该行的数据值时，会进行如下操作，如下图所示。</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/MVCC%E5%AE%9E%E7%8E%B02.png" style="zoom:80%;" />
<ul>
<li>用排他锁锁定该行；记录 Redo log</li>
<li>把该行修改前的值复制到 Undo log，即图中下面的行</li>
<li>修改当前行的值，填写事务编号，使回滚指针指向 Undo log 中修改前的行</li>
</ul>
<p>如果数据继续执行，此时Undolog中有两行记录，并且通过回滚指针连在一起。因此，如果Undolog一直不删除，则会通过当前记录的回滚指针回溯到该行创建时的初始内容，所幸的是在InnoDB中存在purge 线程，它会查询那些比现在最老的活动事务还早的 Undo log，并删除它们，从而保证 Undo log 文件不会无限增长，如下图所示。</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/MVCC3.png" style="zoom:80%;" />
<h2 id="并发事务问题及解决方案">并发事务问题及解决方案</h2>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据数据发生了变化。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<p>产生的这些问题，MySQL 数据库是通过事务隔离级别来解决的。值得一提的是，InnoDB通过Gap锁解决了幻读的问题。</p>
<p>不可重复读重点在于 UPDATA 和 DELETE，而幻读的重点在于 INSERT。它们之间最大的区别是如何通过锁机制来解决它们产生的问题。</p>
<h2 id="InnoDB-的锁">InnoDB 的锁</h2>
<p>InnoDB 的锁分为行锁和表锁。</p>
<p>其中行锁包括两种：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。表锁又分为三种。</p>
<ul>
<li>意向共享锁（IS）：事务计划给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的的 IX 锁。</li>
<li>自增锁（AUTO-INC Locks）：特殊表锁，自增长计数器通过该“锁”来获得子增长计数器最大的计数值。</li>
</ul>
<p>在加行锁之前必须先获得表级意向锁，否则等待 innodb_lock_wait_timeout 超时后根据innodb_rollback_on_timeout 决定是否回滚事务。</p>
<h3 id="InnoDB自增锁">InnoDB自增锁</h3>
<p>在MySQLInnoDB存储引擎中，我们在设计表结构的时候，通常会建议添加一列作为自增主键。这里就会涉及一个特殊的锁：自增锁（即：AUTO-INCLocks），它属于表锁的一种，在 INSERT 结束后立即释放。我们可以执行 <strong>show engine innodb status\G</strong> 来查看自增锁的状态信息。</p>
<p>InnoDB 锁关系矩阵如下图，其中：+ 表示兼容，- 表示不兼容。</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/InnoDB%20%E9%94%81%E5%85%B3%E7%B3%BB%E7%9F%A9%E9%98%B5.png"  style="zoom:80%;" />
<h3 id="InnoDB-行锁">InnoDB 行锁</h3>
<p>InnoDB 行锁是通过对索引数据页上的记录（record）加锁实现的。主要实现算法有 3 种：Record Lock、Gap Lock 和 Next-key Lock。</p>
<ul>
<li>RecordLock锁：单个行记录的锁（锁数据，不锁Gap）。</li>
<li>GapLock锁：间隙锁，锁定一个范围，不包括记录本身（不锁数据，仅仅锁数据前面的Gap）。</li>
<li>Next-keyLock 锁：同时锁住数据，并且锁住数据前面的 Gap。</li>
</ul>
<p><strong>排查 InnoDB 锁问题</strong></p>
<p>排查InnoDB锁问题通常有2种方法。打开innodb_lock_monitor表，注意使用后记得关闭，否则会影响性能。在MySQL5.5版本之后，可以通过查看information_schema 库下面的 innodb_locks、innodb_lock_waits、innodb_trx 三个视图排查 InnoDB 的锁问题。</p>
<h3 id="InnoDB死锁">InnoDB死锁</h3>
<p>在MySQL中死锁不会发生在MyISAM存储引擎中，但会发生在InnoDB存储引擎中，因为InnoDB是逐行加锁的，极容易产生死锁。那么死锁产生的四个条件是什么呢？</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用；</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>不剥夺条件：进程已获得的资源，在没使用完之前，不能强行剥夺；</li>
<li>循环等待条件：多个进程之间形成的一种互相循环等待资源的关系。</li>
</ul>
<p>在发生死锁时，InnoDB存储引擎会自动检测，并且会自动回滚代价较小的事务来解决死锁问题。但很多时候一旦发生死锁，InnoDB存储引擎的处理的效率是很低下的或者有时候根本解决不了问题，需要人为手动去解决。</p>
<p>既然死锁问题会导致严重的后果，那么在开发或者使用数据库的过程中，如何避免死锁的产生呢？这里给出一些建议：</p>
<ul>
<li>加锁顺序一致；</li>
<li>尽量基于primary或uniquekey更新数据。</li>
<li>单次操作数据量不宜过多，涉及表尽量少。</li>
<li>减少表上索引，减少锁定资源。</li>
<li>相关工具：pt-deadlock-logger</li>
</ul>
<p>查看MySQL数据库中死锁的相关信息，可以执行showengineinnodbstatus\G来进行查看，重点关注“LATESTDETECTEDDEADLOCK”部分。</p>
<p>一些开发建议来避免线上业务因死锁造成的不必要的影响。</p>
<ul>
<li>更新SQL的where条件时尽量用索引；</li>
<li>加锁索引准确，缩小锁定范围；</li>
<li>减少范围更新，尤其非主键/非唯一索引上的范围更新。</li>
<li>控制事务大小，减少锁定数据量和锁定时间长度 （innodb_row_lock_time_avg）。</li>
<li>加锁顺序一致，尽可能一次性锁定所有所需的数据行。</li>
</ul>
<!-- 文件: 计算机网络面试题.md -->
<h2 id="TCP-IP四层网络模型⭐">TCP/IP四层网络模型⭐</h2>
<p><strong>第一层 网络接口层</strong></p>
<p>网络接口层包括用于协作IP数据在已有网络介质上传输的协议。</p>
<p>协议：ARP,RARP<br>
<strong>第二层 网间层</strong></p>
<p>网间层对应于OSI七层参考模型的网络层。负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。</p>
<p>协议：本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，ICMP协议。<br>
<strong>第三层 传输层</strong></p>
<p>传输层对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。</p>
<p>其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。<br>
<strong>第四层 应用层</strong></p>
<p>应用层对应于OSI七层参考模型的应用层和表达层。</p>
<p>因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等。</p>
<h2 id="OSI七层网络模型⭐">OSI七层网络模型⭐</h2>
<p><strong>第一层 物理层</strong></p>
<p>作用：负责最后将信息编码成电流脉冲或其它信号用于网上传输。它由计算机和网络介质之间的实际界面组成，可定义电气信号、符号、线的状态和时钟要求、数据编码和数据传输用的连接器。所有比物理层高的层都通过事先定义好的接口而与它通话。</p>
<p>协议：如最常用的RS-232规范、10BASE-T的曼彻斯特编码以及RJ-45就属于第一层。<br>
<strong>第二层 数据链路层</strong></p>
<p>作用：数据链路层通过物理网络链路提供可靠的数据传输。</p>
<p>协议：ATM，FDDI等。<br>
<strong>第三层 网络层</strong></p>
<p>作用：这层对端到端的包传输进行定义，他定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。</p>
<p>协议：IP,IPX等<br>
<strong>第四层 传输层</strong></p>
<p>作用：传输层向高层提供可靠的端到端的网络数据流服务。传输层的功能一般包括流控、多路传输、虚电路管理及差错校验和恢复。流控管理设备之间的数据传输，确保传输设备不发送比接收设备处理能力大的数据；多路传输使得多个应用程序的数据可以传输到一个物理链路上；虚电路由传输层建立、维护和终止；差错校验包括为检测传输错误而建立的各种不同结构；而差错恢复包括所采取的行动（如请求数据重发），以便解决发生的任何错误。</p>
<p>协议：TCP，UDP，SPX。<br>
<strong>第五层 会话层</strong></p>
<p>作用：会话层建立、管理和终止表示层与实体之间的通信会话。通信会话包括发生在不同网络应用层之间的服务请求和服务应答，这些请求与应答通过会话层的协议实现。它还包括创建检查点，使通信发生中断的时候可以返回到以前的一个状态。</p>
<p>协议：RPC，SQL等<br>
<strong>第六层 表示层</strong></p>
<p>作用：这一层的主要功能是定义数据格式及加密。</p>
<p>协议：FTP,加密<br>
<strong>第七层 应用层</strong></p>
<p>作用：应用层是最接近终端用户的OSI层，这就意味着OSI应用层与用户之间是通过应用软件直接相互作用的。应用层的功能一般包括标识通信伙伴、定义资源的可用性和同步通信。<br>
协议：telnet，HTTP,FTP,WWW,NFS,SMTP等。</p>
<h2 id="简述-TCP-和-UDP-的区别⭐">简述 TCP 和 UDP 的区别⭐</h2>
<ul>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>
</ul>
<h3 id="TCP-特点⭐">TCP 特点⭐</h3>
<ul>
<li>基于链接，点对点传输，在传输数据前要先建立好连接，再进行传输。</li>
<li>一旦建立连接就可以是双向通信</li>
<li>传输是基于字节流而不是报文，将数据根据大小进行变好，接收端通过 ack 大小进行编号，从而保证接收数据的有序性和完整性。</li>
<li>TCP 还可提供流量控制能力，通过滑动窗口来控制数据的发送速率，滑动窗口的本质就是动态缓冲区</li>
<li>通过慢启动，拥塞避免，拥塞发生，快速恢复四个算法实现了拥塞控制</li>
</ul>
<p><strong>选择</strong></p>
<p>什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输。什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP。</p>
<h2 id="TCP-三次握手和四次挥手-重点-⭐">TCP 三次握手和四次挥手(重点)⭐</h2>
<p>先介绍各单词的含义：</p>
<p>1为有效，0为无效</p>
<ul>
<li>URG：紧急指针标志</li>
<li><strong>ACK：确认序号标志</strong></li>
<li>PSH：push标志</li>
<li>RST：重置连接标志</li>
<li>SYN （Synchronize Sequence Numbers） ：同步序列号，用于建立连接过程</li>
<li>FIN：finish标志，用于释放链接</li>
</ul>
<p>握手是为了建立连接，流程如下图 ：</p>
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/3次握手.png"/> </div><br>
<p>seq：为自己的标记缓存的初始序号<br>
ack：确认号</p>
<p><strong>第一次握手</strong>：<br>
一开始都是close状态，客户端主动打开，服务端进入listen监听状态，等待请求，客户端发出连接请求报文（SYN包），报文头为SYN,seq为任意正整数x，此时进入同步发送状态（SYN_SEND），等待服务器确认。<br>
<strong>第二次握手：</strong><br>
如果服务端同意接收信息，会发出确认报文（SYN+ACK包 ），报文头seq为另外一个正整数y，ack为x+1，服务端进入同步收到的状态（SYN_RCVD）；<br>
前两步都不携带数据，都需要消耗一个序列号。<br>
<strong>第三次握手：</strong><br>
客户端接收到确认报文（SYN+ACK包 ），进入ESTABLISHED状态，还要向服务端给出确认，发出确认报文（ACK包 ack=y+1 ），两端都进入ESTABLISHED状态，完成三次握手。<br>
<strong>此后，双方就建立了链接，可以开始通信了。</strong></p>
<h2 id="为什么需要三次握手-⭐">为什么需要三次握手?⭐</h2>
<p>简单说就是： 为了双方确认自己与对方的发送与接收是正常的。两次握手的话至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认，不能建立起双向通信。</p>
<p><strong>为了初始化Sequence Number 的初始值</strong>： 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p>
<h2 id="首次握手的隐患–SYN超时">首次握手的隐患–SYN超时</h2>
<p><strong>原因：</strong><br>
Server收到Client的SYN ,回复SYN- ACK的时候未收到ACK确认，导致 Server 一直在 SYN_RCVD 状态，<br>
Server不断重试直至超时, 影响正常数据发送，但 Linux 默认等待63秒才断开连接<br>
所以黑客可能利用这个漏洞进行恶意攻击。</p>
<p><strong>防护措施：</strong><br>
SYN队列满后,通过tcp_ syncookies参数回发SYN Cookie<br>
若为正常连接则客户端会回发 SYN Cookie 告诉服务端已经接收到请稍等,直接建立连接。</p>
<h2 id="建立连接后，Client出现故障怎么办">建立连接后，Client出现故障怎么办</h2>
<p>保活机制<br>
一直发送探测报文，直到达到设定次数还无响应就中断连接</p>
<h2 id="TCP四次挥手（重点）⭐">TCP四次挥手（重点）⭐</h2>
<p>目的：为了中止连接</p>
<p>流程图：</p>
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/4%E6%AC%A1%E6%8C%A5%E6%89%8B.png"/> </div><br>
<p><strong>第一次挥手：</strong><br>
最开始两方都处于ESTABLISHED状态，客户端主动关闭，发出连接释放报文（FIN）并且停止发送数据，报文头：FIN和seq =u（等于前面已经传送过来的数据的最后一个字节的序号加1），然后进入<strong>FINWAIT1</strong>状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>
<strong>第二次挥手：</strong><br>
服务器收到报文，发出确认报文（ACK，ack=u+1，序列号seq=v），进入<strong>CLOSEWAIT</strong>状态。<br>
CLOSEWAIT状态：半关闭状态，服务器端不接收数据但可能还要发送数据。<br>
<strong>第三次挥手：</strong><br>
客户端收到报文进入<strong>FINWAIT2</strong>状态，等待服务器发送第三次挥手，这段时间可以接收数据。服务端数据发送完后，会发送释放报文（FIN），但服务器很可能又发送了一些数据，序列号会变化，假定此时的序列号为seq=w ，此时进入<strong>LASTACK</strong>状态。<br>
<strong>第四次挥手：</strong><br>
客户端收到报文后必须发送确认报文（ACK，ack=w+1，seq=u+1），进入<strong>TIMEWAIT</strong>，但连接没有释放，等待2MSL（2倍最大报文段寿命）来保证连接的可靠关闭才进入<strong>CLOSED</strong>状态。服务端收到确认直接进入<strong>CLOSED</strong>状态。</p>
<p><strong>为什么什么有TIME_WAIT状态</strong></p>
<ul>
<li>保证全双工链接可靠关闭</li>
<li>保证重复的数据段消失，方式端口被重用时产生数据混淆</li>
</ul>
<h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手⭐">为什么连接的时候是三次握手，关闭的时候却是四次握手⭐</h3>
<p>因为在连接时当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，因为可能还有数据需要传输回去，并不能立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了，但我还有一些数据没有发完”。只有等到我Server端所有的报文都发送完了，才会发送FIN报文，因此不能一起发送。所以需要四步握手。</p>
<p>tip: 全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输</p>
<h4 id="服务器出现大量CLOSE-WAIT状态的原因">服务器出现大量CLOSE_ WAIT状态的原因</h4>
<p>被动关闭的一方可能存在代码问题没有正确关闭链接导致的</p>
<p>对方关闭socket连接,我方忙于读或写,没有及时关闭连接<br>
<strong>解决：</strong><br>
检查代码,特别是释放资源的代码<br>
检查配置,特别是处理请求的线程配置</p>
<h2 id="UDP的特点">UDP的特点</h2>
<p>面向非连接<br>
不维护连接状态,支持同时向多个客户端传输相同的消息<br>
数据包报头只有8个字节,额外开销较小<br>
吞吐量只受限于数据生成速率、传输速率以及机器性能<br>
尽最大努力交付,不保证可靠交付,不需要维持复杂的链接状态表<br>
面向报文,不对应用程序提交的报文信息进行拆分或者合并</p>
<h2 id="在浏览器中输入url地址-显示主页的过程⭐">在浏览器中输入url地址 -&gt;&gt; 显示主页的过程⭐</h2>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析，查询服务器缓存，解析url，找到服务器的IP地址</li>
<li>TCP连接， 三次握手</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束，四次挥手</li>
</ol>
<h2 id="HTTP状态码⭐">HTTP状态码⭐</h2>
<p>1xx :指示信息–表示请求已接收,继续处理<br>
2xx :成功–表示请求已被成功接收、理解、接受<br>
3xx :重定向–要完成请求必须进行更进一步的操作<br>
4xx :<strong>客户端错误</strong>–请求有语法错误或请求无法实现<br>
5xx :<strong>服务器端错误</strong>–服务器未能实现合法的请求</p>
<h2 id="get-和-post-请求有哪些区别？-⭐"><strong>get 和 post 请求有哪些区别？</strong> ⭐</h2>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<h2 id="Cookie-，Session区别⭐">Cookie ，Session区别⭐</h2>
<p>Cookie数据存放在客户的浏览器上, Session数据放在服务器上<br>
Session相对于Cookie更安全<br>
若考虑减轻服务器负担,应当使用Cookie</p>
<h2 id="HTTPS">HTTPS</h2>
<p>S:Security<br>
https增加了一个SSL层</p>
<p>SSL(Security Sockets Layer ,安全套接层)<br>
为网络通信提供安全及数据完整性的一-种安全协议<br>
是操作系统对外的API , SSL3.0后更名为TLS<br>
采用身份验证和数据加密保证网络通信的安全和数据的完整性</p>
<h4 id="HTTP和HTTPS的区别">HTTP和HTTPS的区别</h4>
<p>HTTPS需要到CA申请证书, HTTP不需要</p>
<p>HTTPS密文传输, HTTP明文传输</p>
<p>连接方式不同, HTTPS默认使用443端口, HTTP使用80端口</p>
<p>HTTPS=HTTP+加密+认证+完整性保护,较HTTP安全</p>
<h2 id="Socket">Socket</h2>
<p>Socket是对TCP/IP协议的抽象,是操作系统对外开放的接口</p>
<!-- 文件: 设计模式.md -->
<p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p>
<ol>
<li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li>
<li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li>
<li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li>
</ol>
<p><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong></p>
<p><strong>每个代理模式的代码都必须自己手动完成一遍。</strong></p>
<h2 id="创建型模式">创建型模式</h2>
<p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p>
<p>工厂模式分为简单工厂模式，工厂模式，抽象工厂模式</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<strong>本质就是使用工厂方法代替new操作。</strong></p>
<h3 id="简单工厂模式">简单工厂模式</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;兰州拉面&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">noodle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanZhouNoodle</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;兰州拉面&quot;</span>+noodle+<span class="string">&quot;出锅啦&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;黄焖鸡&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuangMenChicken</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;黄焖鸡&quot;</span>+ chicken +<span class="string">&quot;出锅啦&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不知道你做的什么哦~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> FoodFactory.makeFood(<span class="string">&quot;黄焖鸡&quot;</span>);</span><br><span class="line">        FoodFactory.makeFood(<span class="string">&quot;jaja&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单地说，<strong>简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</strong></p>
<blockquote>
<p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p>
</blockquote>
<p>在此例中可以看出，Cook 类在使用 FoodFactory 时就不需要 new 任何一个对象，这就是简单工厂模式的好处，封装了 new 的部分，做到的代码易用性。</p>
<h3 id="工厂模式">工厂模式</h3>
<p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeFood</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p>
<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        <span class="type">FoodFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodFactory</span>();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p>
<p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p>
<p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p>
<h3 id="抽象工厂模式">抽象工厂模式</h3>
<p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。 一个经典的例子是造一台电脑 。</p>
<p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p>
<p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p>
<h3 id="单例模式">单例模式</h3>
<p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p>
<p>getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。</p>
<p><strong>特点</strong></p>
<ul>
<li>类构造器私有</li>
<li>持有自己类型的属性</li>
<li>对外提供获取实例的静态方法</li>
</ul>
<p><strong>饿汉式写法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> instance;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>弊端：因为类加载的时候就会创建对象，所以有的时候还不需要使用对象，就会创建对象，造成内存的浪费；</p>
<p><strong>饱汉模式最容易出错：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双重检查，指的是两次检查 instance 是否为 null。</p>
<p>volatile 在这里是需要的，希望能引起读者的关注。</p>
<p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p>
</blockquote>
<p>嵌套类最经典，以后大家就用它吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p>
</blockquote>
<p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>
<p><strong>TODO:</strong></p>
<p>建造者模式</p>
<p>原型模式</p>
<h2 id="结构型模式">结构型模式</h2>
<p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p>
<h3 id="代理模式">代理模式</h3>
<p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p>
<p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p>
<p>理解<strong>代理</strong>这个词，这个模式其实就简单了。 下面上代码理解。<br>
代理接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要有一个代理接口让实现类和代理实现类来实现。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeChicken</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被代理的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>();</span><br><span class="line">        f.setChicken(<span class="string">&quot;1kg&quot;</span>);</span><br><span class="line">        f.setSpicy(<span class="string">&quot;1g&quot;</span>);</span><br><span class="line">        f.setSalt(<span class="string">&quot;3g&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;鸡肉加好佐料了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>被代理实现类就只需要做自己该做的事情就好了，不需要管别的。</p>
<p>代理实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始制作鸡肉&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeChicken();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;鸡肉制作完成啦，加点胡椒粉&quot;</span>);</span><br><span class="line">        food.addCondiment(<span class="string">&quot;pepper&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;上锅咯&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户端调用，注意，我们要用代理来实例化接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line"><span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceProxy</span>();</span><br><span class="line">foodService.makeChicken();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所谓代理模式，<strong>就是对被代理方法包装或者叫增强， 在面向切面编程（AOP）中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</strong></p>
<p>待续。。。</p>
<h2 id="行为型模式">行为型模式</h2>
<h3 id="模板模式">模板模式</h3>
<p>在含有继承结构的代码中，模板方法模式是非常常用的。</p>
<p><strong>父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现</strong></p>
<p>模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p>
<p>好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好</p>
<p>缺点：   每一个不同的实现都需要一个子类来实现，导致类个数增加，使系统更加庞大</p>
<p><strong>模板模式的关键点：</strong></p>
<p>1、使用抽象类定义模板类，并在其中定义所有的基本方法、模板方法，钩子方法，不限数量，以实现功能逻辑为主。其中基本方法使用final修饰，其中要调用基本方法和钩子方法，基本方法和钩子方法可以使用protected修饰，表明可被子类修改。</p>
<p>2、定义实现抽象类的子类，重写其中的模板方法，甚至钩子方法，完善具体的逻辑。</p>
<p>使用场景：</p>
<p>1、在多个子类中拥有相同的方法，而且逻辑相同时，可以将这些方法抽出来放到一个模板抽象类中。</p>
<p>2、程序主框架相同，细节不同的情况下，也可以使用模板方法。</p>
<h4 id="架构方法介绍">架构方法介绍</h4>
<p>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。其主要分为两大类：模版方法和基本方法，而基本方法又分为：抽象方法（Abstract Method），具体方法（Concrete Method），钩子方法（Hook Method）。</p>
<p>四种方法的基本定义（前提：在抽象类中定义）：</p>
<p>（1）抽象方法：由抽象类声明，由具体子类实现，并以abstract关键字进行标识。</p>
<p>（2）具体方法：由抽象类声明并且实现，子类并不实现或者做覆盖操作。其实质就是普遍适用的方法，不需要子类来实现。</p>
<p>（3）钩子方法：由抽象类声明并且实现，子类也可以选择加以扩展。通常抽象类会给出一个空的钩子方法，也就是没有实现的扩展。<strong>它和具体方法在代码上没有区别，不过是一种意识的区别</strong>；而它和抽象方法有时候也是没有区别的，就是在子类都需要将其实现的时候。而不同的是抽象方法必须实现，而钩子方法可以不实现。也就是说钩子方法为你在实现某一个抽象类的时候提供了可选项，<strong>相当于预先提供了一个默认配置。</strong></p>
<p>（4）模板方法：定义了一个方法，其中定义了整个逻辑的基本骨架。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//这是具体方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 抽象层已经实现，子类也可以选择覆写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是抽象方法，留给子类实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//这是钩子方法，可定义一个默认操作，或者为空</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<!-- 文件: 集合框架面试知识点.md -->
<h1>集合框架面试题和解析</h1>
<p><strong>为什么要设计出迭代器</strong></p>
<p>迭代器本质是一种设计模式，为了解决为不同的集合类提供统一的遍历操作接口。</p>
<h2 id="List、Set、Map-之间的区别">List、Set、Map 之间的区别</h2>
<p><strong>List</strong></p>
<p>1.可以允许重复的对象。<br>
2.可以插入多个null元素。<br>
3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。<br>
4.常用的实现类有 ArrayList、LinkedList 和 Vector。</p>
<p><strong>Set：</strong></p>
<p>1.不允许重复对象<br>
2.无序容器，无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。<br>
3.只允许一个 null 元素<br>
4.Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p>
<p><strong>Map：</strong></p>
<p>1.Map不是collection的子接口或者实现类。Map是一个接口。<br>
2.Map 的 每个 Entry 都持有两个对象，也就是一个键一个值（键值对），Map 可能会持有相同的值对象但键对象必须是唯一的。<br>
3.TreeMap 也通过 Comparator 或者 Comparable 维护了一个排序顺序。<br>
4.Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。<br>
5.Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）</p>
<h2 id="Arraylist-与-LinkedList-的区别">Arraylist 与 LinkedList 的区别</h2>
<p><strong>1. 底层数据结构：</strong> <code>Arraylist</code> 底层使用的是  动态数组 ；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p>
<p><strong>2.插入删除数据方式：</strong> ArrayList插入删除元素时分两种情况：①把元素添加到末尾所需的时间复杂度是O(1)，②在指定位置添加删除元素时就需要移动整个数组，操作代价就比较大了；LinkedList 对于添加删除方法只需要断链然后更改指向，所需的消耗就很小了。</p>
<p><strong>3.是否支持快速随机访问：</strong> ArrayList 支持高效的随机元素访问而LinkedList 不支持。</p>
<p><strong>4. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h2 id="ArrayList-和-Vector-的区别">ArrayList 和 Vector 的区别</h2>
<p><code>Vector</code>类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。Vector一次扩容为原来的2倍。</p>
<p><code>Arraylist</code>不是同步的，所以在不需要保证线程安全时建议使用Arraylist，需要时使用 CopyOnWriteArrayList 。Arraylist一次扩容为1.5倍。</p>
<h2 id="ArrayList-的扩容机制？">ArrayList 的扩容机制？</h2>
<p><strong>前提：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。</strong></p>
<p>流程：</p>
<p>当我们要 add 进第1个元素到 ArrayList 时，数组长度为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以更改了 minCapacity，此时为10（默认最小容量）。此时，就会执行grow 方法把容量扩大为10，然后一直add到第11个元素时，会对旧数组<strong>位移运算</strong>得到新数组，然后把旧数组整个复制到新数组上，是旧容量的 1.5 倍。</p>
<h2 id="如何实现数组和-List-之间的转换？">如何实现数组和 List 之间的转换？</h2>
<ul>
<li>List转换成为数组：调用ArrayList的toArray方法。</li>
<li>数组转换成为List：调用Arrays的asList方法。</li>
</ul>
<h2 id="Array-和-ArrayList-有何区别？">Array 和 ArrayList 有何区别？</h2>
<ul>
<li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li>
<li>Array是指定大小的，而ArrayList大小是固定的。</li>
<li>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</li>
</ul>
<h2 id="HashMap-和-Hashtable-的区别">HashMap 和 Hashtable 的区别</h2>
<ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果保证线程安全的话使用 ConcurrentHashMap ）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小；</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h2 id="说说-HashMap">说说 HashMap</h2>
<p>1.内部存储结构：数组+链表+红黑树（JDK8）</p>
<p>2.默认容量16（数组长度），默认装载因子0.75。</p>
<p>3.key 和 value 对数据类型的要求都是泛型。</p>
<p>4.key 可以为 null，放在 table[0] 中。</p>
<p>5.hashcode：计算键的hashcode作为存储键信息的数组下标用于查找键对象的存储位置。equals：HashMap 使用 equals() 判断当前的键是否与表中存在的键相同。</p>
<h2 id="HashMap-的结构">HashMap 的结构</h2>
<p>在 JDK 1.7 中 HashMap 是以数组加链表的形式组成的，JDK 1.8 之后新增了红黑树的组成结构，当链表大于 8 并且容量大于 64 时，链表结构会转换成红黑树结构，添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p>
<h2 id="HashMap-的长度为什么是2的幂次方">HashMap 的长度为什么是2的幂次方</h2>
<p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&amp;(length-1)，</p>
<p><strong>hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；</strong></p>
<h2 id="什么是-HashMap-的加载因子？加载因子为什么是-0-75？">什么是 HashMap 的加载因子？加载因子为什么是 0.75？</h2>
<p>判断什么时候进行扩容的，假如加载因子是 0.5，HashMap 的初始化容量是 16，那么当 HashMap 中有 16*0.5=8 个元素时，HashMap 就会进行扩容。</p>
<p>这其实是出于容量和性能之间平衡的结果：</p>
<ul>
<li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li>
<li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，多次扩容也会影响性能。</li>
<li>HashMap的容量有一个固定的要求就是一定是2的幂次方。所以，如果负载因子是3/4的话，那么和capacity的乘积结果就可以是一个整数。</li>
</ul>
<p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p>
<h2 id="put-方法流程">put 方法流程</h2>
<p>map.put(“a”,“b”)的整个流程：</p>
<pre><code>  	1. 先判断散列表是否没有初始化或者为空，如果是就扩容
            	2. 根据键值 key 计算 hash 值，得到要插入的数组索引 
         	3. 判断要插入的那个数组是否为空：
                           	1. 如果为空直接插入。
                           	2. 如果不为空，判断 key 的值是否是重复（用 equals 方法）：
                   	1. 如果是就直接覆盖
                   	2. 如果不重复就再判断此节点是否已经是红黑树节点：
                   	1. 如果是红黑树节点就把新增节点放入树中
                             	2. 如果不是，就开始遍历链表：
                                 1. 循环判断直到链表最底部，到达底部就插入节点，然后判断是否大于链表长度是否大于8：
                                    1. 如果大于8就转换为红黑树
                                    2. 如果不大于8就继续下一步
                                       2. 到底部之前发现有重复的值，就覆盖。
       	4. 判断是否需要扩容，如果需要就扩容。
</code></pre>
<h2 id="HashMap-的扩容机制">HashMap 的扩容机制</h2>
<p>扩容时机：当<code>size</code>大于<code>threshold</code>的时候，并不一定会触发扩容机制，只要有一个新建的节点出现哈希冲突，则立刻<code>resize</code>。</p>
<ul>
<li>size记录的是map中包含的Entry的数量</li>
<li>而threshold记录的是需要resize的阈值 且 <code>threshold = loadFactor * capacity</code></li>
<li>capacity 其实就是桶的长度</li>
</ul>
<p>步骤：</p>
<ul>
<li>数组，阈值都扩大一倍</li>
<li>如果旧数组不为空，开始遍历旧数组</li>
<li>遍历到的数组上只有一个元素，就直接迁移</li>
<li>如果是红黑树就使用 split 方法</li>
<li>如果是链表就把链表拆成两个，按照高位运算的结果放到新数组中并且保留顺序</li>
</ul>
<h4 id="JDK-1-8-在扩容方面对-HashMap-做了哪些优化？">JDK 1.8 在扩容方面对 HashMap 做了哪些优化？</h4>
<p>1.7创建一个容量的新数组，重新计算每个元素在数组中的位置并且进行迁移。</p>
<p>1.8中在扩容HashMap的时候，不需要像1.7中去重新计算元素的hash，只需要看看原来的hash值新增的哪个二进制数是1还是0就好了，如果是0的话表示索引没有变，是1的话表示索引变成“oldCap+原索引”，这样即省去了重新计算hash值的时间，并且扩容后链表元素位置不会倒置。</p>
<h2 id="HashMap-1-7和1-8版本区别">HashMap 1.7和1.8版本区别</h2>
<ul>
<li>**数据结构：**1.7：数组+链表，1.8：数组+链表+红黑树</li>
<li>**新节点插入方式：**1.7：头插法 ，1.8：直接在尾部插入</li>
<li>**扰动运算次数：**1.7：运算多，1.8：运算少</li>
<li>**插入和扩容的判断：**1.7：先扩容后插入，1.8：先插入后扩容
<ul>
<li>为什么？1.8增加了判断是否为红黑树节点，先扩容的话不知道到底扩链表节点还是红黑树。</li>
</ul>
</li>
</ul>
<h2 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？">HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2>
<p><code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，  而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，  HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
<p><strong>怎么解决呢？</strong></p>
<p>1.HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</p>
<p>2.保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储。</p>
<p><strong>那为什么是两次扰动呢？</strong></p>
<p>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p>
<h2 id="HashMap1-7为什么不安全？⭐">HashMap1.7为什么不安全？⭐</h2>
<p>HashMap在rehash的时候，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他put操作，如果hash值相同，把值插入同一个链表，会因为头插法的特性造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p>
<h4 id="高并发下HashMap1-7的环是如何产生的">高并发下HashMap1.7的环是如何产生的</h4>
<p>若当前线程一此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，在tranfer方法中会把next指向自己造成闭环，然后在get时会出现死循环。</p>
<h2 id="为什么HashMap中String、Integer这样的包装类适合作为Key？⭐">为什么HashMap中String、Integer这样的包装类适合作为Key？⭐</h2>
<p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<ol>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范，不容易出现Hash值计算错误的情况。</li>
</ol>
<p><strong>如果我想要让自己的Object作为K应该怎么办呢？</strong></p>
<p>重写<code>hashCode()</code>和<code>equals()</code>方法 。 <strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>， <strong>重写<code>equals()</code>方法</strong> <strong>目的是为了保证key在哈希表中的唯一性</strong>；</p>
<h2 id="ConcurrentHashMap线程安全的实现方式-数据结构⭐">ConcurrentHashMap线程安全的实现方式/数据结构⭐</h2>
<p>在JDK1.7版本中，ConcurrentHashMap维护了一个Segment数组，Segment这个类继承了重入锁ReentrantLock，在该类里面维护了一个 HashEntry&lt;K,V&gt;[] table数组，在写操作put，remove，扩容的时候，会对Segment加锁，所以仅仅影响这个Segment，不同的Segment还是可以并发的，所以解决了线程的安全问题，同时又采用了分段锁也提升了并发的效率。在JDK1.8版本中，ConcurrentHashMap摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap。</p>
<p>详见java容器总结篇。</p>
<h2 id="BlockingQueue是什么？">BlockingQueue是什么？</h2>
<p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
<h2 id="在-Queue-中-poll-和-remove-有什么区别？">在 Queue 中 poll()和 remove()有什么区别？</h2>
<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<!-- 文件: 项目常用工具.md -->
<h2 id="整体介绍">整体介绍</h2>
<p><strong>团队协作</strong></p>
<ul>
<li>Ant：较少使用</li>
<li>Maven</li>
<li>Gradle</li>
<li>Git</li>
<li>SVN：较少使用</li>
</ul>
<p><strong>质量保证</strong></p>
<ul>
<li>Checkstyle</li>
<li>FindBugs：代码检测工具</li>
<li>SonarQube：平台，集成了上面两种工具</li>
</ul>
<p><strong>压测</strong></p>
<ul>
<li>JMeter</li>
<li>JMH</li>
<li>AB</li>
<li>LoadRunner</li>
</ul>
<p><strong>容器与代理（随着微服务的盛行，Envoy、OpenResty、Kong等API网关的使用也越来越普遍）</strong></p>
<ul>
<li>Tomcat</li>
<li>Jetty</li>
<li>Nginx</li>
<li>Envoy</li>
<li>OpenResty</li>
<li>Kong</li>
</ul>
<p><strong>CI/CD</strong></p>
<ul>
<li>Gitlab-CI</li>
<li>Jenkins</li>
<li>Travis</li>
</ul>
<p><strong>JVM相关</strong></p>
<ul>
<li>JMC（JFR）</li>
<li>jstack、jmap、jstat</li>
</ul>
<p><strong>系统分析</strong></p>
<ul>
<li>vmstat</li>
<li>iostat &amp; iotop</li>
<li>ifstat &amp; iftop</li>
<li>netstat</li>
<li>dstat</li>
<li>strace</li>
<li>GDB</li>
<li>lsof</li>
<li>tcpdump</li>
<li>traceroute</li>
</ul>
<p><strong>文档管理</strong></p>
<ul>
<li>JavaDoc</li>
<li>Swagger</li>
</ul>
<p><strong>网络工具</strong></p>
<ul>
<li>PostMan</li>
<li>WireShark（网络包分析工具）</li>
<li>Fiddler（只针对HTTP进行抓捕）</li>
<li>Charies</li>
</ul>
<h2 id="JVM相关工具">JVM相关工具</h2>
<h3 id="JMC（Java-Mission-Control）">JMC（Java Mission Control）</h3>
<p>1.7之后提供的 JVM 图形化监控工具，包括 JVM 浏览器，飞行控制器 JFR（Java Filght Recorder），JMX（Java Management Extensions）控制台。</p>
<p>jps：查看java进程信息<br>
jmap：查看JVM中对象的统计信息，<strong>可以在内存溢出时查看堆中最大的对象类型</strong><br>
jstat：对JVM的资源和性能进行实时监控<br>
jstack：查看JVM线程栈信息，<strong>可以检查线程死锁问题</strong><br>
jinfo：动态查看、调整jvm参数<br>
jcmd：1.7提供的综合工具，使用飞行计数器分析性能。</p>
<h2 id="Git">Git</h2>
<h2 id="git命令"><img src="C:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CDesktop%5Cgithub%E7%AC%94%E8%AE%B0%5Cgit%E5%91%BD%E4%BB%A4.png" alt="git命令"></h2>
<p>分布式管理，有四个保存数据区域，如图中的工作区，暂存区，本地仓库，远程仓库。</p>
<p>开发时线程远程仓库拉取代码到工作区，可以使用clone，pull，fetch，checkout。pull=fetch+merge</p>
<p>提交代码时先使用add，再commit，再push。</p>
<h3 id="Git-工作流">Git 工作流</h3>
<p><img src="C:%5CUsers%5C%E5%90%95%E6%98%8E%E8%BE%89%5CDesktop%5Cgithub%E7%AC%94%E8%AE%B0%5Cgit%E5%B7%A5%E4%BD%9C%E6%B5%81.png" alt="git工作流"></p>
<p>github 工作流：master 分支的代码一直是可发布状态，需要新开发就直接开一个feature分支，完成后pullrequest（PR），当Review通过后，合并到mater分支。</p>
<h2 id="Linux-分析工具">Linux 分析工具</h2>
<ul>
<li><strong>vmstat</strong>：进程、虚拟内存、页面交换、IO读写、CPU活动等</li>
<li>iostat &amp; iotop：系统IO状态信息</li>
<li>ifstat &amp; iftop：实时网络流量监控</li>
<li><strong>netstat</strong>：查看网络相关信息,各种网络协议套接字状态</li>
<li>dstat：全能型实时系统信息统计</li>
<li>strace：诊断、调试程序的系统调用</li>
<li>GDB：程序调试、coredump分析</li>
<li>Isof：查看系统当前打开的文件信息</li>
<li>tcpdump：网络抓包工具</li>
<li>traceroute：网络路由分析工具</li>
</ul>
<!-- 文件: 高性能实践篇.md -->
<h1>高性能库表设计</h1>
<h3 id="范式和反范式">范式和反范式</h3>
<h4 id="范式">范式</h4>
<p>范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。数据库的设计范式是数据库设计所需要满足的规范。只有理解数据库的设计范式，才能设计出高效率、优雅的数据库，否则可能会设计出低效的库表结构。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，还又称完美范式。</p>
<p>满足最低要求的叫第一范式，简称1NF。在第一范式基础上进一步满足一些要求的为第二范式，简称2NF。其余依此类推。各种范式呈递次规范，越高的范式数据库冗余越小。通常所用到的只是前三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）。</p>
<p><strong>第一范式</strong></p>
<p>第一范式无重复的列，表中的每一列都是拆分的基本数据项，即列不能够再拆分成其他几列，强调的是列的原子性。</p>
<p>如果在实际场景中，一个联系人有家庭电话和公司电话，那么以“姓名、性别、电话”为表头的表结构就没有达到1NF。要符合1NF我们只需把电话列拆分，让表头变为姓名、性别、家庭电话、公司电话即可。</p>
<p><strong>第二范式</strong></p>
<p>属性完全依赖于主键，首先要满足它符合1NF，另外还需要包含两部分内容：</p>
<ul>
<li>表必须有一个主键；</li>
<li>没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。即要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>
</ul>
<p><strong>第三范式</strong></p>
<p>第三范式属性不传递依赖于其他非主属性，首先需要满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p>
<p><strong>第二范式和第三范式的区别第二范式：</strong></p>
<ul>
<li>非主键列是否依赖主键（包括一列通过某一列间接依赖主键），要是有依赖关系就是第二范式；</li>
<li>第三范式：非主键列是否直接依赖主键，不能是那种通过传递关系的依赖。要是符合这种依赖关系就是第三范式。通过对前三个范式的了解，我们知道 3NF 是 2NF 的子集，2NF 是 1NF 的子集。</li>
</ul>
<p><strong>范式优缺点</strong></p>
<p>优点：</p>
<ul>
<li>避免数据冗余，减少维护数据完整性的麻烦；</li>
<li>减少数据库的空间；</li>
<li>数据变更速度快。</li>
</ul>
<p>缺点：</p>
<ul>
<li>按照范式的规范设计的表，等级越高的范式设计出来的表数量越多。</li>
<li>获取数据时，表关联过多，性能较差。</li>
</ul>
<p>表的数量越多，查询所需要的时间越多。也就是说所用的范式越高，对数据操作的性能越低。</p>
<h4 id="反范式">反范式</h4>
<p>范式是普适的规则，满足大多数的业务场景的需求。对于一些特殊的业务场景，范式设计的表，无法满足性能的需求。此时，就需要根据业务场景，在范式的基础之上进行灵活设计，也就是反范式设计。</p>
<p>反范式设计主要从三方面考虑：</p>
<p><strong>业务场景，相应时间，字段冗余。</strong></p>
<p>反范式设计就是用空间来换取时间，提高业务场景的响应时间，减少多表关联。主要的优点如下：</p>
<p>允许适当的数据冗余，业务场景中需要的数据几乎都可以在一张表上显示，避免关联；</p>
<p>可以设计有效的索引。</p>
<h4 id="范式与反范式异同">范式与反范式异同</h4>
<p><strong>范式化模型</strong>：数据没有冗余，更新容易；当表的数量比较多，查询数据需要多表关联时，会导致查询性能低下。</p>
<p><strong>反范式化模型</strong>：冗余将带来很好的读取性能，因为不需要join很多很多表；虽然需要维护冗余数据，但是对磁盘空间的消耗是可以接受的。</p>
<h2 id="MySQL-使用原则和设计规范">MySQL 使用原则和设计规范</h2>
<h3 id="概述">概述</h3>
<p>MySQL虽然具有很多特性并提供了很多功能，但是有些特性会严重影响它的性能，比如，在数据库里进行计算，写大事务、大SQL、存储大字段等。想要发挥MySQL的最佳性能，需要遵循3个基本使用原则。</p>
<ul>
<li>首先是需要让MySQL回归存储的基本职能：MySQL数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离；</li>
<li>其次是查询数据时，尽量单表查询，减少跨库查询和多表关联；</li>
<li>还有就是要杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手。</li>
</ul>
<p>补充：</p>
<p>大事务，运行步骤较多，涉及的表和字段较多，容易造成资源的争抢，甚至形成死锁。一旦事务回滚，会导致资源占用时间过长。</p>
<p>大SQL，复杂的SQL意味着过多的表的关联，MySQL数据库处理关联超过3张表以上的SQL时，占用资源多，性能低下。</p>
<p>大批量，意味着多条SQL一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行。大字段，blob、text等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新。</p>
<p>下面具体讲解数据库的基本设置规则：</p>
<ol>
<li>必须指定默认存储引擎为InnoDB，并且禁用MyISAM存储引擎，随着MySQL8.0版本的发布，所有的数据字典表都已经转换成了InnoDB，MyISAM存储引擎已成为了历史。</li>
<li>默认字符集UTF8mb4，以前版本的UTF8是UTF8mb3，未包含个别特殊字符，新版本的UTF8mb4包含所有字符，官方强烈建议使用此字符集。</li>
<li>关闭区分大小写功能。设置lower_case_tables_name=1，即可关闭区分大小写功能，即大写字母 T 和小写字母 t 一样。</li>
</ol>
<p>MySQL数据库提供的功能很全面，但并不是所有的功能性能都高效。</p>
<ol>
<li>存储过程、触发器、视图、event。为了存储计算分离，这类功能尽量在程序中实现。这些功能非常不完整，调试、排错、监控都非常困难，相关数据字典也不完善，存在潜在的风险。一般在生产数据库中，禁止使用。</li>
<li>lob、text、enum、set。这些字段类型，在MySQL数据库的检索性能不高，很难使用索引进行优化。如果必须使用这些功能，一般采取特殊的结构设计，或者与程序结合使用其他的字段类型替代。比如：set 可以使用整型（0，1，2，3）、注释功能和程序的检查功能集合替代。</li>
</ol>
<h3 id="规范命名">规范命名</h3>
<p>统一的规范命名，可以增加可读性，减少隐式转换。</p>
<p>命名时的字符取值范围为：a~z，0~9 和 _（下画线）。</p>
<ol>
<li>
<p>所有表名小写，不允许驼峰式命名；</p>
</li>
<li>
<p>允许使用 -（横线）和 （空格）；如下图所示，当使用 -（横线），后台默认会转化成 @002d；</p>
</li>
<li>
<p>不允许使用其他特殊字符作为名称，减少潜在风险。</p>
</li>
</ol>
<p>数据库库名的命名规则必须遵循“见名知意”的原则，即库名规则为“数据库类型代码 + 项目简称 + 识别代码 + 序号”。</p>
<p><strong>表名的命名规则分为：</strong></p>
<p>单表仅使用 a~z、_；</p>
<p>分表名称为“表名_编号”；</p>
<p>业务表名代表用途、内容：子系统简称_业务含义_后缀。</p>
<p>常见业务表类型有：临时表，tmp；备份表，bak；字典表，dic；日志表，log。</p>
<p><strong>字段名精确</strong>，遵循“见名知意”的原则，格式：名称_后缀。</p>
<ul>
<li>避免普遍简单、有歧义的名称。用户表中，用户名的字段为 UserName 比 Name 更好。</li>
<li>布尔型的字段，以助动词（has/is）开头。用户是否有留言 hasmessage，用户是否通过检查 ischecked 等。</li>
</ul>
<p><strong>索引命名格式</strong>，主要为了区分哪些对象是索引：</p>
<p>前缀_表名（或缩写）_字段名（或缩写）；主键必须使用前缀“pk_”；UNIQUE约束必须使用前缀“uk_”；普通索引必须使用前缀“idx_”。</p>
<h3 id="表创建的注意事项">表创建的注意事项</h3>
<ol>
<li>主键列，UNSIGNED整数，使用auto_increment；禁止手动更新auto_increment，可以删除。</li>
<li>必须添加comment注释。</li>
<li>必须显示指定的engine。</li>
<li>表必备三字段：id、xxx_create、xxx_modified。
<ul>
<li>id为主键，类型为unsignedbigint等数字类型；</li>
<li>xxx_create、xxx_modified的类型均为 datetime 类型，分别记录该条数据的创建时间、修改时间。</li>
</ul>
</li>
</ol>
<h4 id="备份表-临时表等常见表的设计规范">备份表/临时表等常见表的设计规范</h4>
<ol>
<li>备份表，表名必须添加bak和日期，主要用于系统版本上线时，存储原始数据，上线完成后，必须及时删除。</li>
<li>临时表，用于存储中间业务数据，定期优化，及时降低表碎片。</li>
<li>日志类表，首先考虑不入库，保存成文件，其次如果入库，明确其生命周期，保留业务需求的数据，定期清理。</li>
<li>大字段表，把主键字段和大字段，单独拆分成表，并且保持与主表主键同步，尽量减少大字段的检索和更新。</li>
<li>大表，根据业务需求，从垂直和水平两个维度进行拆分。</li>
</ol>
<h3 id="字段设计要求">字段设计要求</h3>
<ol>
<li>根据业务场景需求，选择合适的类型，最短的长度；确保字段的宽度足够用，但也不要过宽。所有字段必须为NOTNULL，空值则指定default值，空值难以优化，查询效率低。比如：人的年龄用unsignedtinyint（范围0~255，人的寿命不会超过255岁）；海龟就必须是smallint，但如果是太阳的年龄，就必须是int；如果是所有恒星的年龄都加起来，那么就必须使用bigint。</li>
<li>表字段数少而精，尽量不加冗余列。</li>
<li>单实例表个数必须控制在 2000 个以内。</li>
<li>单表分表个数必须控制在 1024 个以内。</li>
<li>单表字段数上限控制在 20~50 个。</li>
</ol>
<p>**禁用ENUM、SET类型。**兼容性不好，性能差。</p>
<p>解决方案：使用TINYINT，在COMMENT信息中标明被枚举的含义。`is_disable` TINYINT UNSIGNED DEFAULT’0’COMMENT '0:启用1:禁用2:异常’。</p>
<p>**禁用列为NULL。**MySQL难以优化NULL列；NULL列加索引，需要额外空间；含NULL复合索引无效。</p>
<p>解决方案：在列上添加 NOT NULL DEFAULT 缺省值。</p>
<p>**禁止 VARBINARY、BLOB 存储图片、文件等。**禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统中，数据库中存储路径。</p>
<p>不建议使用TEXT/BLOB：处理性能差；行长度变长；全表扫描代价大。</p>
<p>解决方案：拆分成单独的表。</p>
<p>存储字节越小，占用空间越小。尽量选择合适的整型，如下图所示。</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/各字节类型占用的空间.png" style="zoom: 80%;" />
建议：
<ul>
<li>主键列，无负数，建议使用INTUNSIGNED或者BIGINTUNSIGNED；预估字段数字取值会超过42亿，使用BIGINT类型。</li>
<li>短数据使用TINYINT或SMALLINT，比如：人类年龄，城市代码。</li>
<li>使用 UNSIGNED 存储非负数值，扩大正数的范围。</li>
</ul>
<p>推荐字符集都为 UTF8mb4，中文存储占三个字节，而数据或字母，则只占一个字节。</p>
<p>CHAR(N) 和 VARCHAR(N) 的长度 N，不是字节数，是<strong>字符数</strong>。</p>
<p>例：username VARCHAR(40)：username 最多能存储 40 个字符，占用 120 个字节。</p>
<p><strong>Char 与 Varchar 类型</strong></p>
<p>存储字符串长度相同的全部使用 Char 类型；字符长度不相同的使用 Varchar 类型，不预先分配存储空间，长度不要超过 255。</p>
<h2 id="案例处理">案例处理</h2>
<h3 id="IP处理">IP处理</h3>
<p>一般使用Char(15)进行存储，但是当进行查找和统计时，字符类型不是很高效。MySQL数据库内置了两个IP相关的函数INET_ATON()、INET_NTOA()，可以以实现 IP 地址和整数的项目转换。</p>
<p>因此，我们使用 INT UNSIGNED（占用 4 个字节）存储 IP。</p>
<p>将 IP 的存储从字符型转换成整形，转化后数字是连续的，提高了查询性能，使查询更快，占用空间更小。</p>
<h3 id="TIMESTAMP处理">TIMESTAMP处理</h3>
<p>同样的方法，我们使用MySQL内置的函数(FROM_UNIXTIME()，UNIX_TIMESTAMP())，可以将日期转化为数字，用INTUNSIGNED存储日期和时间。</p>
<h1>高性能索引设计</h1>
<h2 id="索引概述">索引概述</h2>
<p>数据库索引是一种数据结构，它以额外的写入和存储空间为代价来提高数据库表上数据检索操作的速度。通俗来说，索引类似于书的目录，根据其中记录的页码可以快速找到所需的内容。</p>
<p>MySQL官方对索引（Index）的定义是存储引擎用于快速查找记录的一种数据结构。</p>
<ul>
<li>索引是物理数据页，数据库页大小（PageSize）决定了一个页可以存储多少个索引行，以及需要多少页来存储指定大小的索引。</li>
<li>索引可以加快检索速度，但同时也降低索引列插入、删除、更新的速度，索引维护需要代价。</li>
</ul>
<h2 id="索引原理">索引原理</h2>
<p>二分查找是索引实现的理论基础。在数据库中大部分索引都是通过 B+Tree 来实现的。当然也涉及其他数据结构，在 MySQL 中除了 B+Tree 索引外我们还需要关注下 Hash 索引。</p>
<h3 id="Hash-索引">Hash 索引</h3>
<p>哈希表是数据库中哈希索引的基础，是根据键值&lt;key,value&gt;存储数据的结构。简单说，哈希表是使用哈希函数将索引列计算到桶或槽的数组，实际存储是根据哈希函数将key换算成确定的存储位置，并将 value 存放到该数组位置上。访问时，只需要输入待查找的 key，即可通过哈希函数计算得出确定的存储位置并读取数据。</p>
<h4 id="Hash-索引的实现">Hash 索引的实现</h4>
<p>数据库中哈希索引是基于哈希表实现的，对于哈希索引列的数据通过Hash算法计算，得到对应索引列的哈希码形成哈希表，由哈希码及哈希码指向的真实数据行的指针组成了哈希索引。哈希索引的应用场景是只在对哈希索引列的等值查询才有效。</p>
<p>因为哈希索引只存储哈希值和行指针，不存储实际字段值，所以其结构紧凑，查询速度也非常快，在无哈希冲突的场景下访问哈希索引一次即可命中。但是哈希索引只适用于等值查询，包括=、IN()、&lt;=&gt;（安全等于，selectnull&lt;=&gt;null和selectnull=null是不一样的结果)，不支持范围查询。</p>
<h4 id="Hash碰撞的处理">Hash碰撞的处理</h4>
<p>Hash碰撞是指不同索引列值计算出相同的哈希码，表中字段为A和B两个不同值根据Hash算法计算出来的哈希码都一样就是出现了哈希碰撞。对于 Hash 碰撞通用的处理方法是使用链表，将 Hash 冲突碰撞的元素形成一个链表，发生冲突时在链表上进行二次遍历找到数据。</p>
<h4 id="MySQL-中如何使用-Hash-索引？">MySQL 中如何使用 Hash 索引？</h4>
<p>在 MySQL 中主要是分为 Memory 存储引擎原生支持的 Hash 索引 、InnoDB 自适应哈希索引及 NDB 集群的哈希索引3类。</p>
<p>InnoDB自适应哈希索引是为了提升查询效率，InnoDB存储引擎会监控表上各个索引页的查询，当InnoDB注意到某些索引值访问非常频繁时，会在内存中基于B+Tree索引再创建一个哈希索引，使得内存中的 B+Tree 索引具备哈希索引的功能，即能够快速定值访问频繁访问的索引页。</p>
<p>为什么要为B+Tree索引页二次创建自适应哈希索引呢？这是因为B+Tree索引的查询效率取决于B+Tree的高度，在数据库系统中通常B+Tree的高度为3～4层，所以访问数据需要做 3～4 次的查询。而 Hash 索引访问通常一次查找就能定位数据（无 Hash 碰撞的情况），其等值查询场景 Hash 索引的查询效率要优于 B+Tree。</p>
<p>自适应哈希索引的建立使得InnoDB存储引擎能自动根据索引页访问的频率和模式自动地为某些热点页建立哈希索引来加速访问。另外InnoDB自适应哈希索引的功能，用户只能选择开启或关闭功能，无法进行人工干涉。功能开启后可以通过 Show Engine Innodb Status 看到当前自适应哈希索引的使用情况。</p>
<h3 id="B-Tree-索引">B+Tree 索引</h3>
<p>如下图所示为一个简单的、标准的 B+tree，每个节点有 K 个键值和 K+1 个指针。</p>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/B+树.png" style="zoom: 80%;" />
B+Tree索引能够快速访问数据，就是因为存储引擎可以不再需要通过全表扫描来获取数据，而是从索引的根结点（通常在内存中）开始进行二分查找，根节点的槽中都存放了指向子节点的指针，存储引擎根据这些指针能快速遍历数据。
<p>叶子节点存放的 &lt;key+data&gt; ，对于真正要存放哪些数据还得取决于该 B+Tree 是聚簇索引（Clustered Index）还是辅助索引（Secondary Index）。</p>
<h4 id="聚簇索引和辅助索引">聚簇索引和辅助索引</h4>
<p>聚簇索引是一种数据存储方式，它表示表中的数据按照主键顺序存储，是索引组织表。InnoDB的聚簇索引就是按照主键顺序构建B+Tree，B+Tree的叶子节点就是行记录，数据行和主键值紧凑地存储在一起。这也意味着InnoDB的主键索引就是数据表本身，它按主键顺序存放了整张表的数据。而InnoDB辅助索引（也叫作二级索引）只是根据索引列构建B+Tree，但在B+Tree的每一行都存了主键信息，加速回表操作。</p>
<p>聚簇索引占用的空间就是整个表数据量的大小，而二级索引会比聚簇索引小很多， 通常创建辅助索引就是为了提升查询效率。</p>
<p>在MySQLInnoDB中索引通常可以分为两大类：主键索引（即聚簇索引）和辅助索引（非聚簇索引）。对于没有指定主键的表，InnoDB会自己选择合适字段为主键，其选择顺序如下：</p>
<ul>
<li>显式主键；</li>
<li>第一个唯一索引（要求唯一索引所有列都非 NULL）；</li>
<li>内置的 6 字节 ROWID。</li>
</ul>
<p>建议使⽤ UNSIGNED 自增列显示创建主键。</p>
<h4 id="联合索引和覆盖索引">联合索引和覆盖索引</h4>
<p>根据索引列个数和功能描述不同索引也可以分为：联合索引和覆盖索引。</p>
<ul>
<li>联合索引是指在多个字段联合组建索引的。</li>
<li>当通过索引即可查询到所有记录，不需要回表到聚簇索引时，这类索引也叫作覆盖索引。</li>
<li>主键查询是天然的覆盖索引，联合索引可以是覆盖索引。</li>
</ul>
<p>那么如何看SQL语句是否使用到覆盖索引了呢？通常在查看执行计划时，Extra列为Usingindex则表示优化器使用了覆盖索引。</p>
<p>我们通常建议优先考虑使用覆盖索引，这是因为如果SQL需要查询辅助索引中不包含的数据列时，就需要先通过辅助索引查找到主键值，然后再回表通过主键查询到其他数据列（即回表查询），需要查询两次。而覆盖索引能从索引中直接获取查询需要的所有数据，从⽽避免回表进行二次查找，节省IO，效率较⾼。</p>
<h2 id="索引使用技巧">索引使用技巧</h2>
<p>接下来聊一聊索引使用技巧的基础知识，这些知识可以帮助你建立高效索引，主要有谓词、过滤因子、基数（Cardinality）、选择率和回表。</p>
<h4 id="谓词和过滤因子">谓词和过滤因子</h4>
<p>谓词本身就是条件表达式，通俗讲就是过滤字段。如下图中这句SQL语句，可以拆解为下面所示：</p>
<p><code>select * from city where city ='BeiJing' and last_updata = '2019-09-01'</code></p>
<p>简单谓词：city和last_updata。组合谓词：cityandlast_updata。</p>
<p>知道谓词后就可以计算谓词的过滤因子了，过滤因子直接描述了谓词的选择性，表示满足谓词条件的记录行数所占比例，过滤因子越小意味着能过滤越多数据，你需要在这类谓词字段上创建索引。</p>
<p>过滤因子的计算算法，就是满足谓词条件的记录行数除以表总行数。</p>
<ul>
<li>简单谓词的过滤因子 = 谓词结果集的数量 / 表总行数</li>
<li>组合谓词的过滤因子 = 谓词 1 的过滤因子 × 谓词 2 的过滤因子</li>
</ul>
<p>下面用一个例子来看下，如何快速根据SQL语句计算谓词、过滤因子。</p>
<ol>
<li>根据SQL语句可以快速得到谓词信息：简单谓词 city 和 last_update，组合谓词 city and last_update。</li>
<li>计算每个谓词信息的过滤因子，过滤因子越小表示选择性越强，字段越适合创建索引。例如：
<ul>
<li>city 的过滤因子=谓词 city 结果集的数量/表总行数=select count(*)  from city where city = ‘BeiJing’ / select countt(*) from city = 20%；</li>
<li>*last_update 的过滤因子 = 谓词 last_update 结果集的数量 / 表总行数 = select count(*) from  city where last_update = ‘2019-08-01’ / select count(*) from city = 10%；</li>
<li>组合谓词 = city 过滤因子 * last_update 过滤因子 = 20% × 10% = 2%，组合谓词的过滤因子为 2%，即只有表总行数的 2% 匹配过滤条件，可以考虑创建组合索引  (city，last_update)。</li>
</ul>
</li>
</ol>
<h4 id="基数和选择率">基数和选择率</h4>
<p>基数（Cardinality ）是某个键值去重后的行数，索引列不重复记录数量的预估值，MySQL优化器会依赖于它。选择率是count (distinct city) / count(*)，选择率越接近1则越适合创建索引，例如主键和唯一键的选择率都是 1。回表是指无法通过索引扫描访问所有数据，需要回到主表进行数据扫描并返回。</p>
<p>Cardinality 能快速告知字段的选择性，高选择性字段有利于创建索引。优化器在选择执行计划时会依赖该信息，通常这类信息也叫作统计信息，数据库中对于统计信息的采集是在存储引擎层进行的。</p>
<p>执行 show index from table_name会看到 Cardinality，同时也会触发 MySQL 数据库对 Cardinaltiy 值的统计。除此之外，还有三种更新策略。</p>
<ul>
<li>触发统计：Cardinality 统计信息更新发生在 INSERT 和 UPDATE 时，InnoDB 存储引擎内部更新的 Cardinality 信息的策略为：1.表中超过1/16的数据发生变化；2.stat_modified_counter &gt; 2000 000 000 （20亿）。</li>
<li>采样统计（sample）：为了减少统计信息更新造成的资源消耗，数据库对 Cardinality 通过采样来完成统计信息更新，每次随机获取 innodb_stats_persistent_sample_pages 页的数量进行 Cardinality 统计。</li>
<li>手动统计：alter table table_name engine=innodb或 analyze table table_name，当发现优化器选择错误的执行计划或没有走理想的索引时，执行 SQL 语句来手动统计信息有时是一种有效的方法。</li>
</ul>
<p>由于采样统计的信息是随机获取8个（8是由innodb_stats_transient_sample_pages参数指定）页面数进行分析，这就意味着下一次随机的8个页面可能是其他页面，其采集页面的 Carinality 也不同。因此当表数据无变化时也会出现 Cardinality 发生变化的情况。</p>
<h2 id="索引使用细节">索引使用细节</h2>
<p>创建索引后如何确认SQL语句是否走索引了呢？创建索引后通过查看执行SQL语句的执行计划即可知道SQL语句是否走索引。执行计划重点关注跟索引相关的关键项，有type、possible_keys、key、key_len、ref、Extra 等。</p>
<p>其中，<strong>possible_keys</strong> 表示查询可能使用的索引，<strong>key</strong>表示真正实际使用的索引，<strong>key_len</strong> 表示使用索引字段的长度。另外执行计划中Extra选项也值得关注，例如<strong>Extra</strong>显示use index时就表示该索引是覆盖索引，通常性能排序的结果是use index&gt;use where&gt;use filsort</p>
<p>当索引选择组合索引时，通过计算key_len来了解有效索引长度对索引优化也是非常重要的，接下来重点讲解key_len计算规则。key_len表示得到结果集所使用的选择索引的长度[字节数]，不包括orderby，也就是说如果orderby也使用了索引则key_len不计算在内。key_len计算规则从两个方面考虑，一方面是索引字段的数据类型，另一方面是表、字段所使用的字符集。</p>
<p>索引字段的数据类型，根据索引字段的定义可以分为变长和定长两种数据类型：</p>
<ol>
<li>索引字段为定长数据类型，比如char、int、datetime，需要有是否为空的标记，这个标记需要占用1个字节；</li>
<li>对于变长数据类型，比如Varchar，除了是否为空的标记外，还需要有长度信息，需要占用两个字节。</li>
</ol>
<p>表所使用的字符集，不同的字符集计算的 key_len 不一样，例如，GBK 编码的是一个占用 2 个字节大小的字符，UTF8 编码的是一个占用 3 个字节大小的字符。</p>
<p>通过key_len计算也帮助我们了解索引的<strong>最左前缀匹配原则</strong>。最左前缀匹配原则是指在使用B+Tree联合索引进行数据检索时，MySQL优化器会读取谓词（过滤条件）并按照联合索引字段创建顺序一直向右匹配直到遇到范围查询或非等值查询后停止匹配，此字段之后的索引列不会被使用，这时计算 key_len 可以分析出联合索引实际使用了哪些索引列。</p>
<h2 id="设计高性能索引">设计高性能索引</h2>
<ol>
<li>**定位由于索引不合适或缺少索引而导致的慢查询。**通常在业务建库建表时就需要提交业务运行相关的SQL给DBA审核，也可以借助ArkcontrolArkit来自动化审核。比如，慢查询日志分析，抓出运行慢的SQL进行分析，也可以借助第三方工具例如Arkcontrol慢查询分析系统进行慢查询采集和分析。在分析慢查询时进行参数最差输入，同时，对SQL语句的谓词进行过滤因子、基数、选择率和SQL查询回表情况的分析。</li>
<li><strong>设计索引</strong>的目标是让查询语句运行得足够快，同时让表、索引维护也足够快，例如，使用业务不相关自增字段为主键，减缓页分裂、页合并等索引维护成本，加速性能。也可以使用第三方工具进行索引设计，例如Arkcontrol SQL 优化助手，会给出设计索引的建议。</li>
<li>**创建索引策略：**优先为搜索列、排序列、分组列创建索引，必要时加入查询列创建覆盖索引；计算字段列基数和选择率，选择率越接近于1越适合创建索引；索引选用较小的数据类型（整型优于字符型），字符串可以考虑前缀索引；不要建立过多索引，优先基于现有索引调整顺序；参与比较的字段类型保持匹配并创建索引。</li>
<li>**调优索引：**分析执行计划；更新统计信息（AnalyzeTable）；Hint优化，方便调优（FORCEINDEX、USEINDEX、IGNOREINDEX、STRAIGHT_JOIN）；检查连接字段数据类型、字符集；避免使用类型转换；关注 optimizer_switch，重点关注索引优化特性 MRR（Multi-Range Read）和 ICP（Index Condition Pushdown）。
<ul>
<li>MRR优化是为了减少磁盘随机访问，将随机IO转化为顺序IO的数据访问，其方式是将查询得到辅助索引的键值放到内存中进行排序，通常是按照主键或RowID进行排序，当需要回表时直接根据主键或 RowID 排序顺序访问实际的数据文件，加速 SQL 查询。</li>
<li>ICP优化同样也是对索引查询的优化特性，MySQL根据索引查询到数据后会优先应用where条件进行数据过滤，即无法使用索引过滤的where子句，其过滤由之前Server层的数据过滤下推到了存储引擎层，可以减少上层对记录的检索，提高数据库的整体性能。</li>
</ul>
</li>
</ol>
<h2 id="创建索引规范">创建索引规范</h2>
<ul>
<li>命名规范，各个公司内部统一。</li>
<li>考虑到索引维护的成本，单张表的索引数量不超过5个，单个索引中的字段数不超过5个。</li>
<li>表必需有主键，推荐使⽤UNSIGNED自增列作为主键。表不设置主键时InnoDB会默认设置隐藏的主键列，不便于表定位数据同时也会增大MySQL运维成本（例如主从复制效率严重受损、pt工具无法使用或正确使用）。</li>
<li>唯一键由3个以下字段组成，并且在字段都是整形时，可使用唯一键作为主键。其他情况下，建议使用自增列或发号器作主键。</li>
<li>禁止冗余索引、禁止重复索引，索引维护需要成本，新增索引时优先考虑基于现有索引进行rebuild，例如(a,b,c)和(a,b)，后者为冗余索引可以考虑删除。重复索引也是如此，例如索引(a)和索引(a,主键ID) 两者重复，增加运维成本并占用磁盘空间，按需删除冗余索引。</li>
<li>联表查询时，JOIN 列的数据类型必须相同，并且要建⽴索引。</li>
<li>不在低基数列上建⽴索引，例如“性别”。 在低基数列上创建的索引查询相比全表扫描不一定有性能优势，特别是当存在回表成本时。</li>
<li>选择区分度（选择率）大的列建立索引。组合索引中，区分度（选择率）大的字段放在最前面。</li>
<li>对过长的Varchar段建立索引。建议优先考虑前缀索引，或添加CRC32或MD5伪列并建⽴索引。</li>
<li>合理创建联合索引，(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)。</li>
<li>合理使用覆盖索引减少IO，避免排序。</li>
</ul>
<h1>查询优化</h1>
<p>MySQL采用基于开销的优化器，以确定处理查询的最佳方式，也就是说执行查询之前，都会先选择一条自以为最优的方案。在很多情况下，MySQL能够计算最佳的可能查询计划，但在某些情况下，MySQL没有关于数据的足够信息，或者是提供太多的相关数据信息，它所采用的可能并非就是事实上的最优方案。这里举了两个例子来说明。</p>
<h3 id="案例一">案例一</h3>
<p><strong>Range Query Optimizer的流程</strong></p>
<ol>
<li>根据查询条件计算所有的 possible keys。</li>
<li>计算全表扫描代价（cost_all）。</li>
<li>计算最小的索引范围访问代价（这一步很关键，直接决定了 Range 的查询效率），它有三步：
<ol>
<li>对于每一个possible keys（可选索引），调用records_in_ranges函数计算范围中的rows；</li>
<li>根据rows，计算二级索引访问代价；</li>
<li>获取cost最小的二级索引访问（cost_range）。</li>
</ol>
</li>
<li>选择执行最小化访问代价的执行计划。如果 cost_all &lt;= cost_range，则全表扫描，否则索引范围扫描。</li>
</ol>
<p>Range使用了records_in_range函数估算每个值范围的rows，结果依赖于possible_keys；possible_keys越多，随机IO代价越大，Range查询效率。所以，索引不是越多越好，相反，我们应该尽量减少possible_keys，减少records_in_range从而减少IO的消耗。这里给大家推荐两个工具，用pt-index-usage工具来删除冗余索引，用 pt-duplicate-key-checker 工具来删除重复索引。</p>
<h3 id="案例二">案例二</h3>
<p>优化前有一个索引idx_global_id。图中的这条SQL语句的where条件包括一个sub_id的等值查询和一个global_id的范围查询。执行一次需要2.37秒。从下一页的执行计划中，我们可以看到虽然查询优化器使用了唯一索引uniq_subid_globalid，但是由于idx_global_id的干扰，实际只使用了前面的4个长度就access，剩余8个长度都被filter了。<br>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/查询优化.png" style="zoom: 80%;" /><br>
从优化后的执行计划中可以看到，使用了forceindex来强制使用唯一索引。正如上文列举的，相似的命令还有ignoreindex忽略索引，straght_join强制优化器按特定的顺序使强制优化器按特定的顺序使用数据表，high_priority 或 low_priority 两个命令来控制 SQL 的执行优先权。</p>
<h3 id="ICP-MRR-BKA">ICP,MRR,BKA</h3>
<p>1.ICPICP是IndexConditionPushdown的简称，是MySQL使用索引从表中检索行数据的一种优化方式。目的是减少从基表中全记录读取操作的数量，从而降低IO操作。</p>
<p>在没有开启ICP之前，存储引擎会通过遍历索引查找基表中的行，然后返回给MySQLServer层，再去为这些数据行进行where后的条件过滤。开启ICP之后，如果部分where条件能使用索引中的字段，MySQLServer会把这部分下推到存储引擎层，存储引擎通过索引过滤，把满足的行从表中读取出来。ICP能减少引擎层访问基表的次数和MySQLServer访问存储引擎的次数。对于 InnoDB 表来说，ICP 只适用于辅助索引.</p>
<p>2.MRR</p>
<p>MRR 是 Multi-Range Read 的简称，是 MySQL 优化器将随机 IO转化为顺序IO以降低查询过程中IO开销的一种手段。MRR的适用场景是辅助索引，如INDEX(key1)，查询key1在n到m范围内的数据。使用限制就是MRR，MR适用于range、ref、eq_ref的查询。</p>
<p>3.BKA和BNLBKA是BatchedKeyAccess的简称，是MySQL优化器提高表join性能的一种手段，它是一种算法。而BNL是BlockNestedLoop的简称，它是默认的处理表join的方式和算法。那么二者有什么区别呢？</p>
<p>•BNL比BKA出现的早，BKA直到MySQL 5.6 版本才出现，而 BNL 至少在 MySQL 5.1 版本中就存在了；</p>
<p>• BNL 主要用于被 join 的表上无索引时；</p>
<p>• BKA 只在被 join 表上有索引时可以使用，那么就在行提交给被 join 的表之前，对这些行按照索引字段进行排序，因此减少了随机 IO，排序才是两者最大的区别，但如果被 join 的表没有索引呢？那么就只能使用 BNL 了。</p>
<p>使用BKA需要注意一些问题，比如：BKA的适用场景支持inner join、outer join、semi-join operations、including nested outer joins等；</p>
<p>BKA 有两个使用限制，一个是使用 BKA 特性，必须启用 MRR 特性；二是 BKA 主要适用于 join 的表上有索引可使用的情况，否则只能使用 BNL。</p>
<h2 id="MySQL执行计划分析三部曲">MySQL执行计划分析三部曲</h2>
<p>当有慢查询或者执行 SQL 遇到瓶颈时，我们分析这类问题时可以参考 MySQL 执行计划分析“三步曲”。</p>
<ol>
<li>查看 SQL 执行计划：</li>
</ol>
<ul>
<li>explain SQL；</li>
<li>desc 表名；</li>
<li>show create table 表名。</li>
</ul>
<ol start="2">
<li>通过 Profile 定位 QUERY 代价消耗：
<ul>
<li>setprofiling=1；</li>
<li>执行SQL；</li>
<li>show profiles;获取Query_ID。</li>
<li>show profile for query Query_ID;查看详细的profile信息</li>
</ul>
</li>
<li>通过Optimizer Trace表查看SQL执行计划树：
<ul>
<li>set session optimizer_trace = ‘enabled = on’；</li>
<li>执行SQL；</li>
<li>查询information_schema.optimizer_trace 表，获取 SQL 查询计划树；</li>
<li>set session optimizer_trace=‘enabled=off’；开启此项影响性能，记得用后关闭。</li>
</ul>
</li>
</ol>
<h2 id="查询相关参数和分析工具">查询相关参数和分析工具</h2>
<p>MySQL 可以通过设置一些参数，将运行时间长或者非索引查找的 SQL 记录到慢查询文件中。可以分析慢查询文件中的 SQL，有针对性的进行优化。</p>
<ul>
<li>参数slow_query_log，表示是否开启慢查询日志，ON或者1表示开启，OFF或者0表示关闭。</li>
<li>参数long_query_time，设置慢查询的阈值，MySQL5.7版本支持微秒级。</li>
<li>参数slow_query_log_file，慢查询文件的存放路径。</li>
<li>参数log_queries_not_using_indexes，表示是否将非索引查找的SQL也记录到慢查询文件中未使用索引的 SQL 语句上限，0 表示没限制。</li>
<li>参数 log_throttle_queries_not_using_indexes，表示每分钟记录到慢查询文件中未使用索引的 SQL 语句上限，0 表示没限制。</li>
<li>参数 max_execution_time，用来控制 SELECT 语句的最大执行时间，单位毫秒，超过此值MySQL 自动 kill 掉该查询。</li>
</ul>
<img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/typora-user-images/慢查询例子.png" style="zoom: 80%;" />
如上图所示是一个慢查询的例子，通过这个例子你可以看到慢查询文件中记录了哪些信息。包括了慢SQL产生的时间，SQL源自的IP和对应的数据库用户名，以及访问的数据库名称；查询的总耗时，被lock 的时间，结果集行数，扫描的行数，以及字节数等。当然还有具体的 SQL 语句。
<p>分析慢查询常用的工具有：</p>
<p>explain；</p>
<p>Mysql dump slow，官方慢查询分析工具；</p>
<p>pt-query-digest，Percona公司开源的慢查询分析工具；</p>
<p>vc-mysql-sniffer，第三方的慢查询抓取工具；</p>
<p>pt-kill，Percona公司开源的慢查询kill工具，常用于生产环境的过载保护。</p>
<p>这里重点介绍pt-query-digest，它是用于分析MySQL慢查询的一个常用工具，先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，同时把分析结果输出到文件中。也可以结合 Anemometer 工具将慢查询平台化展示。</p>
<h2 id="如何优化SQL">如何优化SQL</h2>
<ol>
<li>
<p>全表扫描还是索引扫描。对于小表来说，二者IO调用次数和返回时间相差不大；但对于大表，如果全表扫描，那么查询返回的时间就会很长，就需要使用索引扫描加快查询速度。但并不是要求DBA根据每一种查询条件组合都要创建索引，索引过多也会降低写入和修改的速度，而且如果导致表数据和索引数据比例失调，也不利于后期的正常维护。</p>
</li>
<li>
<p>如何创建索引，在哪些列上建立索引适合业务需求？一般情况下，你可以在选择度高的列上创建索引，也可以在status列上创建索引。创建索引时，要注意避免冗余索引，除非一些特殊情况外。如index(a,b,c)和index(a)，其中a的单列索引就是冗余索引。</p>
</li>
<li>
<p>创建索引以后，尽量不要过频修改。业务可以根据现有的索引情况合理使用索引，而不是每次都去修改索引。能在索引中完成的查找，就不要回表查询。比如SELECT某个具体字段，就有助于实现覆盖索引从而降低IO次数，达到优化SQL的目的。</p>
</li>
<li>
<p>多表关联的SQL，在关联列上要有索引且字段类型一致，这样MySQL在进行嵌套循环连接查找时可以使用索引，且不会因为字段类型不一致或者传入的参数类型与字段类型不匹配的情况，这样就会导致无法使用索引，在优化SQL时需要重点排查这种情况。另外索引列上使用函数也不会涉及索引。多表关联时，尽量让结果集小的表作为驱动表，注意是结果集小的表，不是小表。</p>
</li>
<li>
<p>在日常中你会发现全模糊匹配的查询，由于MySQL的索引是B+树结构，所以当查询条件为全模糊时，例如‘%**%’，索引无法使用，这时需要通过添加其他选择度高的列或者条件作为一种补充，从而加快查询速度。当然也可以通过强制SQL进行全索引扫描，但这种方式不好，尽量不要在SQL中添加hints。对于这种全模糊匹配的场景，可以放到ES或者solr中解决。尽量不要使用子查询，对子查询产生的临时表再扫描时将无索引可查询，只能进行全表扫描，并且MySQL对于出现在from中的表无所谓顺序，对于where中也无所谓顺序，这也是可以优化SQL的地方。</p>
</li>
<li>
<p>另外orderby/groupby的SQL涉及排序，尽量在索引中包含排序字段，并让排序字段的排序顺序与索引列中的顺序相同，这样可以避免排序或减少排序次数。</p>
</li>
<li>
<p>除此之外，复杂查询还是简单查询？貌似总会面临这样的疑问和选择。不要总想着用一个SQL解决所有事情，可以分步骤来进行，MySQL也十分擅长处理短而简单的SQL，总体耗时会更短，而且也不会产生臃肿的 SQL，让人难以理解和优化。</p>
</li>
</ol>
<p>常用的SQL编写规范如下所示。</p>
<ul>
<li>SELECT只获取必要的字段，禁止使用SELECT*。这样能减少网络带宽消耗，有效利用覆盖索引，表结构变更对程序基本无影响。</li>
<li>用IN代替OR。SQL语句中IN包含的值不宜过多，应少于1000个。过多会使随机IO增大，影响性能。</li>
<li>禁止使用orderbyrand()。orderbyrand()会为表增加几个伪列，然后用rand() 函数为每一行数据计算 rand() 值，最后基于该行排序，这通常都会生成磁盘上的临时表，因此效率非常低。建议先使用 rand() 函数获得随机的主键值，然后通过主键获取数据。</li>
<li>SQL中避免出现now()、rand()、sysdate()、current_user()等不确定结果的函数。在语句级复制场景下，引起主从数据不一致；不确定值的函数，产生的SQL语句无法使用QUERY CACHE。</li>
</ul>

      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">JVM 的主要组成部分及其作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E2%AD%90"><span class="nav-number">2.</span> <span class="nav-text">JVM 运行时数据区⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">2.1.</span> <span class="nav-text">堆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">堆和栈的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="nav-number">3.1.</span> <span class="nav-text">分代回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F%E2%AD%90"><span class="nav-number">4.</span> <span class="nav-text">什么是双亲委派模型？⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">双亲委派机制的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">对象的创建过程？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Step1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="nav-number">6.0.1.</span> <span class="nav-text">Step1:类加载检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Step2-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">6.0.2.</span> <span class="nav-text">Step2:分配内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Step3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="nav-number">6.0.3.</span> <span class="nav-text">Step3:初始化零值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Step4-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">6.0.4.</span> <span class="nav-text">Step4:设置对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Step5-%E6%89%A7%E8%A1%8C-init-%E6%96%B9%E6%B3%95"><span class="nav-number">6.0.5.</span> <span class="nav-text">Step5:执行 init 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">类加载的执行过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">怎么判断对象是否可以被回收？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">Java 中都有哪些引用类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E2%AD%90"><span class="nav-number">10.</span> <span class="nav-text">常见的垃圾回收机制⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E2%AD%90"><span class="nav-number">11.</span> <span class="nav-text">jvm 有哪些垃圾回收算法⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor-GC%E5%92%8CFull-GC%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%E2%AD%90"><span class="nav-number">11.1.</span> <span class="nav-text">Minor GC和Full GC触发条件⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E4%B8%ADStop-the-world%EF%BC%88STW%EF%BC%89%E2%AD%90"><span class="nav-number">11.2.</span> <span class="nav-text">GC中Stop the world（STW）⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Roots"><span class="nav-number">11.3.</span> <span class="nav-text">哪些对象可以作为GC Roots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E9%94%81%E4%BC%98%E5%8C%96%E5%92%8C%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B%E2%AD%90"><span class="nav-number">11.4.</span> <span class="nav-text">JVM锁优化和膨胀过程⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">jvm 有哪些垃圾回收器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E2%AD%90"><span class="nav-number">13.</span> <span class="nav-text">详细介绍一下 CMS 垃圾回收器⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%92%8CCMS%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">13.1.</span> <span class="nav-text">G1和CMS的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i-%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E2%AD%90"><span class="nav-number">13.2.</span> <span class="nav-text">i++操作的字节码指令⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-jvm-%E8%B0%83%E4%BC%98%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-number">14.</span> <span class="nav-text">说一下 jvm 调优的工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO%EF%BC%9A"><span class="nav-number">15.</span> <span class="nav-text">TODO：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">一 概览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection"><span class="nav-number">1.</span> <span class="nav-text">Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">1.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">1.2.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue"><span class="nav-number">1.3.</span> <span class="nav-text">Queue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">2.</span> <span class="nav-text">Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">二 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-number">1.</span> <span class="nav-text">ArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.</span> <span class="nav-text">2.扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">1.3.</span> <span class="nav-text">3.添加和删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">2.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList"><span class="nav-number">3.</span> <span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%A7%88"><span class="nav-number">3.0.1.</span> <span class="nav-text">1. 概览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%8E-ArrayList-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">3.0.2.</span> <span class="nav-text">2.与 ArrayList 的比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">4.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B4%E4%BD%93%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">4.0.1.</span> <span class="nav-text">1.整体原理分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-put%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">4.0.2.</span> <span class="nav-text">2.put方法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%89%A9%E5%AE%B9%EF%BC%88resize%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">4.0.3.</span> <span class="nav-text">3.扩容（resize方法）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">5.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet"><span class="nav-number">6.</span> <span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">7.</span> <span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap-%E5%AE%9E%E7%8E%B0LRU%EF%BC%88least-recently-used%EF%BC%89"><span class="nav-number">7.1.</span> <span class="nav-text">LinkedHashMap 实现LRU（least recently used）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">8.</span> <span class="nav-text">TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap-%E5%85%B6-key-%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E8%A6%81%E5%AE%9E%E7%8E%B0-Compare-%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.1.</span> <span class="nav-text">TreeMap 其 key 对象为什么必须要实现 Compare 接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">9.</span> <span class="nav-text">BlockingQueue 的实现类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">Java基础面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9-%E4%BB%80%E4%B9%88%E6%98%AFJava%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">Java 语言有哪些特点&#x2F;什么是Java？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">面向对象和面向过程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">Java和C++的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E6%9C%89%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">Java有几种基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">基本类型和引用类型？他们的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">重载和重写的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-number">6.0.1.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">6.0.2.</span> <span class="nav-text">重写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81"><span class="nav-number">7.</span> <span class="nav-text">Java 面向对象编程三大特性: 封装 继承 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">7.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">7.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">7.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-%E5%9C%A8-java-%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">final 在 java 中有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">9.</span> <span class="nav-text">String StringBuffer 和 StringBuilder 的区别是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">String 是如何实现不可变的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">String 为什么设置为不可变？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception%E3%80%81Error%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C-java-%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="nav-number">11.1.</span> <span class="nav-text">Exception、Error、运行时异常与一般异常有何异同 &#x2F;java 异常体系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">接口和抽象类的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">Object类有哪些常用的方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.1.</span> <span class="nav-text">&#x3D;&#x3D; 和 equals 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashCode-%E4%B8%8E-equals-%E9%87%8D%E8%A6%81"><span class="nav-number">14.</span> <span class="nav-text">hashCode 与 equals (重要)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode%EF%BC%88%EF%BC%89%E4%BB%8B%E7%BB%8D"><span class="nav-number">14.1.</span> <span class="nav-text">hashCode（）介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashCode"><span class="nav-number">14.2.</span> <span class="nav-text">为什么要有 hashCode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode%EF%BC%88%EF%BC%89%E4%B8%8Eequals%EF%BC%88%EF%BC%89%E7%9A%84%E7%9B%B8%E5%85%B3%E8%A7%84%E5%AE%9A"><span class="nav-number">14.3.</span> <span class="nav-text">hashCode（）与equals（）的相关规定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99-hashcode-%E8%BF%98%E8%A6%81%E9%87%8D%E5%86%99-equals-%EF%BC%9F%E5%8F%8D%E4%B9%8B%E4%BA%A6%E5%8F%AF%E9%97%AE%E3%80%82"><span class="nav-number">14.4.</span> <span class="nav-text">为什么要重写 hashcode( ) 还要重写 equals( ) ？反之亦可问。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">Java序列化中如果有些字段不想进行序列化，怎么办？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-number">15.1.</span> <span class="nav-text">幂等性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E5%89%8D%E7%AB%AF%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">怎么防止前端重复提交？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">&#x3D;&#x3D; 和 equals 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E8%AF%BB"><span class="nav-number">1.</span> <span class="nav-text">&#x3D;&#x3D; 解读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals"><span class="nav-number">2.</span> <span class="nav-text">equals</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">缓存池和字符串常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="nav-number">1.</span> <span class="nav-text">缓存池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.</span> <span class="nav-text">字符串常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-s-new-String-%E2%80%9Cabc%E2%80%9D-%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.</span> <span class="nav-text">String s &#x3D; new String(“abc”) 会创建几个对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">Linux面试题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">推荐终端工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">常用命令（重要）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#top%E2%AD%90"><span class="nav-number">2.</span> <span class="nav-text">top⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#less-%E5%92%8C-more"><span class="nav-number">3.</span> <span class="nav-text">less 和 more</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tail%E2%AD%90"><span class="nav-number">4.</span> <span class="nav-text">tail⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#netstat%E2%AD%90"><span class="nav-number">5.</span> <span class="nav-text">netstat⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#grep-%E6%9F%A5%E6%89%BE%E2%AD%90"><span class="nav-number">6.</span> <span class="nav-text">grep 查找⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6-find"><span class="nav-number">7.</span> <span class="nav-text">查找特定文件 find</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">7.1.</span> <span class="nav-text">管道操作符    |</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%80%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">杀僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%81%9A%E7%BB%9F%E8%AE%A1-awk-%E2%AD%90"><span class="nav-number">8.</span> <span class="nav-text">对文件内容做统计 awk ⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2-sed"><span class="nav-number">9.</span> <span class="nav-text">批量替换 sed</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%93%AA%E4%BA%9B-Linux-%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">你经常使用哪些 Linux 命令，主要用来解决什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E6%9E%B6%E6%9E%84"><span class="nav-number">11.</span> <span class="nav-text">MySQL架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">11.1.</span> <span class="nav-text">逻辑架构图和执行流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">11.2.</span> <span class="nav-text">并发控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">11.3.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">11.3.1.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-MVVC"><span class="nav-number">11.3.2.</span> <span class="nav-text">多版本并发控制(MVVC)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">11.4.</span> <span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB"><span class="nav-number">11.4.1.</span> <span class="nav-text">InnoDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyISAM"><span class="nav-number">11.4.2.</span> <span class="nav-text">MyISAM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Myisam-%E5%92%8C-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">11.4.3.</span> <span class="nav-text">Myisam 和 InnoDB 的区别</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">数据库设计优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">浮点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F"><span class="nav-number">3.</span> <span class="nav-text">时间和日期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-DATETIME"><span class="nav-number">3.1.</span> <span class="nav-text">1. DATETIME</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TIMESTAMP"><span class="nav-number">3.2.</span> <span class="nav-text">2. TIMESTAMP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">数据库的三范式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">如何设计一个关系型数据库？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">B 树和 B + 树的概念和区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="nav-number">1.1.</span> <span class="nav-text">最佳左前缀法则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87"><span class="nav-number">2.</span> <span class="nav-text">为什么使用索引能提高效率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">为什么要使用索引？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">索引的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E4%B8%8D%E5%BB%BA%E6%88%96%E5%B0%91%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">4.</span> <span class="nav-text">什么情况下应不建或少建索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">索引优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%88%97"><span class="nav-number">5.1.</span> <span class="nav-text">独立的列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95"><span class="nav-number">5.2.</span> <span class="nav-text">多列索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-number">5.3.</span> <span class="nav-text">前缀索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95-2"><span class="nav-number">5.4.</span> <span class="nav-text">多列索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.5.</span> <span class="nav-text">索引列的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">5.6.</span> <span class="nav-text">聚簇索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">5.6.1.</span> <span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">5.7.</span> <span class="nav-text">覆盖索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C"><span class="nav-number">6.</span> <span class="nav-text">索引的使用经验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">7.</span> <span class="nav-text">性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Explain"><span class="nav-number">7.1.</span> <span class="nav-text">Explain</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#id"><span class="nav-number">7.1.1.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type"><span class="nav-number">7.1.2.</span> <span class="nav-text">type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#key-len"><span class="nav-number">7.1.3.</span> <span class="nav-text">key_len</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Extra"><span class="nav-number">7.1.4.</span> <span class="nav-text">Extra</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">查询优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">MySQL面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F-2"><span class="nav-number">1.</span> <span class="nav-text">如何设计一个关系型数据库？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">数据库的三范式是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0-ACID%E2%AD%90"><span class="nav-number">3.</span> <span class="nav-text">事务的基本要素 ACID⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">char 和 varchar 的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#where%E4%B8%8Ehaving%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">where与having的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E2%AD%90"><span class="nav-number">6.</span> <span class="nav-text">数据库的事务隔离&#x2F;事务隔离级别⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E2%AD%90"><span class="nav-number">6.1.</span> <span class="nav-text">如何解决事务的并发问题⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F%E2%AD%90"><span class="nav-number">7.</span> <span class="nav-text">说一下乐观锁和悲观锁？⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-MVCC-%E2%AD%90"><span class="nav-number">8.</span> <span class="nav-text">多版本并发控制(MVCC)⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F%E2%AD%90"><span class="nav-number">9.</span> <span class="nav-text">MySQL逻辑架构和执行流程？⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-mysql-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">说一下 mysql 常用的引擎？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Myisam%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="nav-number">11.</span> <span class="nav-text">Myisam和InnoDB的区别⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql-%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">mysql 索引是怎么实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">13.</span> <span class="nav-text">B树和B+树的概念和区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E2%AD%90"><span class="nav-number">14.</span> <span class="nav-text">为什么选择B+树作为索引结构⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF%E2%AD%90"><span class="nav-number">15.</span> <span class="nav-text">B+树的叶子节点都可以存哪些东西⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BF%A1%E6%81%AF%E8%83%BD%E6%88%90%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">16.</span> <span class="nav-text">什么样的信息能成为索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E2%AD%90"><span class="nav-number">16.1.</span> <span class="nav-text">聚簇索引⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-2"><span class="nav-number">16.1.1.</span> <span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E2%AD%90"><span class="nav-number">16.2.</span> <span class="nav-text">覆盖索引⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99%E2%AD%90"><span class="nav-number">17.</span> <span class="nav-text">最佳左前缀法则⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">mysql 问题排查都有哪些手段？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E9%87%8D%E7%82%B9%E5%AD%97%E6%AE%B5"><span class="nav-number">19.</span> <span class="nav-text">性能分析的重点字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#type-2"><span class="nav-number">19.0.1.</span> <span class="nav-text">type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Extra-2"><span class="nav-number">19.0.2.</span> <span class="nav-text">Extra</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">20.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sql-%E4%BC%98%E5%8C%96%E5%8F%AF%E4%BB%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E8%80%83%E8%99%91%EF%BC%9F%E2%AD%90"><span class="nav-number">21.</span> <span class="nav-text">sql 优化可以从哪些方面考虑？⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C-2"><span class="nav-number">22.</span> <span class="nav-text">索引的使用经验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C"><span class="nav-number">23.</span> <span class="nav-text">数据库调优经验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E5%BE%80mysql%E5%AF%BC%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">批量往mysql导入1000万数据有什么方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redolog-undolog-binlog"><span class="nav-number">24.1.</span> <span class="nav-text">redolog,undolog,binlog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog%E5%92%8Credolog%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">24.2.</span> <span class="nav-text">binlog和redolog的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">MyBatis 整体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">接口层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B1%82"><span class="nav-number">1.0.1.</span> <span class="nav-text">数据处理层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82"><span class="nav-number">1.0.2.</span> <span class="nav-text">基础支持层</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">MyBatis 核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SqlSessionFactory"><span class="nav-number">1.</span> <span class="nav-text">SqlSessionFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SqlSessionFactory-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">SqlSessionFactory 的执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#configuration-%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.1.</span> <span class="nav-text">configuration 的配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SqlSession"><span class="nav-number">2.</span> <span class="nav-text">SqlSession</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor"><span class="nav-number">3.</span> <span class="nav-text">Executor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Executor-%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="nav-number">3.0.1.</span> <span class="nav-text">Executor 的继承结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor-%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">Executor 的具体执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StatementHandler"><span class="nav-number">3.2.</span> <span class="nav-text">StatementHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StatementHandler-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.2.1.</span> <span class="nav-text">StatementHandler 的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.2.2.</span> <span class="nav-text">#{}和${}的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E9%99%A4%E4%BA%86%E5%B8%B8%E8%A7%81%E7%9A%84-select-insert-updae-delete-%E6%A0%87%E7%AD%BE%E4%B9%8B%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE%EF%BC%9F"><span class="nav-number">3.2.3.</span> <span class="nav-text">Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mybatis-%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">mybatis 有几种分页方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mybatis-%E9%80%BB%E8%BE%91%E5%88%86%E9%A1%B5%E5%92%8C%E7%89%A9%E7%90%86%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">mybatis 逻辑分页和物理分页的区别是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">Redis面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">0.1.</span> <span class="nav-text">Redis是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E2%AD%90"><span class="nav-number">0.2.</span> <span class="nav-text">应用场景⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%92%8C-memcached-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">0.3.</span> <span class="nav-text">Redis 和 memcached 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="nav-number">0.4.</span> <span class="nav-text">redis 为什么是单线程的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F%E2%AD%90"><span class="nav-number">0.5.</span> <span class="nav-text">为什么Redis这么快？⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%BA%94%E7%94%A8%EF%BC%9F%E2%AD%90"><span class="nav-number">0.6.</span> <span class="nav-text">Redis 支持的数据类型有哪些？应用？⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zset%E8%B7%B3%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%AD%90"><span class="nav-number">0.7.</span> <span class="nav-text">zset跳表的数据结构⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">0.8.</span> <span class="nav-text">redis 设置过期时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E2%AD%90"><span class="nav-number">0.9.</span> <span class="nav-text">数据过期策略⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E2%AD%90"><span class="nav-number">0.10.</span> <span class="nav-text">数据淘汰机制⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%9A%84LRU%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">0.11.</span> <span class="nav-text">Redis的LRU具体实现：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%AD%90"><span class="nav-number">0.12.</span> <span class="nav-text">Redis 持久化的两种方式⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB-%E4%B8%8E-AOF-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="nav-number">0.12.1.</span> <span class="nav-text">RDB 与 AOF 如何选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="nav-number">0.13.</span> <span class="nav-text">为什么要用缓存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F%E2%AD%90"><span class="nav-number">0.14.</span> <span class="nav-text">怎么保证缓存和数据库数据的一致性？⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="nav-number">0.15.</span> <span class="nav-text">redis 怎么实现分布式锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">0.16.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">0.17.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">0.18.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9C%89%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E6%88%96%E8%80%85%E4%BC%9A%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="nav-number">0.19.</span> <span class="nav-text">实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">0.20.</span> <span class="nav-text">主从复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Cloud-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">Spring Cloud 的理解？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Eureka"><span class="nav-number">1.1.</span> <span class="nav-text">服务发现框架——Eureka</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eureka-%E5%8E%9F%E7%90%86%E2%AD%90"><span class="nav-number">2.</span> <span class="nav-text">Eureka 原理⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eureka-%E5%92%8C-ZooKeeper-%E7%9A%84%E5%8C%BA%E5%88%AB-%E2%AD%90"><span class="nav-number">3.</span> <span class="nav-text">Eureka 和 ZooKeeper 的区别 ⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8B-Ribbon"><span class="nav-number">3.1.</span> <span class="nav-text">负载均衡之 Ribbon</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Nginx-%E5%92%8C-Ribbon-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">3.1.1.</span> <span class="nav-text">Nginx 和 Ribbon 的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ribbon-%E7%9A%84%E5%87%A0%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">Ribbon 的几种负载均衡算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Open-Feign"><span class="nav-number">3.2.</span> <span class="nav-text">Open Feign</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hystrix%E2%80%93%E6%96%AD%E8%B7%AF%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">Hystrix–断路器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E5%8E%9F%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">服务熔断原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E2%80%94%E2%80%94Zuul"><span class="nav-number">5.</span> <span class="nav-text">微服务网关——Zuul</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD"><span class="nav-number">5.0.1.</span> <span class="nav-text">路由功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD"><span class="nav-number">5.0.2.</span> <span class="nav-text">过滤功能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94Config"><span class="nav-number">6.</span> <span class="nav-text">配置管理——Config</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Cloud-Bus"><span class="nav-number">6.1.</span> <span class="nav-text">Spring Cloud Bus</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">7.</span> <span class="nav-text">启动过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Bean-%E5%AE%B9%E5%99%A8%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">7.1.</span> <span class="nav-text">创建 Bean 容器前的准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Bean-%E5%AE%B9%E5%99%A8%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%B3%A8%E5%86%8C-Bean"><span class="nav-number">7.2.</span> <span class="nav-text">创建 Bean 容器，加载并注册 Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanDefinition-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-number">7.2.1.</span> <span class="nav-text">BeanDefinition 接口定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#customizeBeanFactory"><span class="nav-number">7.2.2.</span> <span class="nav-text">customizeBeanFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD-Bean-loadBeanDefinitions"><span class="nav-number">7.2.3.</span> <span class="nav-text">加载 Bean: loadBeanDefinitions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C-Bean"><span class="nav-number">7.2.3.1.</span> <span class="nav-text">注册 Bean</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean-%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%8C%E6%88%90%E5%90%8E"><span class="nav-number">7.3.</span> <span class="nav-text">Bean 容器实例化完成后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87-Bean-%E5%AE%B9%E5%99%A8-prepareBeanFactory"><span class="nav-number">7.4.</span> <span class="nav-text">准备 Bean 容器: prepareBeanFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E7%9A%84-singleton-beans"><span class="nav-number">7.5.</span> <span class="nav-text">初始化所有的 singleton beans</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getBean"><span class="nav-number">7.5.1.</span> <span class="nav-text">getBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Bean"><span class="nav-number">7.5.2.</span> <span class="nav-text">创建 Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Bean-%E5%AE%9E%E4%BE%8B"><span class="nav-number">7.5.2.1.</span> <span class="nav-text">创建 Bean 实例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-%E7%9A%84%E5%AE%8C%E6%95%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">8.</span> <span class="nav-text">Bean 的完整生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Spring%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">9.</span> <span class="nav-text">谈谈你对 Spring的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF-Spring-IOC-%E5%AE%B9%E5%99%A8%EF%BC%9F%E2%AD%90"><span class="nav-number">10.</span> <span class="nav-text">IOC 是什么，什么是 Spring IOC 容器？⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IoC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E2%AD%90"><span class="nav-number">10.1.</span> <span class="nav-text">IoC 的实现机制&#x2F;初始化流程⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Bean"><span class="nav-number">10.2.</span> <span class="nav-text">Spring Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Bean%EF%BC%9F"><span class="nav-number">10.2.1.</span> <span class="nav-text">什么是 Spring Bean？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88scope%EF%BC%89"><span class="nav-number">10.2.2.</span> <span class="nav-text">Bean 的作用域（scope）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E2%AD%90"><span class="nav-number">10.2.3.</span> <span class="nav-text">Bean 的生命周期⭐</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.</span> <span class="nav-text">常见扩展接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">11.1.</span> <span class="nav-text">Spring的后置处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-bean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">11.2.</span> <span class="nav-text">spring 自动装配 bean 有哪些方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext%E5%92%8CBeanFactory%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="nav-number">11.3.</span> <span class="nav-text">ApplicationContext和BeanFactory的区别⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">12.</span> <span class="nav-text">循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90"><span class="nav-number">12.1.</span> <span class="nav-text">循环依赖是什么？⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F%E2%AD%90"><span class="nav-number">12.2.</span> <span class="nav-text">Spring 如何解决循环依赖？⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP"><span class="nav-number">13.</span> <span class="nav-text">AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF-AOP%EF%BC%9F"><span class="nav-number">13.1.</span> <span class="nav-text">解释一下什么是 AOP？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89%E2%AD%90"><span class="nav-number">14.</span> <span class="nav-text">AOP 的原理（重要）⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="nav-number">15.</span> <span class="nav-text">JDK 动态代理和 CGLIB 的区别⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">15.1.</span> <span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AspectJ-%E5%92%8C-Spring-AOP"><span class="nav-number">16.</span> <span class="nav-text">AspectJ 和 Spring AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">16.1.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springAOP-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">17.</span> <span class="nav-text">springAOP 项目中的实际应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC"><span class="nav-number">18.</span> <span class="nav-text">SpringMVC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Springmvc-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E7%9A%84%E6%B5%81%E7%A8%8B%E2%AD%90"><span class="nav-number">19.</span> <span class="nav-text">Springmvc 请求处理的流程⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Springmvc-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6"><span class="nav-number">19.1.</span> <span class="nav-text">Springmvc 有哪些组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="nav-number">20.</span> <span class="nav-text">常用注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">Spring 框架中用到了哪些设计模式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%BA%8B%E5%8A%A1"><span class="nav-number">22.</span> <span class="nav-text">Spring 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="nav-number">22.1.</span> <span class="nav-text">Spring 管理事务的方式有几种？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E2%AD%90"><span class="nav-number">23.</span> <span class="nav-text">事务注解@Transactional实现机制⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Transactional-rollbackFor-Exception-class-%E6%B3%A8%E8%A7%A3"><span class="nav-number">23.1.</span> <span class="nav-text">@Transactional(rollbackFor &#x3D; Exception.class)注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA-%E6%9C%BA%E5%88%B6%E2%AD%90"><span class="nav-number">24.</span> <span class="nav-text">事务传播行为&#x2F;机制⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-%E7%9A%84%E5%AE%8C%E6%95%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2"><span class="nav-number">25.</span> <span class="nav-text">Bean 的完整生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Boot%EF%BC%9F"><span class="nav-number">25.1.</span> <span class="nav-text">什么是 Spring Boot？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot-%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">25.2.</span> <span class="nav-text">Spring Boot 的优点是什么?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E2%AD%90"><span class="nav-number">26.</span> <span class="nav-text">Spring Boot 启动流程⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="nav-number">26.1.</span> <span class="nav-text">Spring Boot提供了两种常用的配置文件：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F%E2%AD%90"><span class="nav-number">27.</span> <span class="nav-text">Spring Boot 的核心注解是哪个？⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E2%AD%90"><span class="nav-number">28.</span> <span class="nav-text">Spring Boot 自动配置原理是什么⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot%E3%80%81SpringMVC%E5%92%8CSpring%E5%8C%BA%E5%88%AB"><span class="nav-number">28.1.</span> <span class="nav-text">SpringBoot、SpringMVC和Spring区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">29.</span> <span class="nav-text">SpringBoot 拦截器和过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-boot%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">30.</span> <span class="nav-text">spring boot处理一个http请求的全过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">Spring 的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">Spring 的设计理念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">核心组件如何协同工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">核心组件详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean-%E7%BB%84%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">Bean 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean-%E5%B7%A5%E5%8E%82"><span class="nav-number">2.1.1.</span> <span class="nav-text">Bean 工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanDefinition"><span class="nav-number">2.1.2.</span> <span class="nav-text">BeanDefinition</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context-%E7%BB%84%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">Context 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Core-%E7%BB%84%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">Core 组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-BeanFactory-%E5%B7%A5%E5%8E%82"><span class="nav-number">3.</span> <span class="nav-text">创建 BeanFactory 工厂</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bean-%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">Bean 实例创建流程图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ioc-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%89%A9%E5%B1%95%E7%82%B9"><span class="nav-number">3.1.</span> <span class="nav-text">Ioc 容器的扩展点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">Spring 中设计模式分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">多线程面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90"><span class="nav-number">1.</span> <span class="nav-text">线程和进程的区别？⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">进程间通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">线程通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%844%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E2%AD%90"><span class="nav-number">3.1.</span> <span class="nav-text">死锁的4个必要条件⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%98%AF%E5%90%A6%E6%9C%89%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F-%E2%AD%90"><span class="nav-number">4.</span> <span class="nav-text">如何分析是否有线程死锁？ ⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">5.</span> <span class="nav-text">理解线程的同步与异步、阻塞与非阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">创建线程有哪几种方式，如何实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">runnable 和 callable 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="nav-number">8.</span> <span class="nav-text">sleep和wait的区别⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">notify()和 notifyAll()有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">线程的 run()和 start()有什么区别？&#x2F;为什么不能直接调用 run() 方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="nav-number">11.</span> <span class="nav-text">线程的生命周期和状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89%E2%AD%90"><span class="nav-number">12.</span> <span class="nav-text">线程的各种状态的切换（重要）⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">有哪几种实现生产者消费者模式的方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2-%E2%AD%90"><span class="nav-number">14.</span> <span class="nav-text">什么是上下文切换?⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">创建线程池ThreadPoolExecutor有哪几种方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="nav-number">16.</span> <span class="nav-text">线程池都有哪些状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E2%AD%90"><span class="nav-number">17.</span> <span class="nav-text">线程池核心参数⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E2%AD%90"><span class="nav-number">17.1.</span> <span class="nav-text">线程池的拒绝策略⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="nav-number">18.</span> <span class="nav-text">如何向线程池提交任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8Cexecute-%E6%96%B9%E6%B3%95%E5%92%8Csubmit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">执行execute()方法和submit()方法的区别是什么呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">线程池常用的阻塞队列？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%89%E5%85%A8-%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95%E2%AD%90"><span class="nav-number">21.</span> <span class="nav-text">怎么保证多线程的运行安全&#x2F;保证线程安全的方法⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%BD%E5%8F%AF%E8%83%BD%E6%8F%90%E9%AB%98%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">如何尽可能提高多线程并发性能？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E2%AD%90"><span class="nav-number">23.</span> <span class="nav-text">为什么要使用线程池⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BB%A1%E4%BA%86%EF%BC%8C%E5%BE%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E5%85%B7%E4%BD%93%E5%88%86%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">24.</span> <span class="nav-text">线程池满了，往线程池里提交任务会发生什么样的情况，具体分几种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86-%E6%AD%A5%E9%AA%A4%E2%AD%90"><span class="nav-number">25.</span> <span class="nav-text">向线程池提交一个线程的原理&#x2F;步骤⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7-%E2%AD%90"><span class="nav-number">25.1.</span> <span class="nav-text">如何指定多个线程的执行顺序&#x2F; 如何控制线程池线程的优先级 ⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A"><span class="nav-number">25.2.</span> <span class="nav-text">线程池的线程数量怎么确定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-number">26.</span> <span class="nav-text">常用的线程分析工具与方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E4%BD%9C%E7%94%A8%E2%AD%90"><span class="nav-number">27.</span> <span class="nav-text">volatile作用⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">Java 中是如何实现线程同步的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#i-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">i++是线程安全的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-Synchronized"><span class="nav-number">30.</span> <span class="nav-text">介绍 Synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">31.</span> <span class="nav-text">Synchronized 的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK1-6-%E4%B9%8B%E5%90%8E%E7%9A%84synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E5%81%9A%E4%BA%86%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="nav-number">31.1.</span> <span class="nav-text">JDK1.6 之后的synchronized 关键字底层做了一些优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized%E4%B8%8ELock%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="nav-number">32.</span> <span class="nav-text">Synchronized与Lock的区别⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">乐观锁和悲观锁的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">33.0.1.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">33.0.2.</span> <span class="nav-text">乐观锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">如何实现一个乐观锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">35.</span> <span class="nav-text">ReentrantLock如何实现公平和非公平锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">JUC工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Atomic%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">Atomic类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">基本数据类型的原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic%E7%B1%BB%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E2%AD%90"><span class="nav-number">1.2.</span> <span class="nav-text">Atomic类如何保证原子性⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS-%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">CAS 可能会导致什么问题？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">0.1.</span> <span class="nav-text">ThreadLocal 实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">ThreadLocal用来解决什么问题？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">并发基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM%EF%BC%88Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">JMM（Java 内存模型）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomictiy%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">原子性（Atomictiy）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%88Visibility%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">可见性（Visibility）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%88Ordering%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">有序性（Ordering）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="nav-number">1.4.</span> <span class="nav-text">指令重排</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%A3%E4%BA%9B%E6%8C%87%E4%BB%A4%E4%B8%8D%E8%83%BD%E9%87%8D%E6%8E%92%EF%BC%9AHappen-Before-%E8%A7%84%E5%88%99"><span class="nav-number">1.5.</span> <span class="nav-text">那些指令不能重排：Happen-Before 规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="nav-number">2.</span> <span class="nav-text">线程中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InterruptedException"><span class="nav-number">2.1.</span> <span class="nav-text">InterruptedException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interrupted"><span class="nav-number">2.2.</span> <span class="nav-text">interrupted()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%EF%BC%88wait%EF%BC%89%E5%92%8C%E9%80%9A%E7%9F%A5%EF%BC%88notify%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">等待（wait）和通知（notify）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">4.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">volatile的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">5.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">synchronized 的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">synchronized 和 volatile 的区别是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">JDK 并发包（JUC）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%85%A5%E9%94%81-ReentrantLock"><span class="nav-number">1.</span> <span class="nav-text">重入锁 ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock%E7%9A%84%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">ReentrantLock的高级功能：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock-%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8C%85%E5%90%AB%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">ReentrantLock 的实现，包含三要素：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E6%90%AD%E6%A1%A3%EF%BC%9ACondition"><span class="nav-number">1.3.</span> <span class="nav-text">重入锁的搭档：Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="nav-number">1.4.</span> <span class="nav-text">信号量（Semaphore）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88ReadWriteLock%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">读写锁（ReadWriteLock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%92%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88CountDownLatch%EF%BC%89"><span class="nav-number">1.6.</span> <span class="nav-text">倒计数器（CountDownLatch）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F%EF%BC%88CyclicBarrier%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">循环栅栏（CyclicBarrier）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88LockSupport%EF%BC%89"><span class="nav-number">1.8.</span> <span class="nav-text">线程阻塞工具类（LockSupport）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">创建线程池的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">线程池实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">2.3.</span> <span class="nav-text">拒绝策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadFactory"><span class="nav-number">2.4.</span> <span class="nav-text">ThreadFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoin-%E6%A1%86%E6%9E%B6"><span class="nav-number">2.5.</span> <span class="nav-text">ForkJoin 框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">并发集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">CAS（乐观锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E8%AF%BB%E5%86%99%E7%9A%84%E9%98%9F%E5%88%97%EF%BC%9AConcurrentLinkedQueue"><span class="nav-number">3.2.</span> <span class="nav-text">高效读写的队列：ConcurrentLinkedQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E8%AF%BB%E5%8F%96%EF%BC%9ACopyOnWriteArrayList"><span class="nav-number">3.3.</span> <span class="nav-text">高效读取：CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E9%80%9A%E9%81%93%EF%BC%9ABlockingQueue"><span class="nav-number">3.4.</span> <span class="nav-text">数据共享通道：BlockingQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E9%94%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE"><span class="nav-number">4.1.</span> <span class="nav-text">提高锁性能的几点建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%AF%B9%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text">JVM对锁的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">4.2.1.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">4.2.2.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">4.2.3.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">4.2.4.</span> <span class="nav-text">锁消除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%EF%BC%88%E5%BE%85%E5%8A%9E%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">ThreadLocal （待办）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">4.4.</span> <span class="nav-text">死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">MySQL体系结构与存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">MySQL体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-2"><span class="nav-number">2.</span> <span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%82"><span class="nav-number">2.1.</span> <span class="nav-text">实例层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">2.2.</span> <span class="nav-text">物理层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">内存和物理结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Myisam%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.</span> <span class="nav-text">Myisam和InnoDB的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">InnoDB 核心要点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">深入理解事务与锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">事务及其特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">持久性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">1.4.</span> <span class="nav-text">隔离性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">并发事务控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E9%94%81"><span class="nav-number">2.1.</span> <span class="nav-text">单版本控制-锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-MVCC"><span class="nav-number">2.2.</span> <span class="nav-text">多版本控制-MVCC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">技术原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">原子性技术原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">持久性技术原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">隔离性技术原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="nav-number">3.4.</span> <span class="nav-text">一致性技术原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.</span> <span class="nav-text">MVCC 实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">4.</span> <span class="nav-text">并发事务问题及解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E7%9A%84%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">InnoDB 的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E8%87%AA%E5%A2%9E%E9%94%81"><span class="nav-number">5.1.</span> <span class="nav-text">InnoDB自增锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB-%E8%A1%8C%E9%94%81"><span class="nav-number">5.2.</span> <span class="nav-text">InnoDB 行锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E6%AD%BB%E9%94%81"><span class="nav-number">5.3.</span> <span class="nav-text">InnoDB死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E2%AD%90"><span class="nav-number">6.</span> <span class="nav-text">TCP&#x2F;IP四层网络模型⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E2%AD%90"><span class="nav-number">7.</span> <span class="nav-text">OSI七层网络模型⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="nav-number">8.</span> <span class="nav-text">简述 TCP 和 UDP 的区别⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E7%89%B9%E7%82%B9%E2%AD%90"><span class="nav-number">8.1.</span> <span class="nav-text">TCP 特点⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E9%87%8D%E7%82%B9-%E2%AD%90"><span class="nav-number">9.</span> <span class="nav-text">TCP 三次握手和四次挥手(重点)⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E2%AD%90"><span class="nav-number">10.</span> <span class="nav-text">为什么需要三次握手?⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A6%96%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E9%9A%90%E6%82%A3%E2%80%93SYN%E8%B6%85%E6%97%B6"><span class="nav-number">11.</span> <span class="nav-text">首次握手的隐患–SYN超时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%90%8E%EF%BC%8CClient%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">12.</span> <span class="nav-text">建立连接后，Client出现故障怎么办</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89%E2%AD%90"><span class="nav-number">13.</span> <span class="nav-text">TCP四次挥手（重点）⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E7%9A%84%E6%97%B6%E5%80%99%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E2%AD%90"><span class="nav-number">13.1.</span> <span class="nav-text">为什么连接的时候是三次握手，关闭的时候却是四次握手⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8FCLOSE-WAIT%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">13.1.1.</span> <span class="nav-text">服务器出现大量CLOSE_ WAIT状态的原因</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">14.</span> <span class="nav-text">UDP的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80-%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B%E2%AD%90"><span class="nav-number">15.</span> <span class="nav-text">在浏览器中输入url地址 -&gt;&gt; 显示主页的过程⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E2%AD%90"><span class="nav-number">16.</span> <span class="nav-text">HTTP状态码⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F-%E2%AD%90"><span class="nav-number">17.</span> <span class="nav-text">get 和 post 请求有哪些区别？ ⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie-%EF%BC%8CSession%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="nav-number">18.</span> <span class="nav-text">Cookie ，Session区别⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS"><span class="nav-number">19.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.0.1.</span> <span class="nav-text">HTTP和HTTPS的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket"><span class="nav-number">20.</span> <span class="nav-text">Socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">21.</span> <span class="nav-text">创建型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">21.1.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">21.2.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">21.3.</span> <span class="nav-text">抽象工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">21.4.</span> <span class="nav-text">单例模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">22.</span> <span class="nav-text">结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">22.1.</span> <span class="nav-text">代理模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">23.</span> <span class="nav-text">行为型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F"><span class="nav-number">23.1.</span> <span class="nav-text">模板模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">23.1.1.</span> <span class="nav-text">架构方法介绍</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">集合框架面试题和解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E3%80%81Set%E3%80%81Map-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">List、Set、Map 之间的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arraylist-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">Arraylist 与 LinkedList 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">ArrayList 和 Vector 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">ArrayList 的扩容机制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8C-List-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">如何实现数组和 List 之间的转换？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-%E5%92%8C-ArrayList-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">Array 和 ArrayList 有何区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">HashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-HashMap"><span class="nav-number">8.</span> <span class="nav-text">说说 HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">9.</span> <span class="nav-text">HashMap 的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="nav-number">10.</span> <span class="nav-text">HashMap 的长度为什么是2的幂次方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-HashMap-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%EF%BC%9F%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-0-75%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">什么是 HashMap 的加载因子？加载因子为什么是 0.75？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#put-%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">put 方法流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">13.</span> <span class="nav-text">HashMap 的扩容机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-8-%E5%9C%A8%E6%89%A9%E5%AE%B9%E6%96%B9%E9%9D%A2%E5%AF%B9-HashMap-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">13.0.1.</span> <span class="nav-text">JDK 1.8 在扩容方面对 HashMap 做了哪些优化？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-1-7%E5%92%8C1-8%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">HashMap 1.7和1.8版本区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8hashCode-%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E7%9B%B4%E6%8E%A5%E4%BD%9C%E4%B8%BAtable%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap1-7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F%E2%AD%90"><span class="nav-number">16.</span> <span class="nav-text">HashMap1.7为什么不安全？⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8BHashMap1-7%E7%9A%84%E7%8E%AF%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84"><span class="nav-number">16.0.1.</span> <span class="nav-text">高并发下HashMap1.7的环是如何产生的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E4%B8%ADString%E3%80%81Integer%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BAKey%EF%BC%9F%E2%AD%90"><span class="nav-number">17.</span> <span class="nav-text">为什么HashMap中String、Integer这样的包装类适合作为Key？⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%AD%90"><span class="nav-number">18.</span> <span class="nav-text">ConcurrentHashMap线程安全的实现方式&#x2F;数据结构⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">BlockingQueue是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-Queue-%E4%B8%AD-poll-%E5%92%8C-remove-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">在 Queue 中 poll()和 remove()有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">21.</span> <span class="nav-text">整体介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7"><span class="nav-number">22.</span> <span class="nav-text">JVM相关工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JMC%EF%BC%88Java-Mission-Control%EF%BC%89"><span class="nav-number">22.1.</span> <span class="nav-text">JMC（Java Mission Control）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git"><span class="nav-number">23.</span> <span class="nav-text">Git</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git%E5%91%BD%E4%BB%A4"><span class="nav-number">24.</span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">24.1.</span> <span class="nav-text">Git 工作流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-number">25.</span> <span class="nav-text">Linux 分析工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">高性能库表设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%BC%8F%E5%92%8C%E5%8F%8D%E8%8C%83%E5%BC%8F"><span class="nav-number">0.1.</span> <span class="nav-text">范式和反范式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E5%BC%8F"><span class="nav-number">0.1.1.</span> <span class="nav-text">范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F"><span class="nav-number">0.1.2.</span> <span class="nav-text">反范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E5%BC%8F%E4%B8%8E%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%BC%82%E5%90%8C"><span class="nav-number">0.1.3.</span> <span class="nav-text">范式与反范式异同</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99%E5%92%8C%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">1.</span> <span class="nav-text">MySQL 使用原则和设计规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%84%E8%8C%83%E5%91%BD%E5%90%8D"><span class="nav-number">1.2.</span> <span class="nav-text">规范命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.3.</span> <span class="nav-text">表创建的注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD%E8%A1%A8-%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%AD%89%E5%B8%B8%E8%A7%81%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">1.3.1.</span> <span class="nav-text">备份表&#x2F;临时表等常见表的设计规范</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E8%A6%81%E6%B1%82"><span class="nav-number">1.4.</span> <span class="nav-text">字段设计要求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">案例处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E5%A4%84%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">IP处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIMESTAMP%E5%A4%84%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">TIMESTAMP处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">高性能索引设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">索引概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">索引原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash-%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.</span> <span class="nav-text">Hash 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">Hash 索引的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash%E7%A2%B0%E6%92%9E%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.1.2.</span> <span class="nav-text">Hash碰撞的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Hash-%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">2.1.3.</span> <span class="nav-text">MySQL 中如何使用 Hash 索引？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree-%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.</span> <span class="nav-text">B+Tree 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">聚簇索引和辅助索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%92%8C%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">联合索引和覆盖索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="nav-number">3.</span> <span class="nav-text">索引使用技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%93%E8%AF%8D%E5%92%8C%E8%BF%87%E6%BB%A4%E5%9B%A0%E5%AD%90"><span class="nav-number">3.0.1.</span> <span class="nav-text">谓词和过滤因子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E5%92%8C%E9%80%89%E6%8B%A9%E7%8E%87"><span class="nav-number">3.0.2.</span> <span class="nav-text">基数和选择率</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="nav-number">4.</span> <span class="nav-text">索引使用细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95"><span class="nav-number">5.</span> <span class="nav-text">设计高性能索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E8%A7%84%E8%8C%83"><span class="nav-number">6.</span> <span class="nav-text">创建索引规范</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="nav-number">0.1.</span> <span class="nav-text">案例一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="nav-number">0.2.</span> <span class="nav-text">案例二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ICP-MRR-BKA"><span class="nav-number">0.3.</span> <span class="nav-text">ICP,MRR,BKA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="nav-number">1.</span> <span class="nav-text">MySQL执行计划分析三部曲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-number">2.</span> <span class="nav-text">查询相关参数和分析工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96SQL"><span class="nav-number">3.</span> <span class="nav-text">如何优化SQL</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Zhan"
      src="/notes.github.io/images/woshicaigou.jpg">
  <p class="site-author-name" itemprop="name">Chen Zhan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/notes.github.io/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Zhan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/notes.github.io/lib/anime.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/notes.github.io/js/utils.js"></script>

<script src="/notes.github.io/js/motion.js"></script>


<script src="/notes.github.io/js/schemes/pisces.js"></script>


<script src="/notes.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

</body>
</html>
