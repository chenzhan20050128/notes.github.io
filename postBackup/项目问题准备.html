<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/notes.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/notes.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/notes.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/notes.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/notes.github.io/css/main.css">


<link rel="stylesheet" href="/notes.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhan20050128.github.io","root":"/notes.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="索引 一、索引类型分类  普通索引 (Standard Index) 用户表(users)  idx_users_username: 普通索引 idx_users_email: 普通索引 idx_users_telephone: 普通索引 商品表(products) idx_products_title: 普通索引 idx_products_price: 普通索引 idx_products_rat">
<meta property="og:type" content="website">
<meta property="og:title" content="项目问题准备">
<meta property="og:url" content="https://chenzhan20050128.github.io/notes.github.io/postBackup/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87.html">
<meta property="og:site_name" content="cz Blog">
<meta property="og:description" content="索引 一、索引类型分类  普通索引 (Standard Index) 用户表(users)  idx_users_username: 普通索引 idx_users_email: 普通索引 idx_users_telephone: 普通索引 商品表(products) idx_products_title: 普通索引 idx_products_price: 普通索引 idx_products_rat">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-23T04:27:03.000Z">
<meta property="article:modified_time" content="2025-06-23T04:27:03.415Z">
<meta property="article:author" content="Chen Zhan">
<meta property="article:tag" content="其他">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chenzhan20050128.github.io/notes.github.io/postBackup/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>项目问题准备 | cz Blog
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/notes.github.io/atom.xml" title="cz Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/notes.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cz Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/notes.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/notes.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/chenzhan20050128" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">项目问题准备
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <h2 id="索引">索引</h2>
<p>一、索引类型分类</p>
<ol>
<li>普通索引 (Standard Index)<br>
用户表(users)</li>
</ol>
<p>idx_users_username: 普通索引</p>
<p>idx_users_email: 普通索引</p>
<p>idx_users_telephone: 普通索引</p>
<p>商品表(products)</p>
<p>idx_products_title: 普通索引</p>
<p>idx_products_price: 普通索引</p>
<p>idx_products_rate: 普通索引</p>
<p>库存表(stockpiles)</p>
<p>idx_stockpiles_amount: 普通索引</p>
<ol start="2">
<li>外键索引 (Foreign Key Index)<br>
规格表(specifications)</li>
</ol>
<p>idx_specifications_product_id: 外键索引</p>
<p>库存表(stockpiles)</p>
<p>idx_stockpiles_product_id: 外键索引</p>
<p>广告表(advertisements)</p>
<p>idx_product_id: 外键索引</p>
<ol start="3">
<li>复合索引 (Composite Index)<br>
规格表(specifications)</li>
</ol>
<p>idx_specifications_item_value: 复合索引(item, value)</p>
<p>购物车表(carts)</p>
<p>idx_carts_user_product: 复合索引(user_id, product_id)</p>
<ol start="4">
<li>唯一索引 (已存在)<br>
用户表(users)</li>
</ol>
<p>telephone字段已定义为UNIQUE，自动创建唯一索引</p>
<p>二、各类索引的得失分析</p>
<ol>
<li>普通索引<br>
优点:</li>
</ol>
<p>加速WHERE条件查询</p>
<p>提高ORDER BY排序效率</p>
<p>支持覆盖索引查询(当查询只包含索引列时)</p>
<p>缺点:</p>
<p>占用额外存储空间</p>
<p>降低INSERT/UPDATE/DELETE速度(需要维护索引)</p>
<p>可能导致优化器选择不理想的执行计划</p>
<p>适用场景:</p>
<p>高频查询条件字段</p>
<p>需要排序或分组的字段</p>
<p>选择性高的字段(不同值多的字段)</p>
<ol start="2">
<li>外键索引<br>
优点:</li>
</ol>
<p>加速表连接操作</p>
<p>保证参照完整性</p>
<p>优化关联查询性能</p>
<p>缺点:</p>
<p>增加外键约束检查开销</p>
<p>可能影响批量导入性能</p>
<p>级联操作可能带来性能问题</p>
<p>适用场景:</p>
<p>所有外键关系字段都应建立</p>
<p>频繁进行JOIN操作的表</p>
<ol start="3">
<li>复合索引<br>
优点:</li>
</ol>
<p>支持多列组合查询</p>
<p>可以实现索引覆盖</p>
<p>减少单列索引数量</p>
<p>缺点:</p>
<p>列顺序很重要，设计不当会失效</p>
<p>只对最左前缀有效</p>
<p>占用更多空间</p>
<p>适用场景:</p>
<p>经常同时查询多个字段</p>
<p>有固定查询模式的场景</p>
<p>需要覆盖索引优化查询</p>
<h3 id="一、阿里巴巴手册对外键的建议">一、阿里巴巴手册对外键的建议</h3>
<p>阿里巴巴《Java开发手册》确实建议：</p>
<ol>
<li><strong>不要使用数据库外键约束</strong>（FOREIGN KEY constraint）</li>
<li><strong>但需要建立外键索引</strong>（即在外键字段上创建普通索引）</li>
</ol>
<h3 id="原因分析：">原因分析：</h3>
<ol>
<li>
<p><strong>外键约束的缺点</strong>：</p>
<ul>
<li>性能开销：每次DML操作都需要检查外键约束</li>
<li>并发问题：容易引发死锁</li>
<li>扩展困难：分库分表时难以维护外键关系</li>
<li>耦合度高：业务逻辑与数据强耦合</li>
</ul>
</li>
<li>
<p><strong>外键索引的优点</strong>：</p>
<ul>
<li>提高JOIN查询性能</li>
<li>保证查询优化器能选择最优执行计划</li>
<li>不引入约束检查的开销</li>
</ul>
</li>
</ol>
<h3 id="二、外键索引的原理">二、外键索引的原理</h3>
<h3 id="1-基本工作原理">1. 基本工作原理</h3>
<p>外键索引本质上是一个普通的B+树索引，只是它建立在外键字段上，用于：</p>
<ul>
<li>加速表连接操作</li>
<li>优化关联查询</li>
<li>支持嵌套循环连接(Nested Loop Join)算法</li>
</ul>
<h3 id="2-与有约束外键的区别">2. 与有约束外键的区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>有约束的外键</th>
<th>外键索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>分库分表兼容性</td>
<td>难以实现</td>
<td>容易实现</td>
</tr>
<tr>
<td>约束检查</td>
<td>有，保证数据完整性</td>
<td>无</td>
</tr>
<tr>
<td>存储结构</td>
<td>约束+索引</td>
<td>纯索引</td>
</tr>
<tr>
<td>级联操作</td>
<td>支持CASCADE/SET NULL等</td>
<td>不支持</td>
</tr>
<tr>
<td>性能影响</td>
<td>DML操作有额外开销</td>
<td>只有查询优化</td>
</tr>
</tbody>
</table>
<h3 id="3-索引选择算法">3. 索引选择算法</h3>
<p>当执行JOIN查询时，优化器会：</p>
<ol>
<li>检查连接字段是否有索引</li>
<li>评估不同连接算法(Nested Loop, Hash Join, Merge Join)的成本</li>
<li>优先选择有索引的字段作为驱动表</li>
</ol>
<h3 id="三、实际应用建议">三、实际应用建议</h3>
<h3 id="1-应该建立外键索引的情况">1. 应该建立外键索引的情况</h3>
<ul>
<li>所有需要JOIN的关联字段</li>
<li>高频查询的关联条件</li>
<li>OLTP系统中核心业务表的关联字段</li>
</ul>
<h3 id="2-不建议建立的情况">2. 不建议建立的情况</h3>
<ul>
<li>极少参与查询的关联字段</li>
<li>数据量极小(如配置表)的关联</li>
<li>写多读少的场景</li>
</ul>
<h3 id="3-最佳实践示例">3. 最佳实践示例</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不建议（添加外键约束）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> orders <span class="keyword">ADD CONSTRAINT</span> fk_user_id <span class="keyword">FOREIGN KEY</span> (user_id) <span class="keyword">REFERENCES</span> users(user_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建议（只创建外键索引）</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_orders_user_id <span class="keyword">ON</span> orders(user_id);</span><br></pre></td></tr></table></figure>
<h3 id="四、性能影响对比">四、性能影响对比</h3>
<h3 id="1-有外键约束时">1. 有外键约束时</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入订单时需要检查用户是否存在</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> orders(user_id, ...) <span class="keyword">VALUES</span> (<span class="number">100</span>, ...);</span><br><span class="line"><span class="comment">-- 数据库需要执行：</span></span><br><span class="line"><span class="comment">-- 1. 检查users表中是否存在user_id=100的记录</span></span><br><span class="line"><span class="comment">-- 2. 如果不存在则拒绝插入</span></span><br><span class="line"><span class="comment">-- 3. 如果存在则完成插入</span></span><br></pre></td></tr></table></figure>
<h3 id="2-只有外键索引时">2. 只有外键索引时</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入订单时没有约束检查</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> orders(user_id, ...) <span class="keyword">VALUES</span> (<span class="number">100</span>, ...);</span><br><span class="line"><span class="comment">-- 数据库只需：</span></span><br><span class="line"><span class="comment">-- 1. 直接插入数据</span></span><br><span class="line"><span class="comment">-- 2. 更新索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询时仍能高效JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">JOIN</span> users <span class="keyword">ON</span> orders.user_id <span class="operator">=</span> users.user_id;</span><br><span class="line"><span class="comment">-- 可以使用orders.user_id上的索引加速连接</span></span><br></pre></td></tr></table></figure>
<h3 id="五、总结">五、总结</h3>
<ol>
<li><strong>外键索引≠外键约束</strong>：前者是性能优化手段，后者是数据完整性机制</li>
<li><strong>互联网应用推荐做法</strong>：
<ul>
<li>应用层维护数据一致性</li>
<li>数据库层建立外键索引优化查询</li>
<li>避免使用数据库外键约束</li>
</ul>
</li>
<li><strong>索引选择原则</strong>：
<ul>
<li>评估查询模式</li>
<li>监控索引使用情况</li>
<li>定期优化冗余索引</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>算法</th>
<th>有无索引要求</th>
<th>时间复杂度</th>
<th>内存消耗</th>
<th>适用场景</th>
<th>外键索引优势</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Nested Loop</strong></td>
<td>内表连接字段需索引</td>
<td>O(M * log N)</td>
<td>低</td>
<td>中小表连接，驱动表小</td>
<td>大幅降低内表查找成本</td>
</tr>
<tr>
<td><strong>Hash Join</strong></td>
<td>无需索引</td>
<td>O(M + N)</td>
<td>高</td>
<td>大表等值连接，无索引场景</td>
<td>无直接优势</td>
</tr>
<tr>
<td><strong>Merge Join</strong></td>
<td>两表都需有序</td>
<td>O(M + N)</td>
<td>低</td>
<td>已排序的大表连接</td>
<td>间接优势（索引可帮助排序）</td>
</tr>
</tbody>
</table>
<h2 id="Caffeine">Caffeine</h2>
<p>一、Caffeine 核心原理</p>
<ol>
<li>整体架构<br>
Caffeine 是一个高性能的 Java 缓存库，基于 Google Guava 缓存 API 重新设计，具有以下核心组件：</li>
</ol>
<p>哈希表：使用并发哈希表存储缓存条目</p>
<p>访问队列：维护 LRU (最近最少使用) 顺序</p>
<p>写入队列：维护写入顺序</p>
<p>淘汰策略：基于大小、时间和引用类型的组合策略</p>
<ol start="2">
<li>缓存淘汰算法<br>
Caffeine 采用 Window TinyLFU 算法，结合了：</li>
</ol>
<p>TinyLFU：频率草图(count-min sketch)统计访问频率</p>
<p>LRU：保留最近访问的项目</p>
<p>分段缓存：分为主缓存区、保护区和边缓存区</p>
<ol start="3">
<li>并发控制<br>
使用 Striped 非阻塞数据结构</li>
</ol>
<p>读写分离设计</p>
<p>无锁并发优化</p>
<h1>问题群 2: 业务逻辑与服务层实现</h1>
<h2 id="1-基础问题-请简要描述一下订单服务的功能和流程。">1. <strong>基础问题</strong>: 请简要描述一下订单服务的功能和流程。</h2>
<p>核心流程：</p>
<p>​用户结算：从购物车中选择商品，触发 /api/cart/checkout 接口。<br>
​创建订单：生成订单并预占库存（OrderService.createOrder()）。<br>
​支付跳转：调用支付宝接口生成支付页面（OrderController.pay()）。<br>
​异步回调：支付宝回调通知支付结果（OrderController.payNotify()）。<br>
​状态更新：根据回调更新订单状态为“支付成功”并扣减库存。<br>
​超时释放：通过 RabbitMQ 延迟队列自动释放超时订单的库存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OrderController 中的支付跳转逻辑</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/&#123;orderId&#125;/pay&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="meta">@PathVariable</span> Integer orderId, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getOrderById(orderId);</span><br><span class="line">    <span class="comment">// 生成支付宝支付链接并返回给前端</span></span><br><span class="line">    <span class="type">AlipayClient</span> <span class="variable">alipayClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(...);</span><br><span class="line">    <span class="type">AlipayTradePagePayRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePagePayRequest</span>();</span><br><span class="line">    request.setBizContent(...); <span class="comment">// 封装订单信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">form</span> <span class="operator">=</span> alipayClient.pageExecute(request).getBody();</span><br><span class="line">    response.getWriter().write(form); <span class="comment">// 返回支付页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>问题群 3: 缓存策略与使用</h1>
<ol>
<li><strong>基础问题</strong>: 你在项目中使用了哪些缓存技术？它们的作用是什么？</li>
</ol>
<p>答案：<br>
项目中使用了 ​Redis 和 ​Caffeine 两种缓存技术：</p>
<p>​Redis：<br>
​作用：作为分布式缓存，存储高频访问数据（如广告信息、商品详情），支持跨服务节点的数据共享和一致性。<br>
​代码体现：RedisConfig 中配置了多个 RedisTemplate（如 advertisementRedisTemplate 和 productRedisTemplate），用于不同类型数据的序列化。<br>
​Caffeine：<br>
​作用：作为本地缓存（JVM 级别），缓存访问频率极高的数据（如广告元数据），减少 Redis 的网络开销。<br>
​代码体现：CacheConfig 中配置了 Caffeine 缓存管理器，设置容量和过期时间。<br>
​Redisson：<br>
​作用：提供分布式锁（如 RLock），防止缓存击穿。<br>
​代码体现：RedissonConfig 中初始化 RedissonClient。</p>
<ol>
<li>
<p><strong>深入问题</strong>: 请解释一下你是如何实现缓存穿透的防护的？使用了哪些策略？</p>
</li>
<li>
<p><strong>优化问题</strong>: 在缓存失效时，你如何使用分布式锁来防止缓存击穿？具体的实现是什么样的？</p>
</li>
<li>
<p><strong>复杂问题</strong>: 你能描述一下在预热缓存时的具体步骤吗？为什么要定期更新缓存？</p>
</li>
<li>
<p><strong>进一步挖掘</strong>: 对于缓存的命中率，你如何进行监控和分析？如果发现缓存命中率低，你会采取什么措施？</p>
<p>经过测试：在10000并发请求下还能保证错误率为0<br>
以下为原理：<br>
1. 缓存穿透防护<br>
空值缓存：当数据库查询结果为空时，缓存空列表（Collections.emptyList()），并设置较短的TTL（NULL_CACHE_TTL）。避免恶意请求穿透缓存直接访问数据库。<br>
双重检查锁：在未命中缓存时，通过分布式锁控制仅一个线程查询数据库，其他线程等待或降级，防止并发穿透。</p>
</li>
<li>
<p>缓存击穿防护<br>
分布式锁（Redisson）：使用 RLock 实现分布式锁，确保缓存失效时仅一个线程重建数据。<br>
非阻塞锁竞争：通过 tryLock(100ms) 控制锁等待时间，避免线程长时间阻塞，超时后触发降级逻辑，保障可用性。</p>
</li>
<li>
<p>缓存雪崩防护<br>
分片存储与随机TTL：将数据分片为多个键（如 PRODUCT_LIST_CACHE_KEY::chunk_0），每个分片设置基础TTL加随机偏移值（ThreadLocalRandom.current().nextInt(30_000)），避免所有缓存同时失效。<br>
异步批量写入：使用Redis Pipeline批量写入分片数据，减少网络开销，提升性能。</p>
</li>
<li>
<p>高并发查询优化<br>
分页加载数据库：通过分页查询（Pageable）避免单次大数据量查询导致数据库或内存压力。<br>
异步缓存重建：主线程返回数据后异步执行缓存重建，减少用户请求延迟，通过分片存储和Pipeline写入提升效率。</p>
</li>
<li>
<p>降级与回退策略<br>
锁超时降级：若获取锁失败或超时（如100ms内未获得锁），直接查询数据库并返回部分数据（如 PageRequest.of(0, 100)），避免系统雪崩。<br>
异常捕获：捕获分布式锁和缓存操作异常，降级到数据库查询，确保最终可用性。</p>
</li>
</ol>
<p>代码逻辑：</p>
<p><strong>1. 构建缓存 Key:</strong></p>
<ul>
<li>1.1 根据商品 <code>id</code> 构建 Redis 缓存 Key: <code>PRODUCT_CACHE_KEY + id</code></li>
</ul>
<p><strong>2. 尝试从缓存中获取:</strong></p>
<ul>
<li>
<p>2.1 使用 <code>productRedisTemplate.opsForValue().get(key)</code> 从 Redis 缓存中获取 <code>Product</code> 对象。</p>
</li>
<li>
<p>2.2 <strong>如果缓存命中:</strong></p>
<ul>
<li>2.2.1 <strong>空值判断:</strong>
<ul>
<li>2.2.1.1 检查 <code>product.getId() == -1</code></li>
<li>2.2.1.2 如果是 <code>true</code> (空值):
<ul>
<li>记录日志: “命中空值缓存，商品ID：{}”</li>
<li>返回 <code>null</code> (防止缓存穿透)</li>
</ul>
</li>
</ul>
</li>
<li>2.2.2 <strong>正常缓存:</strong>
<ul>
<li>2.2.2.1 如果 <code>product.getId() != -1</code>
<ul>
<li>记录日志: “从缓存中获取商品信息，商品ID：{}”</li>
<li>返回 <code>product</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>2.3 <strong>如果缓存未命中:</strong></p>
<ul>
<li>进入步骤 3 (从数据库加载)</li>
</ul>
</li>
</ul>
<p><strong>3. 防止缓存击穿 (使用分布式锁):</strong></p>
<ul>
<li>
<p>3.1 获取分布式锁: 使用 Redisson 获取名为 <code>&quot;product_lock_&quot; + id</code> 的锁</p>
</li>
<li>
<p>3.2 尝试获取锁:  <code>lock.lock()</code></p>
</li>
<li>
<p>3.3 <strong>双重检查:</strong> (获取锁后再次检查缓存)</p>
<ul>
<li>3.3.1 再次使用 <code>productRedisTemplate.opsForValue().get(key)</code> 从 Redis 获取 Product</li>
<li>3.3.2 <strong>如果缓存命中:</strong>
<ul>
<li>记录日志: “从缓存中获取商品信息，商品ID：{}”</li>
<li>返回 <code>product</code></li>
</ul>
</li>
<li>3.3.3 <strong>如果缓存仍然未命中:</strong>
<ul>
<li>进入步骤 4 (从数据库加载)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>4. 从数据库加载数据:</strong></p>
<ul>
<li>4.1 调用 <code>productRepository.findByIdWithSpecifications(id)</code> 从数据库获取 <code>Product</code> 对象</li>
</ul>
<p><strong>5. 处理数据库查询结果:</strong></p>
<ul>
<li>
<p>5.1 <strong>如果数据库中不存在该商品 (<code>product == null</code>):</strong></p>
<ul>
<li>5.1.1 <strong>防止缓存穿透:</strong>
<ul>
<li>创建一个新的 <code>Product</code> 对象</li>
<li>设置 <code>product.setId(-1)</code> (标记为空值)</li>
<li><code>productRedisTemplate.opsForValue().set(key, product, NULL_CACHE_TTL)</code> (缓存空值并设置过期时间)</li>
<li>记录日志: “缓存空值，商品ID：{}”</li>
<li>返回 <code>null</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>5.2 <strong>如果数据库中存在该商品 (<code>product != null</code>):</strong></p>
<ul>
<li>5.2.1 <strong>防止缓存雪崩:</strong>
<ul>
<li>计算随机过期时间:  <code>randomTtl = CACHE_TTL.toMillis() + (long)(Math.random() * 60000)</code></li>
</ul>
</li>
<li>5.2.2 <code>productRedisTemplate.opsForValue().set(key, product, randomTtl, TimeUnit.MILLISECONDS)</code> (将商品信息存入缓存并设置随机过期时间)</li>
<li>记录日志: “将商品信息存入缓存，商品ID：{}”</li>
<li>返回 <code>product</code></li>
</ul>
</li>
</ul>
<p><strong>6. 释放锁:</strong></p>
<ul>
<li>6.1  在 <code>finally</code> 块中执行 <code>lock.unlock()</code> (确保锁始终被释放，避免死锁)</li>
</ul>
<p><strong>空值缓存</strong>实现简单，能精确判断数据是否存在，但内存消耗不可控，易受恶意攻击，适合小型系统。<br>
<strong>布隆过滤器</strong>内存效率高，抗攻击性强，但存在误判率，数据更新复杂，适合大型系统。</p>
<p>实际应用中，<strong>建议采用组合方案：布隆过滤器 + 空值缓存 + 分布式锁</strong>，构建多层防御体系。</p>
<p><strong>选型策略方面：</strong></p>
<ul>
<li><strong>小型系统、高一致性要求：</strong> 优先使用空值缓存 + 分布式锁。</li>
<li><strong>大型系统、高并发随机Key攻击风险：</strong> 必须引入布隆过滤器，建议组合使用。</li>
<li><strong>金融级系统：</strong> 可考虑使用支持删除操作的。</li>
<li><strong>超高并发场景：</strong> 在Nginx层添加Lua + Bloom Filter实现前置拦截。</li>
</ul>
<p><strong>生产环境建议：</strong></p>
<ul>
<li><strong>监控告警：</strong> 监控Redis内存使用率（空值缓存）和误判率（布隆过滤器）。</li>
<li><strong>兜底策略：</strong> 始终保留空值缓存作为最后防线。</li>
<li><strong>过滤器优化：</strong> 使用Redisson的RBloomFilter或布谷鸟过滤器。</li>
<li><strong>冷启动方案：</strong> 分批次异步加载数据到过滤器。</li>
</ul>
<h2 id="JWT">JWT</h2>
<p>JWT结构： 由Header、Payload和Signature三部分组成。Header和Payload可解码，但Signature是防篡改的关键。<br>
防篡改机制： JWT通过Signature来防止Payload被篡改。篡改Payload会导致Signature无效，服务器会拒绝该Token。用户无法在不知道密钥的情况下生成有效的Signature。<br>
加密类型：<br>
对称加密 (HMAC + SHA256)： 使用同一密钥签名和验证，速度快但密钥共享存在安全风险。<br>
非对称加密 (RSA/ECDSA)： 使用私钥签名，公钥验证，安全性更高但计算开销更大。<br>
实践建议：<br>
客户端只需验证Token的场景 (API访问) 推荐使用非对称加密。<br>
内部服务间通信可考虑使用对称加密。<br>
务必安全存储密钥。<br>
敏感信息不要放在Payload中。</p>
<h2 id="问题群-5-消息队列与异步处理">问题群 5: 消息队列与异步处理</h2>
<ol>
<li><strong>基础问题</strong>: 请简要介绍一下你在项目中使用的消息队列技术。</li>
<li><strong>深入问题</strong>: 在订单处理中，为什么选择使用消息队列？它带来了哪些好处？</li>
<li><strong>优化问题</strong>: 如何确保消息的可靠性和顺序性？你在实现中考虑了哪些细节？</li>
<li><strong>复杂问题</strong>: 如果消费者处理消息失败，系统会如何恢复？你在设计中是否考虑了死信队列？</li>
<li><strong>进一步挖掘</strong>: 请描述一下如何使用RabbitMQ实现延迟队列？在实际应用中遇到了哪些挑战？</li>
</ol>
<p>库存释放机制<br>
主要机制：OrderTimeoutConsumer 监听延迟队列，超时后调用 handleExpiredOrder 释放库存。</p>
<p>兜底机制：ScheduledTask 定时扫描过期订单，防止消息丢失或处理失败。</p>
<p>冗余设计：确保极端情况下（如 RabbitMQ 宕机）仍能通过定时任务恢复。</p>
<h2 id="Redis-AND-Caffeine">Redis AND Caffeine</h2>
<h2 id="1-数据访问特性">1. 数据访问特性</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Caffeine（本地）</th>
<th>Redis（分布式）</th>
</tr>
</thead>
<tbody>
<tr>
<td>延迟</td>
<td>&lt; 1 μs（纯内存，无网络）</td>
<td>≈ 0.2–2 ms（网络＋内存）</td>
</tr>
<tr>
<td>吞吐</td>
<td>极高（线程局部，几百万 QPS）</td>
<td>高（依赖网络、单线程事件循环）</td>
</tr>
<tr>
<td>容量</td>
<td>受单机 JVM 堆内存限制（几十 MB–几 GB）</td>
<td>水平可扩展，受集群内存限制</td>
</tr>
<tr>
<td>一致性／共享</td>
<td>不支持跨实例共享，只在同一 JVM 内可见</td>
<td>多客户端／多实例可见，天然分布式</td>
</tr>
<tr>
<td>持久化</td>
<td>不支持；JVM 重启即空</td>
<td>支持 RDB/AOF 持久化</td>
</tr>
<tr>
<td>高级数据结构</td>
<td>仅简单 Key→Value</td>
<td>list、set、zset、hash、stream、bitmaps、geospatial…</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="2-适用场景">2. 适用场景</h2>
<h3 id="2-1-当选-Caffeine">2.1 当选 Caffeine</h3>
<ul>
<li><strong>单机或无须跨实例共享</strong>
<ul>
<li>方法结果缓存（<code>@Cacheable</code> 场景）：计算密集型、重复调用的纯函数（如费率限流、业务规则校验等）。</li>
<li>配置／元数据、白名单、字典表等小体量静态参照。</li>
<li>热点数据，一秒内多次读写：如本地计数器、短期限流、短期重试次数。</li>
</ul>
</li>
<li><strong>超低延迟要求</strong>
<ul>
<li>频繁访问、毫秒级以下延迟场景，完全消除网络抖动。</li>
</ul>
</li>
<li><strong>资源隔离</strong>
<ul>
<li>避免所有缓存压力打到集中式 Redis，利用本地内存分摊热点。</li>
</ul>
</li>
<li><strong>SLA 容忍度低</strong>
<ul>
<li>即使 Redis 故障，服务本地缓存依然可用（降级模式）。</li>
</ul>
</li>
</ul>
<h3 id="2-2-当选-Redis">2.2 当选 Redis</h3>
<ul>
<li><strong>跨实例／跨进程共享</strong>
<ul>
<li>分布式 Session、统一权限信息、用户登录态集中管理。</li>
<li>分布式限流、漏桶／令牌桶全局计数器。</li>
</ul>
</li>
<li><strong>大容量或长生命周期</strong>
<ul>
<li>多 GB—TB 级别的数据缓存（商品图片元数据、大规模配置）。</li>
<li>缓存持久化后可冷启动。</li>
</ul>
</li>
<li><strong>复杂数据结构与功能</strong>
<ul>
<li>排行榜（Sorted Set）、消息队列（List/Stream）、社交关系（Set）、地理位置（GEO）。</li>
<li>发布/订阅、事务、Lua 脚本、Bitmaps/HyperLogLog 等。</li>
</ul>
</li>
<li><strong>高可用／可扩展</strong>
<ul>
<li>主从复制、哨兵、Cluster 分片，支持线上扩容、故障切换。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-混合使用：二级缓存策略">3. 混合使用：二级缓存策略</h2>
<p>常见做法是在 <strong>应用内层</strong> 用 Caffeine 作「近缓存（L1）」、在 <strong>网络层</strong> 用 Redis 作「主缓存（L2）」，以兼顾超低延迟和数据一致性／共享。</p>
<p>工作流程示例：</p>
<ol>
<li>读请求先查 L1（Caffeine）</li>
<li>未命中再查 L2（Redis），并回填 L1</li>
<li>写／更新同时写 Redis，再 Invalid L1／主动刷新 L1</li>
</ol>
<p>这样可以</p>
<ul>
<li>显著降低 Redis 压力</li>
<li>保证分布式一致性（短期内有小概率读到过期 L1，可配合 TTL 或消息总线做通知）</li>
</ul>
<h2 id="缓存策略对比">缓存策略对比</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>Cache Aside（旁路缓存）</th>
<th>Write-Through（同步写入）</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>应用主动管理：读操作先查缓存，未命中时从后端加载并写入缓存；写操作更新数据库后再或删除缓存。</td>
<td>写操作同时写入缓存和数据库，保证写入过程中的强一致性；读操作只查缓存（未命中可回源并填充缓存）。</td>
</tr>
<tr>
<td>读流程</td>
<td>1. 应用→缓存查询<br>2. 缓存未命中 → 应用→数据库查询<br>3. 将结果写入缓存 → 返回结果</td>
<td>1. 应用→缓存查询<br>2. 缓存未命中 → 应用→数据库查询并写入缓存 → 返回结果</td>
</tr>
<tr>
<td>写流程</td>
<td>1. 应用→数据库写入<br>2. 写成功后，应用显式删除或更新缓存（使后续读到最新数据）</td>
<td>1. 应用→数据库写入<br>2. 同步更新缓存（写数据到缓存后才返回）</td>
</tr>
<tr>
<td>优点</td>
<td>- 简单灵活，读多写少场景常用<br>- 缓存只存热数据，避免无用缓存<br>- 可自行控制缓存失效时机</td>
<td>- 写入实时更新缓存，读操作命中率高<br>- 保证缓存与数据库强一致性<br>- 应用逻辑更简单，无需显式管理缓存失效</td>
</tr>
<tr>
<td>缺点</td>
<td>- 写操作后需手动维护缓存；若忘记删除/更新缓存会导致读到旧数据<br>- 首次读有额外的数据库延迟</td>
<td>- 每次写都要双写，写延迟增加、数据库负载较大<br>- 若缓存写入失败，需要额外补偿或重试机制</td>
</tr>
<tr>
<td>适用场景</td>
<td>- 读多写少、能容忍一定数据短暂不一致<br>- 热点数据自下而上加载<br>- 应用能严格控制何时失效或更新缓存</td>
<td>- 强一致性要求高的场景<br>- 写入频率适中，能接受写延迟<br>- 希望简化应用层缓存管理逻辑</td>
</tr>
</tbody>
</table>
<p>redis-cli INFO memory | grep used_memory<br>
redis-cli INFO keyspace | grep “^db”</p>
<h2 id="为什么用消息队列">为什么用消息队列</h2>
<p>​解耦性：<br>
支付和订单超时处理是核心业务，但它们的执行时长和成功率不应阻塞主流程。通过消息队列，支付回调（payNotify）只需发送消息到MQ，后续处理（如更新订单状态、库存扣减）由消费者异步完成，避免支付宝回调接口因处理时间长而超时。<br>
示例：OrderController.payNotify 发送消息到 payment.exchange 后立即返回&quot;success&quot;，避免支付宝重复回调。<br>
​异步提速：<br>
同步处理需等待所有步骤完成（如支付验证、订单更新、库存操作），而异步将耗时操作（如库存锁定）交给消费者，缩短接口响应时间。<br>
​可靠性：<br>
消息队列提供持久化、重试和死信机制。例如，在 PaymentResultConsumer 中，若处理支付结果失败，可通过 basicNack 重试或进入死信队列，避免数据不一致。<br>
​流量削峰：<br>
高并发时，MQ作为缓冲区，避免瞬间流量压垮数据库。订单创建和支付回调的高峰期，消息可堆积在队列中逐步消费。</p>
<p>TTL+DLX vs 插件：优缺点对比**<br>
​方案	​优点	​缺点	​适用场景<br>
TTL+DLX	无需插件，兼容性好	队列级固定TTL，无法单消息定制延迟	所有订单统一超时时间<br>
x-delayed-message	消息级延迟，灵活控制	需安装插件，运维复杂	动态延迟（如不同订单）<br>
​项目选择插件的原因：<br>
订单超时时间可能动态调整（例如促销活动延长支付时间），插件支持每条消息独立设置延迟。</p>
<p>手动确认 vs 自动确认**<br>
​手动确认优势：<br>
确保消息处理成功后才确认。例如，在 PaymentResultConsumer 中，只有订单状态更新成功后才发送 basicAck，避免消息丢失。<br>
自动确认在消费者接收消息后立即确认，若后续处理失败，消息无法恢复。</p>
<h2 id="login">login</h2>
<p>Q4.1（认证流程）<br>
认证流程：​</p>
<p>​提交凭证：用户发送登录请求到 AccountController.login，携带用户名和密码。<br>
​验证凭证：服务层校验密码（BCrypt 哈希比对）。<br>
​生成令牌：JwtUtil 生成 JWT，载荷包含 userId、username、role，签名使用密钥。<br>
​返回令牌：令牌通过响应头返回客户端。<br>
​后续请求：客户端在 Authorization 头携带 Bearer <token>。<br>
​拦截器验证：JwtInterceptor 验证签名、过期时间，解析出 userId 和 username 存入请求属性。<br>
​控制器访问：通过 @RequestAttribute(“userId”) 获取用户身份。<br>
JWT 载荷信息：​</p>
<p>​包含字段：userId（唯一标识用户）、username（显示用）、role（授权用）。<br>
​安全考量：<br>
​不存储敏感信息​（如密码）。<br>
​签名防篡改：确保令牌完整性。<br>
​短期有效期：通过 exp 字段限制令牌生命周期。</p>
<h2 id="JPA">JPA</h2>
<p>当你先执行一条查询拿到 N 条父实体（例如：SELECT * FROM product），然后在循环里依次访问其延迟加载的子集合（如 product.getSpecifications()），就会针对每一个父实体再发起一次子查询。<br>
总共产生 1（父查询）+ N（每个父实体一个子查询） 条 SQL，故称 N+1 问题。<br>
SELECT p.<em>, s.</em><br>
FROM product p<br>
LEFT JOIN specification s ON s.product_id = <a target="_blank" rel="noopener" href="http://p.id">p.id</a>;<br>
通过 JPQL 的 JOIN FETCH，Hibernate 会在一条 SQL 里同时把 Product 和它的 specifications 一并加载</p>
<h1>花旗杯</h1>
<h2 id="拦截器-等等">拦截器 等等</h2>
<p>LoginInterceptor 与 CorsFilter 的执行顺序及跨域鉴权协作<br>
执行顺序：</p>
<p>CorsFilter 作为 @Order(Ordered.HIGHEST_PRECEDENCE)，优先执行，处理跨域请求的CORS头。<br>
LoginInterceptor 作为后续拦截器，进行鉴权。<br>
跨域与鉴权的协作：</p>
<p>CorsFilter确保浏览器允许跨域请求（设置Access-Control-Allow-Origin等），使请求能到达后端。<br>
后端的LoginInterceptor在请求到达后，校验请求头中的token，确认用户身份。<br>
这样即使跨域请求允许发起，鉴权也能在请求到达后端进行。</p>

      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">1.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%89%8B%E5%86%8C%E5%AF%B9%E5%A4%96%E9%94%AE%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.1.</span> <span class="nav-text">一、阿里巴巴手册对外键的建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">原因分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%A4%96%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">二、外键索引的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">1. 基本工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%8E%E6%9C%89%E7%BA%A6%E6%9D%9F%E5%A4%96%E9%94%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">2. 与有约束外键的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">3. 索引选择算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.7.</span> <span class="nav-text">三、实际应用建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BA%94%E8%AF%A5%E5%BB%BA%E7%AB%8B%E5%A4%96%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">1.8.</span> <span class="nav-text">1. 应该建立外键索引的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%BB%BA%E7%AB%8B%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">1.9.</span> <span class="nav-text">2. 不建议建立的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.10.</span> <span class="nav-text">3. 最佳实践示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%AF%B9%E6%AF%94"><span class="nav-number">1.11.</span> <span class="nav-text">四、性能影响对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9C%89%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E6%97%B6"><span class="nav-number">1.12.</span> <span class="nav-text">1. 有外键约束时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8F%AA%E6%9C%89%E5%A4%96%E9%94%AE%E7%B4%A2%E5%BC%95%E6%97%B6"><span class="nav-number">1.13.</span> <span class="nav-text">2. 只有外键索引时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.14.</span> <span class="nav-text">五、总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Caffeine"><span class="nav-number">2.</span> <span class="nav-text">Caffeine</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">问题群 2: 业务逻辑与服务层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98-%E8%AF%B7%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E6%B5%81%E7%A8%8B%E3%80%82"><span class="nav-number">1.</span> <span class="nav-text">1. 基础问题: 请简要描述一下订单服务的功能和流程。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">问题群 3: 缓存策略与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JWT"><span class="nav-number">1.</span> <span class="nav-text">JWT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%BE%A4-5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">问题群 5: 消息队列与异步处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-AND-Caffeine"><span class="nav-number">3.</span> <span class="nav-text">Redis AND Caffeine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E7%89%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">1. 数据访问特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.</span> <span class="nav-text">2. 适用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%BD%93%E9%80%89-Caffeine"><span class="nav-number">5.1.</span> <span class="nav-text">2.1 当选 Caffeine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%BD%93%E9%80%89-Redis"><span class="nav-number">5.2.</span> <span class="nav-text">2.2 当选 Redis</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">6.</span> <span class="nav-text">3. 混合使用：二级缓存策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%AF%B9%E6%AF%94"><span class="nav-number">7.</span> <span class="nav-text">缓存策略对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">8.</span> <span class="nav-text">为什么用消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#login"><span class="nav-number">9.</span> <span class="nav-text">login</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JPA"><span class="nav-number">10.</span> <span class="nav-text">JPA</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">花旗杯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8-%E7%AD%89%E7%AD%89"><span class="nav-number">1.</span> <span class="nav-text">拦截器 等等</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Zhan"
      src="/notes.github.io/images/woshicaigou.jpg">
  <p class="site-author-name" itemprop="name">Chen Zhan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/notes.github.io/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Zhan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/notes.github.io/lib/anime.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/notes.github.io/js/utils.js"></script>

<script src="/notes.github.io/js/motion.js"></script>


<script src="/notes.github.io/js/schemes/pisces.js"></script>


<script src="/notes.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

</body>
</html>
