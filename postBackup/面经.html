<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/notes.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/notes.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/notes.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/notes.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/notes.github.io/css/main.css">


<link rel="stylesheet" href="/notes.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhan20050128.github.io","root":"/notes.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="0519 幻读和GapLock 先后两次执行相同的范围查询，却“前后结果不一样”：第二次多了（或少了）一些行——这些新出现（或消失）的行就称为“phantom rows”，现象称为幻读。 例子（隔离级别：READ COMMITTED）  事务 A：1234567891011121314151617181920212223242526272829303132333435363738394041424">
<meta property="og:type" content="website">
<meta property="og:title" content="面经">
<meta property="og:url" content="https://chenzhan20050128.github.io/notes.github.io/postBackup/%E9%9D%A2%E7%BB%8F.html">
<meta property="og:site_name" content="cz Blog">
<meta property="og:description" content="0519 幻读和GapLock 先后两次执行相同的范围查询，却“前后结果不一样”：第二次多了（或少了）一些行——这些新出现（或消失）的行就称为“phantom rows”，现象称为幻读。 例子（隔离级别：READ COMMITTED）  事务 A：1234567891011121314151617181920212223242526272829303132333435363738394041424">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-23T04:27:03.000Z">
<meta property="article:modified_time" content="2025-06-23T04:27:03.413Z">
<meta property="article:author" content="Chen Zhan">
<meta property="article:tag" content="其他">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chenzhan20050128.github.io/notes.github.io/postBackup/%E9%9D%A2%E7%BB%8F">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>面经 | cz Blog
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/notes.github.io/atom.xml" title="cz Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/notes.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cz Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/notes.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/notes.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/chenzhan20050128" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">面经
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <h1>0519</h1>
<h2 id="幻读和GapLock">幻读和GapLock</h2>
<p>先后两次执行相同的范围查询，却“前后结果不一样”：第二次多了（或少了）一些行——这些新出现（或消失）的行就称为“phantom rows”，现象称为幻读。</p>
<p>例子（隔离级别：READ COMMITTED）</p>
<ol>
<li>事务 A：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>;  </span><br><span class="line">   <span class="comment">-- 假设此时返回 5 行</span></span><br><span class="line">   ```  </span><br><span class="line"><span class="number">2.</span> 同时，事务 B 插入了一条满足 amount <span class="operator">&gt;</span> <span class="number">100</span> 的新记录，并提交。  </span><br><span class="line"><span class="number">3.</span> 事务 A 再次执行同样的查询：  </span><br><span class="line">   ```<span class="keyword">sql</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line">   ```  </span><br><span class="line">   这次会看到 <span class="number">6</span> 行，多出来的那行就是“幻读”——之前不存在、现在却出现了。</span><br><span class="line"></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">Gap Lock（间隙锁） <span class="operator">&amp;</span> Next<span class="operator">-</span>Key Lock  </span><br><span class="line">InnoDB 在可重复读（REPEATABLE READ）及以上隔离级别下，对以下操作（<span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span><span class="operator">/</span><span class="keyword">SELECT</span> … <span class="keyword">FOR</span> <span class="keyword">UPDATE</span><span class="operator">/</span>LOCK <span class="keyword">IN</span> SHARE MODE）会使用 <span class="operator">*</span><span class="operator">*</span>Next<span class="operator">-</span>Key Lock<span class="operator">*</span><span class="operator">*</span>，本质上是：</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> Record Lock：锁住已有索引键值对应的记录  </span><br><span class="line"><span class="operator">-</span> Gap Lock：锁住两个相邻索引值之间的“间隙”（不含边界的记录本身）  </span><br><span class="line"></span><br><span class="line">这样，对一个范围 `a <span class="operator">&lt;</span> col ≤ b`，InnoDB 会在 `a` 和 `b` 之间，以及它们各自的左右相邻记录之间，全部加上 Gap Lock。  </span><br><span class="line"></span><br><span class="line">为什么 Gap Lock 能防止幻读？  </span><br><span class="line"><span class="operator">-</span> 事务 A 首次读到某个范围后，对该范围施加了 Gap Lock。  </span><br><span class="line"><span class="operator">-</span> 这样，事务 B 就 <span class="operator">*</span><span class="operator">*</span>无法<span class="operator">*</span><span class="operator">*</span> 在这个范围内插入任何新行（因为插入要占用某个间隙，而该间隙已被锁定）。  </span><br><span class="line"><span class="operator">-</span> 所以，即使事务 B 提交，事务 A 再次查询时，也不会看到“新幻影”——范围内的行集保持不变。</span><br><span class="line"></span><br><span class="line">简而言之，Gap Lock 在索引的“空白”上也加锁，阻止并发事务往原先读取过的范围插入新记录，从而杜绝幻读。</span><br><span class="line"></span><br><span class="line">“(<span class="operator">*</span>) 通过间隙锁可避免幻读，但需显式加锁”</span><br><span class="line">核心点：InnoDB 在默认的可重复读隔离级别下，可以通过加间隙锁（Gap Lock） 来避免幻读。</span><br><span class="line">但：如果没有显式地在事务中加锁（比如没有用 <span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> 或 LOCK <span class="keyword">IN</span> SHARE MODE），那么幻读仍然可能发生。</span><br><span class="line"></span><br><span class="line">## Redis原子化操作的底层原理？</span><br><span class="line">Lua 脚本 (EVAL)</span><br><span class="line"></span><br><span class="line">将多条命令写在一个 Lua 脚本里，提交给 Redis 后，服务器会在脚本执行期间 完全阻塞 事件循环。</span><br><span class="line">脚本内所有调用 redis.call(...) 的命令都在同一个上下文里连贯执行，中途不会被打断。</span><br><span class="line">这样就保证了跨命令的复杂逻辑也能做到“要么全做完要么不做”。</span><br><span class="line"></span><br><span class="line">## RedLock</span><br><span class="line">### <span class="number">1.</span> 证明RedLock的正确性  </span><br><span class="line">RedLock的正确性基于以下设计原则和反驳争议的论点：  </span><br><span class="line"></span><br><span class="line">#### <span class="operator">*</span><span class="operator">*</span>核心保证机制<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>多数派原则<span class="operator">*</span><span class="operator">*</span>：客户端需在过半（如<span class="number">5</span>个实例中的<span class="number">3</span>个）Redis实例上成功获取锁，确保即使部分节点故障，锁仍有效。  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>时钟误差容忍<span class="operator">*</span><span class="operator">*</span>：Redis作者Antirez指出，RedLock仅需时钟大体一致（允许微小误差），通过运维避免大幅时钟跳跃即可满足要求。  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>锁持有时间校验<span class="operator">*</span><span class="operator">*</span>：客户端在获取锁后计算实际耗时（T2<span class="operator">-</span>T1），若超过锁的过期时间则主动放弃锁，避免因网络延迟或GC导致锁冲突。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">### <span class="number">2.</span> 设置唯一标识（UUID）和过期时间的原因  </span><br><span class="line">#### <span class="operator">*</span><span class="operator">*</span>唯一标识（UUID）的作用<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>防误删锁<span class="operator">*</span><span class="operator">*</span>：释放锁时需验证UUID，确保只有锁的持有者能删除锁，避免其他客户端误删。  </span><br><span class="line">  <span class="operator">-</span> <span class="operator">*</span>示例<span class="operator">*</span>：客户端A持有锁后因GC暂停，锁过期被客户端B获取。若A恢复后尝试释放锁，因UUID不匹配，无法删除B的锁。  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>避免锁冲突<span class="operator">*</span><span class="operator">*</span>：唯一标识确保锁的全局唯一性，防止不同客户端的锁请求混淆。  </span><br><span class="line"></span><br><span class="line">#### <span class="operator">*</span><span class="operator">*</span>过期时间（TTL）的作用<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>防止死锁<span class="operator">*</span><span class="operator">*</span>：若客户端崩溃未主动释放锁，过期时间确保锁自动释放，避免资源永久阻塞。  </span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>活性保证<span class="operator">*</span><span class="operator">*</span>：限制锁的最大持有时间，确保其他客户端在超时后有机会获取锁。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Spring AOP及代理模式的实现？</span><br><span class="line">代理模式在Spring AOP中的实现</span><br><span class="line">​</span><br><span class="line">###（<span class="number">1</span>）JDK动态代理</span><br><span class="line"></span><br><span class="line">​适用条件：目标对象实现了至少一个接口。</span><br><span class="line">​原理：基于Java反射机制，通过Proxy.newProxyInstance()生成代理对象，代理类实现与目标对象相同的接口。</span><br><span class="line"></span><br><span class="line">## <span class="number">1.</span> 核心概念</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>Proxy 类<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line">  `java.lang.reflect.Proxy`，Java 自带的动态代理入口，负责在运行时生成代理类字节码，并加载到 JVM。</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>InvocationHandler 接口<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line">  代理实例方法调用时的“调度中心”，所有对代理实例的方法调用，都会被转给它的 `invoke(...)` 方法去处理。</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="operator">*</span><span class="operator">*</span>目标对象（target）<span class="operator">*</span><span class="operator">*</span>  </span><br><span class="line">  真正要被增强的对象，必须实现了一个或多个接口。</span><br><span class="line"></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line">## <span class="number">2.</span> 代码回顾</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class JdkProxyHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public Object createProxy(Object target) &#123;</span><br><span class="line">        this.target <span class="operator">=</span> target;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span> 生成并返回代理对象</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            this</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            this</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public Object invoke(Object proxy, <span class="keyword">Method</span> <span class="keyword">method</span>, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;前置通知&quot;);</span><br><span class="line">        Object <span class="keyword">result</span> <span class="operator">=</span> method.invoke(target, args);  <span class="operator">/</span><span class="operator">/</span> 调用真实对象方法</span><br><span class="line">        System.out.println(&quot;后置通知&quot;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p><code>createProxy(...)</code>：<br>
调用 <code>Proxy.newProxyInstance</code>，传入</p>
<ol>
<li>类加载器（和目标类一致）</li>
<li>接口列表（目标对象实现的接口）</li>
<li>当前 InvocationHandler 实例（把增强逻辑写在 <code>invoke</code> 里）</li>
</ol>
</li>
<li>
<p><code>invoke(...)</code>：<br>
真正发生“代理增强”的地方：前置处理 → 反射调用真实方法 → 后置处理。<br>
JDK 动态代理的限制：<br>
只能代理接口，无法直接给普通类（没有接口）生成代理。<br>
如果目标类没有任何接口，通常用 CGLIB、ByteBuddy 等库，它们是基于生成子类字节码来做代理。</p>
</li>
</ul>
<h3 id="CGLIB代理">CGLIB代理</h3>
<p>CGLIB通过ASM字节码操作框架在运行时动态生成目标类的子类，并在子类中重写非final方法。代理类通过方法拦截器（MethodInterceptor）​将方法调用委托给用户定义的增强逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(targetClass);</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键步骤</p>
<ol>
<li>
<p><strong>生成代理类</strong>：</p>
<ul>
<li>使用<code>Enhancer</code>类指定目标类（父类），生成其子类字节码。</li>
<li>子类会继承目标类的所有非<code>final</code>方法，并重写这些方法以插入拦截逻辑。</li>
</ul>
</li>
<li>
<p><strong>方法拦截</strong>：</p>
<ul>
<li>代理类重写的方法会调用<code>MethodInterceptor.intercept()</code>，该方法接收四个参数：
<ul>
<li><code>obj</code>：代理对象。</li>
<li><code>method</code>：目标方法。</li>
<li><code>args</code>：方法参数。</li>
<li><code>proxy</code>：方法代理（用于调用父类原始方法）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="与JDK动态代理的对比"><strong>与JDK动态代理的对比</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CGLIB代理</strong></th>
<th><strong>JDK动态代理</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>代理方式</strong></td>
<td>继承目标类，生成子类</td>
<td>实现目标接口，生成接口实现类</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>更高（直接调用父类方法，无反射开销）</td>
<td>较低（反射调用接口方法）</td>
</tr>
<tr>
<td><strong>限制</strong></td>
<td>无法代理<code>final</code>类或方法</td>
<td>只能代理实现了接口的类</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>Spring AOP（无接口时默认使用）</td>
<td>微服务接口代理</td>
</tr>
</tbody>
</table>
<h3 id="Spring中的应用？">Spring中的应用？</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>     <span class="comment">// 表示这是一个切面类</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">// 让Spring能自动扫描并管理这个Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 定义切入点：匹配com.example.service包下所有类的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">txPoint</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在切入点方法执行前执行</span></span><br><span class="line">    <span class="meta">@Before(&quot;txPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;开启事务&quot;</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在切入点方法正常返回后执行</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;txPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;提交事务&quot;</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在切入点方法抛出异常时执行</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;txPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;回滚事务&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和一个业务 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String user)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>启动时扫描到 <code>TxAspect</code>，生成一个 <code>DefaultPointcutAdvisor</code>，其中封装了 <code>AspectJMethodBeforeAdvice</code>、<code>AspectJAfterReturningAdvice</code>、<code>AspectJAfterThrowingAdvice</code>。</li>
<li><code>AnnotationAwareAspectJAutoProxyCreator</code> 在 <code>postProcessAfterInitialization(userServiceImpl, &quot;userService&quot;)</code> 时：
<ul>
<li>发现该 Bean 类匹配切点 → 创建 <code>ProxyFactory</code> → 组装所有 AdviceChain → 调用 <code>getProxy()</code>。</li>
</ul>
</li>
<li>对外暴露的 <code>userService</code> 实际是一个代理。</li>
<li>当客户端调用 <code>userService.register(&quot;zhang&quot;)</code> 时：
<ul>
<li>代理的 <code>invoke()</code>（或 <code>intercept()</code>）被触发 → 构建 <code>MethodInvocation</code> 链 → 执行：
<ol>
<li><code>AspectJMethodBeforeAdvice</code>（开启事务）</li>
<li>目标方法 <code>register</code></li>
<li><code>AspectJAfterReturningAdvice</code>（提交事务）</li>
<li>如果抛异常，则执行 <code>AspectJAfterThrowingAdvice</code>（回滚事务）</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1>0522</h1>
<h2 id="Java中static和final关键字的联系与区别">Java中static和final关键字的联系与区别</h2>
<h3 id="核心区别">核心区别</h3>
<p><code>static</code>和<code>final</code>是Java中两个独立但经常结合使用的关键字，它们的主要区别在于：</p>
<ul>
<li><code>static</code>表示&quot;静态的&quot;，强调<strong>属于类而非对象</strong>，所有实例共享同一份拷贝</li>
<li><code>final</code>表示&quot;最终的&quot;，强调<strong>不可修改</strong>，变量值不能改、方法不能重写、类不能继承</li>
</ul>
<h3 id="1-修饰变量时的区别">1. 修饰变量时的区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>static变量</th>
<th>final变量</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>访问方式</strong></td>
<td>可通过类名直接访问</td>
<td>需通过对象实例访问(除非也是static)</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全(需同步)</td>
<td>线程安全(不可变)</td>
</tr>
<tr>
<td><strong>初始化时机</strong></td>
<td>类加载时初始化</td>
<td>声明时或构造函数中初始化</td>
</tr>
<tr>
<td><strong>共享性</strong></td>
<td>所有实例共享同一份</td>
<td>每个实例可以有自己的final变量</td>
</tr>
<tr>
<td><strong>存储位置</strong></td>
<td>方法区的静态区域</td>
<td>基本类型在栈，引用类型在堆</td>
</tr>
<tr>
<td><strong>修改性</strong></td>
<td>可以修改</td>
<td>初始化后不能修改</td>
</tr>
</tbody>
</table>
<h3 id="2-修饰方法时的区别">2. 修饰方法时的区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>static方法</th>
<th>final方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>调用方式</strong></td>
<td>通过类名调用</td>
<td>通过对象实例调用</td>
</tr>
<tr>
<td><strong>重写性</strong></td>
<td>可被继承但不能重写(隐藏)</td>
<td>不能被子类重写</td>
</tr>
<tr>
<td><strong>访问限制</strong></td>
<td>只能访问静态成员</td>
<td>可以访问所有成员</td>
</tr>
<tr>
<td><strong>多态性</strong></td>
<td>不支持多态(静态绑定)</td>
<td>支持多态(除非private)</td>
</tr>
</tbody>
</table>
<h3 id="3-修饰类时的区别">3. 修饰类时的区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>static类(仅内部类)</th>
<th>final类</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义范围</strong></td>
<td>只能是内部类</td>
<td>可以是任何类</td>
</tr>
<tr>
<td><strong>继承性</strong></td>
<td>可以继承其他类</td>
<td>不能被继承</td>
</tr>
<tr>
<td><strong>实例化</strong></td>
<td>不依赖外部类实例</td>
<td>可以正常实例化</td>
</tr>
<tr>
<td><strong>方法默认修饰</strong></td>
<td>方法不默认final</td>
<td>所有方法隐式final</td>
</tr>
</tbody>
</table>
<h2 id="JVM动态绑定">JVM动态绑定</h2>
<p>JVM使用虚方法表(vtable)实现动态绑定：</p>
<p>每个类都有一个虚方法表，包含该类所有可重写方法的入口地址</p>
<p>子类继承父类的虚方法表，然后替换重写方法的入口地址</p>
<p>调用方法时，JVM根据对象的实际类查找虚方法表，找到正确的方法实现</p>
<h2 id="read-commit-vs-serializable">read commit vs serializable</h2>
<h3 id="关键区别总结"><strong>关键区别总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Read Committed</strong></th>
<th><strong>Serializable</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁范围</strong></td>
<td>仅锁定现有行和部分间隙</td>
<td>锁定所有可能影响的间隙（Next-Key Lock）</td>
</tr>
<tr>
<td><strong>锁释放时机</strong></td>
<td>行锁在读取后立即释放</td>
<td>锁持续到事务结束</td>
</tr>
<tr>
<td><strong>索引依赖</strong></td>
<td>未覆盖的索引间隙可能导致幻读</td>
<td>所有索引范围被锁定</td>
</tr>
<tr>
<td><strong>并发性能</strong></td>
<td>高</td>
<td>低（锁冲突多）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="实现细节（以-MySQL-InnoDB-为例）"><strong>实现细节（以 MySQL InnoDB 为例）</strong></h3>
<ul>
<li>
<p><strong>Read Committed</strong>：</p>
<ul>
<li>仅对访问到的行加行锁，间隙锁仅在唯一索引唯一性检查时使用。</li>
<li>允许其他事务在未锁定的间隙插入数据。</li>
</ul>
</li>
<li>
<p><strong>Serializable</strong>：</p>
<ul>
<li>所有读取操作自动转换为 <code>SELECT ... FOR SHARE</code>，对查询涉及的索引范围加 Next-Key Lock。</li>
<li>完全禁止其他事务在锁定范围内插入或删除。</li>
</ul>
</li>
</ul>
<h2 id="HashMap">HashMap</h2>
<hr>
<h2 id="1-HashMap-的基本工作原理">1. HashMap 的基本工作原理</h2>
<p>HashMap 底层是一个 Node&lt;K,V&gt;[] 数组（JDK 1.7 叫 Entry[]），每个元素要么为 null，要么是一个链表／红黑树的头节点。</p>
<ul>
<li>
<p><strong>put(K key, V value)</strong></p>
<ol>
<li>计算 hash = hash(key)；</li>
<li>如果 table 未初始化，则调用 resize() 初始化（默认容量 16）；</li>
<li>根据 index = (table.length–1) &amp; hash 定位桶位置；</li>
<li>若 table[index] 为 null，直接创建 new Node(key, value) 放入；</li>
<li>否则遍历链表／树：
<ul>
<li>找到相同 key，则覆盖 value；</li>
<li>否则插入新节点（JDK 1.7 链表头插，JDK 1.8 链表尾插并可能触发“树化”）；</li>
</ul>
</li>
<li>插入后若 size &gt; threshold(=capacity×loadFactor)，则触发 resize() 扩容。</li>
</ol>
</li>
<li>
<p><strong>get(Object key)</strong></p>
<ol>
<li>计算 hash 和 index；</li>
<li>遍历 table[index] 上的链表／树，按 key.equals() 找到即返回 value，否则返回 null。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">  Node&lt;K,V&gt; e = table[(n-<span class="number">1</span>) &amp; hash];</span><br><span class="line">  <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.hash==hash &amp;&amp; Objects.equals(e.key, key))</span><br><span class="line">      <span class="keyword">return</span> e.value;</span><br><span class="line">    e = e.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="concurrentHashMap">concurrentHashMap</h3>
<h4 id="JDK-1-8-实现（CAS-synchronized-链表-树化）">JDK 1.8 实现（CAS + synchronized + 链表/树化）</h4>
<ul>
<li>去掉 Segment，底层直接是 <code>Node&lt;K,V&gt;[] table</code>；</li>
<li><strong>初始化 table</strong>：采用 CAS 保证只有一个线程完成第一次初始化；</li>
<li><strong>put 操作</strong>：
<ol>
<li>CAS 尝试将新节点放入空桶；</li>
<li>若 CAS 失败（已有节点或并发竞争），对该桶头节点加 <code>synchronized(bin)</code> 锁，安全地在链表尾部插入或在必要时树化；</li>
<li>解锁后，如需扩容，则发起一次 “单线程” 扩容（转移节点时用 CAS 标记前驱为 forwardingNode，其它线程在访问时可以帮忙迁移）；</li>
</ol>
</li>
<li><strong>get 操作</strong>：
<ul>
<li>全程无锁，只做 volatile 读 + 链表／树遍历。</li>
</ul>
</li>
<li><strong>扩容（resize）</strong>：
<ul>
<li>不再一次性锁整个 table，而是通过 CAS+forwardingNode 让多个线程协作“分段”搬运节点；</li>
</ul>
</li>
<li>优点：更轻量级的并发控制，高并发下性能优；内存开销更小。</li>
</ul>
<h2 id="Bean">Bean</h2>
<p>以下是整理的 Spring Bean 生命周期执行过程的逻辑流程图，按阶段划分并标注关键步骤：</p>
<hr>
<h3 id="Spring-Bean-生命周期完整流程"><strong>Spring Bean 生命周期完整流程</strong></h3>
<h4 id="1-实例化阶段"><strong>1. 实例化阶段</strong></h4>
<ul>
<li><strong>步骤1</strong>：Spring 容器启动，扫描并加载 Bean 定义（BeanDefinition）。</li>
<li><strong>步骤2</strong>：通过反射调用构造方法实例化 Bean（默认使用无参构造，或指定构造器）。</li>
</ul>
<h4 id="2-属性注入阶段"><strong>2. 属性注入阶段</strong></h4>
<ul>
<li><strong>步骤3</strong>：依赖注入（DI），通过 setter 或字段注入完成 Bean 的属性赋值（如 <code>@Autowired</code>、<code>@Value</code>）。</li>
</ul>
<h4 id="3-Aware-接口回调（感知容器信息）"><strong>3. Aware 接口回调（感知容器信息）</strong></h4>
<ul>
<li><strong>步骤4</strong>：若实现 <code>BeanNameAware</code>，调用 <code>setBeanName(String beanId)</code> 传入 Bean 的 ID。</li>
<li><strong>步骤5</strong>：若实现 <code>BeanFactoryAware</code>，调用 <code>setBeanFactory(BeanFactory factory)</code> 传入工厂实例。</li>
<li><strong>步骤6</strong>：若实现 <code>ApplicationContextAware</code>，调用 <code>setApplicationContext(ApplicationContext ctx)</code> 传入应用上下文。</li>
</ul>
<h4 id="4-初始化前阶段（BeanPostProcessor-前置处理）"><strong>4. 初始化前阶段（<code>BeanPostProcessor</code> 前置处理）</strong></h4>
<ul>
<li><strong>步骤7</strong>：若存在 <code>BeanPostProcessor</code>，调用 <code>postProcessBeforeInitialization(Object bean, String beanName)</code>（AOP 代理在此生成）。</li>
</ul>
<h4 id="5-初始化阶段"><strong>5. 初始化阶段</strong></h4>
<ul>
<li><strong>步骤8</strong>：若实现 <code>InitializingBean</code>，调用 <code>afterPropertiesSet()</code> 方法。</li>
<li><strong>步骤9</strong>：若配置了 <code>init-method</code> 或使用 <code>@PostConstruct</code>，调用指定的初始化方法。</li>
</ul>
<h4 id="6-初始化后阶段（BeanPostProcessor-后置处理）"><strong>6. 初始化后阶段（<code>BeanPostProcessor</code> 后置处理）</strong></h4>
<ul>
<li><strong>步骤10</strong>：若存在 <code>BeanPostProcessor</code>，调用 <code>postProcessAfterInitialization(Object bean, String beanName)</code>。此时 Bean 已完全就绪，可被使用。</li>
</ul>
<h4 id="7-使用阶段"><strong>7. 使用阶段</strong></h4>
<ul>
<li><strong>步骤11</strong>：
<ul>
<li><strong>Singleton</strong>：Bean 被放入 Spring IoC 单例缓存池，由容器管理生命周期。</li>
<li><strong>Prototype</strong>：Bean 交给调用方管理，Spring 不再跟踪其生命周期。</li>
</ul>
</li>
</ul>
<h4 id="8-销毁阶段"><strong>8. 销毁阶段</strong></h4>
<ul>
<li><strong>步骤12</strong>：若实现 <code>DisposableBean</code>，调用 <code>destroy()</code> 方法。</li>
<li><strong>步骤13</strong>：若配置了 <code>destroy-method</code> 或使用 <code>@PreDestroy</code>，调用指定的销毁方法。</li>
</ul>

      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">0519</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BB%E8%AF%BB%E5%92%8CGapLock"><span class="nav-number">1.1.</span> <span class="nav-text">幻读和GapLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CGLIB%E4%BB%A3%E7%90%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">CGLIB代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8EJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.2.</span> <span class="nav-text">与JDK动态代理的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">Spring中的应用？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">0522</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%ADstatic%E5%92%8Cfinal%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.</span> <span class="nav-text">Java中static和final关键字的联系与区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.</span> <span class="nav-text">核心区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.2.</span> <span class="nav-text">1. 修饰变量时的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.3.</span> <span class="nav-text">2. 修饰方法时的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BF%AE%E9%A5%B0%E7%B1%BB%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.4.</span> <span class="nav-text">3. 修饰类时的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="nav-number">2.2.</span> <span class="nav-text">JVM动态绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#read-commit-vs-serializable"><span class="nav-number">2.3.</span> <span class="nav-text">read commit vs serializable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="nav-number">2.3.1.</span> <span class="nav-text">关键区别总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%88%E4%BB%A5-MySQL-InnoDB-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="nav-number">2.3.2.</span> <span class="nav-text">实现细节（以 MySQL InnoDB 为例）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">2.4.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-HashMap-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">1. HashMap 的基本工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrentHashMap"><span class="nav-number">2.5.1.</span> <span class="nav-text">concurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-8-%E5%AE%9E%E7%8E%B0%EF%BC%88CAS-synchronized-%E9%93%BE%E8%A1%A8-%E6%A0%91%E5%8C%96%EF%BC%89"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">JDK 1.8 实现（CAS + synchronized + 链表&#x2F;树化）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean"><span class="nav-number">2.6.</span> <span class="nav-text">Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="nav-number">2.6.1.</span> <span class="nav-text">Spring Bean 生命周期完整流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">1. 实例化阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E9%98%B6%E6%AE%B5"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">2. 属性注入阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Aware-%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83%EF%BC%88%E6%84%9F%E7%9F%A5%E5%AE%B9%E5%99%A8%E4%BF%A1%E6%81%AF%EF%BC%89"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">3. Aware 接口回调（感知容器信息）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D%E9%98%B6%E6%AE%B5%EF%BC%88BeanPostProcessor-%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86%EF%BC%89"><span class="nav-number">2.6.1.4.</span> <span class="nav-text">4. 初始化前阶段（BeanPostProcessor 前置处理）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="nav-number">2.6.1.5.</span> <span class="nav-text">5. 初始化阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E9%98%B6%E6%AE%B5%EF%BC%88BeanPostProcessor-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%EF%BC%89"><span class="nav-number">2.6.1.6.</span> <span class="nav-text">6. 初始化后阶段（BeanPostProcessor 后置处理）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E4%BD%BF%E7%94%A8%E9%98%B6%E6%AE%B5"><span class="nav-number">2.6.1.7.</span> <span class="nav-text">7. 使用阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5"><span class="nav-number">2.6.1.8.</span> <span class="nav-text">8. 销毁阶段</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Zhan"
      src="/notes.github.io/images/woshicaigou.jpg">
  <p class="site-author-name" itemprop="name">Chen Zhan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/notes.github.io/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Zhan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/notes.github.io/lib/anime.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/notes.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/notes.github.io/js/utils.js"></script>

<script src="/notes.github.io/js/motion.js"></script>


<script src="/notes.github.io/js/schemes/pisces.js"></script>


<script src="/notes.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

</body>
</html>
